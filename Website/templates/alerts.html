{% extends 'base.html' %}

{% block title %}Alerts - OSRS Market Tracker{% endblock %}

{% block content %}
<h1>Alerts</h1>
<hr>

<div class="alert-tabs">
    <button class="tab-btn active" data-tab="my-alerts">My Alerts</button>
    <button class="tab-btn" data-tab="create-alert">Create Alert</button>
</div>

<div class="tab-content">
    <div id="my-alerts" class="tab-pane active">
        <div id="triggered-notifications">
            {% for message in messages %}
                <div class="triggered-notification status-notification">
                    {{ message }}
                    <button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>
                </div>
            {% endfor %}
            {% for alert in triggered_alerts %}
                <div class="triggered-notification" data-alert-id="{{ alert.id }}">
                    {{ alert.triggered_text }}
                    <button class="dismiss-btn" onclick="dismissAlert({{ alert.id }})">&times;</button>
                </div>
            {% endfor %}
        </div>
        {% if has_alerts %}
        <div class="alert-actions-wrapper">
            <div class="alert-actions">
                <div class="alert-actions-left">
                    <select id="alert-action-select" class="action-dropdown" onchange="AlertActions.handleAction(this.value); this.value='';">
                        <option value="">Actions</option>
                        <option value="delete">Delete</option>
                        <option value="group">Add to Group</option>
                    </select>
                </div>
                <div class="alert-actions-right" id="active-filters">
                    <div class="alert-actions-controls">
                        <div class="sort-controls">
                            <select class="sort-dropdown" onchange="handleSortSelection(this.value); this.value='';">
                                <option value="">Sort...</option>
                                <option value="lastTriggered">Last Triggered Time</option>
                                <option value="alertType">Alert Type</option>
                                <option value="thresholdDistance">Threshold Distance</option>
                                <option value="createdDate">Created Date</option>
                            </select>
                            <div id="sort-order-picker" class="sort-order-picker" style="display: none;"></div>
                        </div>
                        <select class="filter-dropdown" onchange="addFilter(this.value); this.value='';">
                            <option value="">Add Filter...</option>
                            <option value="triggered">Triggered</option>
                            <option value="notTriggered">Not Triggered</option>
                            <option value="minimumPrice">Minimum Price</option>
                            <option value="maximumPrice">Maximum Price</option>
                            <option value="myGroups">My Groups</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="alert-indicators">
                <div class="filter-tags"></div>
                <div class="sort-tag-holder"></div>
            </div>
        </div>
        <div id="alerts-list-container">
            <div class="loading-container">
                <div class="loading-spinner"></div>
                <span class="loading-text">Loading</span>
            </div>
        </div>
        {% elif not triggered_alerts %}
            <p class="no-alerts">No active alerts. Create one to get started!</p>
        {% endif %}
    </div>
    <div id="create-alert" class="tab-pane" style="display: none;">
        <form method="POST" action="{% url 'create_alert' %}" class="create-alert-form">
            {% csrf_token %}
            <div class="form-group">
                <label for="alert-type">Alert Type</label>
                <select name="type" id="alert-type" required onchange="handleAlertTypeChange()">
                    <option value="above" selected>Above Threshold</option>
                    <option value="below">Below Threshold</option>
                    <option value="spread">Spread</option>
                    <option value="spike">Spike</option>
                </select>
            </div>

            <!-- Number of items (shown for spike only) -->
            <div class="form-group" id="number-items-group" style="display: none;">
                <label for="number-of-items">Number of Items</label>
                <select name="number_of_items" id="number-of-items" onchange="handleSpikeScopeChange()">
                    <option value="one" selected>One</option>
                    <option value="all">All</option>
                </select>
            </div>
            
            <!-- Spread-specific fields -->
            <div class="form-group" id="spread-scope-group" style="display: none;">
                <label for="spread-scope">Apply To</label>
                <select name="spread_scope" id="spread-scope" onchange="handleSpreadScopeChange()">
                    <option value="all">All Items</option>
                    <option value="specific">Specific Item</option>
                </select>
            </div>
            
            <!-- Item fields (shown for above/below, or spread with specific item) -->
            <div class="form-group" id="item-name-group">
                <label for="item-name">Item Name</label>
                <input type="text" name="item_name" id="item-name" autocomplete="off">
                <input type="hidden" name="item_id" id="item-id">
                <input type="hidden" name="is_all_items" id="is-all-items" value="false">
                <div id="item-suggestions" class="suggestions-dropdown"></div>
            </div>
            
            <!-- Price fields (shown for above/below only) -->
            <div class="form-group" id="price-group">
                <label for="price">Price Threshold</label>
                <input type="number" name="price" id="price">
            </div>
            <div class="form-group" id="reference-group">
                <label for="reference">Reference Price</label>
                <select name="reference" id="reference">
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                </select>
            </div>
            
            <!-- Percentage field (shown for spread or spike) -->
            <div class="form-group" id="percentage-group" style="display: none;">
                <label for="percentage">Percentage (%)</label>
                <input type="number" name="percentage" id="percentage" step="0.001" min="0.001">
            </div>

            <!-- Time frame field (shown for spike only) -->
            <div class="form-group" id="time-frame-group" style="display: none;">
                <label for="time-frame">Time Frame (minutes)</label>
                <input type="number" name="time_frame" id="time-frame" min="1" step="1" placeholder="e.g. 10">
            </div>
            
            <!-- Direction field (shown for spike only) -->
            <div class="form-group" id="direction-group" style="display: none;">
                <label for="direction">Direction</label>
                <select name="direction" id="direction">
                    <option value="both" selected>Both</option>
                    <option value="up">Up</option>
                    <option value="down">Down</option>
                </select>
            </div>
            
            <!-- Min/Max price fields (shown for spread all items only) -->
            <div class="form-group" id="min-price-group" style="display: none;">
                <label for="minimum-price">Minimum Price</label>
                <input type="number" name="minimum_price" id="minimum-price" min="0">
            </div>
            <div class="form-group" id="max-price-group" style="display: none;">
                <label for="maximum-price">Maximum Price</label>
                <input type="number" name="maximum_price" id="maximum-price" min="0">
            </div>
            
            <div class="form-group checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" name="email_notification" id="email-notification">
                    Receive SMS Notification
                </label>
            </div>
            
            <button type="submit" class="btn-create-alert">Create Alert</button>
        </form>
    </div>
</div>

<!-- Spread Details Modal -->
<div id="spread-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spread Alert Details</h2>
            <button class="modal-close" onclick="closeSpreadModal()">&times;</button>
        </div>
        <div id="spread-modal-body">
            <ul id="spread-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpreadModal()">Close</button>
        </div>
    </div>
</div>

<!-- Spike Details Modal -->
<div id="spike-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spike Alert Details</h2>
            <button class="modal-close" onclick="closeSpikeModal()">&times;</button>
        </div>
        <div id="spike-modal-body">
            <ul id="spike-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpikeModal()">Close</button>
        </div>
    </div>
</div>

<!-- Group Alerts Modal -->
<div id="group-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Organize Alerts</h2>
            <button class="modal-close" onclick="GroupManager.close()">&times;</button>
        </div>
        <div class="form-group">
            <label>Existing Groups</label>
            <div id="group-list" class="group-list"></div>
        </div>
        <div class="form-group">
            <label for="new-group-input">Add New Groups</label>
            <input type="text" id="new-group-input" placeholder="Comma-separated, e.g. Bossing, Supplies">
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="GroupManager.save()">Save</button>
            <button type="button" class="btn-cancel" onclick="GroupManager.deleteSelectedGroups()" style="margin: 0 auto;">Delete Group(s)</button>
            <button type="button" class="btn-cancel" onclick="GroupManager.close()">Cancel</button>
        </div>
    </div>
</div>

<!-- Groups Filter Modal -->
<div id="groups-filter-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Filter by Groups</h2>
            <button class="modal-close" onclick="closeGroupsFilterModal()">&times;</button>
        </div>
        <div class="form-group">
            <label>Select Groups to Display</label>
            <div id="groups-filter-list" class="group-list pill-padding"></div>
            <p id="no-groups-message" class="no-alerts" style="display: none;">No groups available. Create groups by organizing your alerts first.</p>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="applyGroupsFilter()">Apply Filter</button>
            <button type="button" class="btn-cancel" onclick="closeGroupsFilterModal()">Cancel</button>
        </div>
    </div>
</div>

<!-- Price Filter Modal -->
<div id="price-filter-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="price-filter-title">Set Price Filter</h2>
            <button class="modal-close" onclick="closePriceFilterModal()">&times;</button>
        </div>
        <div class="form-group">
            <label for="price-filter-input" id="price-filter-label">Enter value</label>
            <input type="number" id="price-filter-input" placeholder="Enter price...">
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="applyPriceFilter()">Apply</button>
            <button type="button" class="btn-cancel" onclick="closePriceFilterModal()">Cancel</button>
        </div>
    </div>
</div>
<style>
    .pill-padding span {
        margin-right: 5px;
        margin-left: 5px;
        margin-top: 15px;
    }

    .alert-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }
    .tab-btn {
        padding: 10px 20px;
        border: none;
        background-color: transparent;
        cursor: pointer;
        font-size: 16px;
        border-bottom: 2px solid transparent;
    }
    .tab-btn:hover {
        border-bottom: 2px solid #ccc;
    }
    .tab-btn.active {
        border-bottom: 2px solid #007bff;
        color: #007bff;
    }
    .tab-content {
        padding: 20px;
    }
    .alerts-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .alert-item {
        display: flex;
        align-items: center;
        gap: 12px;
       /* padding: 15px 20px; */
        padding-left: 6px;
        padding-right: 6px;
        margin-bottom: 10px;
        background-color: #cce5ff;
        border-left: 4px solid #007bff;
        border-radius: 8px;
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        max-height: 200px;
        overflow: hidden;
    }
    .alert-item:hover {
        transform: translateX(5px);
        box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
    }
    .alert-item.deleting {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .alert-text {
        flex: 1;
    }
    .alert-triggered {
        font-weight: 700;
        color: #8b5cf6;
        background-color: #ede9fe;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.85rem;
        letter-spacing: 0.5px;
        flex-shrink: 0;
    }
    .alert-threshold {
        font-weight: 600;
        color: orange;
        margin-left: 8px;
        font-size: 0.9rem;
        white-space: nowrap;
        flex-shrink: 0;
    }
    .alert-icon {
        font-size: 1.4rem;
    }
    .alert-text {
        font-size: 1rem;
        color: #333;
    }
    .no-alerts {
        color: #6c757d;
        font-style: italic;
        padding: 20px;
        text-align: center;
    }
    
    /* Loading Indicator */
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        gap: 16px;
    }
    
    .loading-spinner {
        width: 48px;
        height: 48px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        font-size: 1.1rem;
        font-weight: 500;
        color: #6c757d;
        letter-spacing: 0.5px;
    }
    
    .alert-group {
        margin-bottom: 25px;
    }
    .alert-group-header {
        font-size: 1.1rem;
        font-weight: 600;
        color: #007bff;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #fd7e14;
    }
.alert-actions-wrapper {
    margin-bottom: 10px;
}
.alert-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}
.alert-actions-left {
    display: flex;
    gap: 10px;
}
.alert-actions-right {
    display: flex;
    align-items: center;
    gap: 10px;
}
.alert-actions-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}
.action-dropdown {
 /*   padding: 6px 6px 6px 10px; */
 /*    margin-bottom: 6px; */
    border: 1px solid #ccc;
    border-radius: 6px;
    cursor: pointer;
        /* font-weight: 600; */
        background-color: white;
    }
    .action-dropdown:focus {
        outline: none;
        border-color: #007bff;
    }
    .action-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s ease;
    }
    .edit-btn {
        background-color: #007bff;
        color: white;
    }
    .edit-btn:hover {
        background-color: #0056b3;
    }
    .delete-btn {
        background-color: #dc3545;
        color: white;
    }
    .delete-btn:hover {
        background-color: #c82333;
    }
    .confirm-delete-btn {
        background-color: #dc3545;
        color: white;
    }
    .confirm-delete-btn:hover {
        background-color: #c82333;
    }
    .cancel-btn {
        background-color: #6c757d;
        color: white;
    }
    .cancel-btn:hover {
        background-color: #5a6268;
    }
    .alert-checkbox {
        width: 20px;
        height: 20px;
        cursor: pointer;
        accent-color: #dc3545;
        margin-right: 6px;
    }
    .triggered-notification {
        background-color: #28a745;
        color: white;
        padding: 15px 40px 15px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        position: relative;
        font-weight: 500;
        transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        max-height: 100px;
        overflow: hidden;
    }
    .triggered-notification.dismissing {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .triggered-notification .dismiss-btn {
        position: absolute;
        top: 50%;
        right: 15px;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        opacity: 0.8;
    }
    .triggered-notification .dismiss-btn:hover {
        opacity: 1;
    }
    /* Filter UI styles */
    .filter-dropdown {
        /* padding: 6px 6px 8px 10px; */
        border: 1px solid #ccc;
        border-radius: 5px;
        /* font-size: 14px; */
        cursor: pointer;
        background-color: white;
    }
    .filter-dropdown:focus {
        outline: none;
        border-color: #007bff;
    }
    .active-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 15px;
        min-height: 0;
    }
.filter-tag {
    display: inline-flex;
    align-items: center;
    background-color: #007bff;
    color: white;
    padding: 6px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 500;
    animation: filterTagIn 0.3s ease forwards;
    max-width: 200px;
    overflow: hidden;
}
    .filter-tag.removing {
        animation: filterTagOut 0.3s ease forwards;
    }
    @keyframes filterTagIn {
        from {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
            margin: 0;
        }
        to {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 10px;
        }
    }
    @keyframes filterTagOut {
        from {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 10px;
        }
        to {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
            margin: 0;
        }
    }
    .filter-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 6px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.8;
        padding: 0;
    }
    .filter-tag-remove:hover {
        opacity: 1;
    }
    .sort-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .sort-dropdown {
        /* padding: 6px 10px; */
        border: 1px solid #ccc;
        border-radius: 6px;
        cursor: pointer;
        /* font-weight: 600; */
        background-color: white;
    }
    .sort-dropdown:focus {
        outline: none;
        border-color: #fd7e14;
        box-shadow: 0 0 0 2px rgba(253, 126, 20, 0.2);
    }
    .sort-order-picker {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        background: #fff3e6;
        border: 1px solid #fd7e14;
        border-radius: 8px;
    }
    .sort-order-label {
        font-weight: 600;
        color: #d35400;
    }
    .sort-order-btn {
        padding: 4px 9px;
        border: 1px solid #fd7e14;
        background: white;
        color: #d35400;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
        transition: all 0.2s ease;
    }
    .sort-order-btn:hover {
        background: #fd7e14;
        color: white;
    }
.sort-tag {
    background-color: #fd7e14;
    color: white;
    padding: 6px 10px;
    border-radius: 20px;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    margin-right: 8px;
}
    .sort-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 4px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.85;
        padding: 0;
    }
.sort-tag-remove:hover {
    opacity: 1;
}
.alert-indicators {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    flex-wrap: wrap-reverse;
    gap: 8px;
    margin-top: 6px;
}
.filter-tags {
    display: contents;
}
.sort-tag-holder {
    display: contents;
}
    /* Filter input styles */
    .filter-input-container {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        margin-right: 15px;
        animation: filterTagIn 0.3s ease forwards;
    }
    .filter-input {
        padding: 6px 10px;
        border: 1px solid #007bff;
        border-radius: 20px;
        font-size: 13px;
        width: 150px;
        outline: none;
    }
    .filter-input:focus {
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
    }
    .filter-input-confirm,
    .filter-input-cancel {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 4px 4px;
        border-radius: 4px;
    }
    .filter-input-confirm {
        color: #28a745;
    }
    .filter-input-confirm:hover {
        background-color: rgba(40, 167, 69, 0.1);
    }
    .filter-input-cancel {
        color: #dc3545;
    }
    .filter-input-cancel:hover {
        background-color: rgba(220, 53, 69, 0.1);
    }
    .create-alert-form {
        max-width: 400px;
    }
    .form-group {
        margin-bottom: 15px;
        position: relative;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #333;
    }
    .form-group input,
    .form-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 14px;
    }
    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
    }
    .checkbox-group {
        display: flex;
        align-items: center;
    }
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-weight: 600;
        color: #333;
    }
    .checkbox-label input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #007bff;
    }
    .group-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 5px 0;
    }
    .group-checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        border: 1px solid #ccc;
        border-radius: 20px;
        background-color: #f8f9fa;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .group-checkbox-label:hover {
        background-color: #e9ecef;
    }
    .group-checkbox-label input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }
    .group-checkbox-label input[type="checkbox"]:checked + span {
        font-weight: 600;
        color: #007bff;
    }
    .group-pill {
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        border: 1px solid #ccc;
        border-radius: 20px;
        background-color: #f8f9fa;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
    }
    .group-pill:hover {
        background-color: #e9ecef;
        border-color: #adb5bd;
    }
    .group-pill.selected {
        background-color: #fd7e14;
        border-color: #fd7e14;
        color: white;
    }
    .group-pill.selected:hover {
        background-color: #e96b02;
        border-color: #e96b02;
    }
    .btn-create-alert {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-create-alert:hover {
        background-color: #0056b3;
    }
    .suggestions-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 5px 5px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
    }
    .suggestion-item {
        padding: 10px;
        cursor: pointer;
    }
    .suggestion-item:hover,
    .suggestion-item.selected {
        background-color: #007bff;
        color: white;
    }
    .clickable-alert {
        cursor: pointer;
    }
    .clickable-alert:hover {
        background-color: #b8daff;
    }
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .modal-content {
        background-color: white;
        padding: 30px;
        border-radius: 12px;
        width: 100%;
        max-width: 450px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    .modal-header h2 {
        margin: 0;
        color: #333;
    }
    .modal-close {
        background: none;
        border: none;
        font-size: 28px;
        cursor: pointer;
        color: #666;
        line-height: 1;
    }
    .modal-close:hover {
        color: #333;
    }
    .modal-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
    .btn-save {
        flex: 1;
        background-color: #28a745;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-save:hover {
        background-color: #218838;
    }
    .btn-cancel {
        flex: 1;
        background-color: #6c757d;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-cancel:hover {
        background-color: #5a6268;
    }
    .modal-content-large {
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
    }
    #spread-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #spread-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #spread-items-list li:last-child {
        border-bottom: none;
    }
    #spike-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #spike-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #spike-items-list li:last-child {
        border-bottom: none;
    }
    .spread-item-name {
        font-weight: 600;
        color: #333;
    }
    .spread-item-details {
        color: #666;
        font-size: 0.9rem;
    }
    .spread-item-percentage {
        font-weight: 700;
        color: #28a745;
        font-size: 1.1rem;
    }
    .spread-item-percentage.negative-change {
        color: #dc3545;
    }
</style>

<script>
/**
 * =============================================================================
 * OSRS ALERTS MANAGEMENT SYSTEM
 * =============================================================================
 * 
 * This module handles all client-side functionality for the alerts system:
 * - Creating and editing alerts (above/below threshold, spread alerts)
 * - Displaying triggered alerts with real-time updates
 * - Managing alert lifecycle (dismiss, delete)
 * - Item search autocomplete functionality
 * - Modal management for spread details and editing
 * 
 * Architecture:
 * - AlertsConfig: Central configuration object for settings and selectors
 * - AlertsState: Manages application state (filters, cached data, etc.)
 * - AlertsAPI: Handles all server communication
 * - AlertsUI: Manages DOM updates and rendering
 * - FormManager: Handles form field visibility and validation
 * - ModalManager: Controls modal dialogs
 * - AutocompleteManager: Handles item search suggestions
 * - EventManager: Sets up all event listeners
 * 
 * =============================================================================
 */

// =============================================================================
// CONFIGURATION
// =============================================================================
/**
 * Central configuration object containing all settings, selectors, and constants.
 * 
 * Why: Centralizing configuration makes it easy to modify settings without
 * searching through code. It also makes the codebase more maintainable.
 * 
 * How: All DOM selectors, API endpoints, and timing settings are defined here
 * and referenced throughout the application.
 */
const AlertsConfig = {
    // API endpoints for server communication
    endpoints: {
        alerts: '/api/alerts/',
        dismiss: '/api/alerts/dismiss/',
        delete: '/api/alerts/delete/',
        update: '/api/alerts/update/',
        group: '/api/alerts/group/',
        deleteGroups: '/api/alerts/groups/delete/',
        itemSearch: '/api/items/'
    },
    
    // Timing settings (in milliseconds)
    timing: {
        refreshInterval: 5000,      // How often to poll for alert updates
        minSearchLength: 2          // Minimum characters before searching
    },
    
    // Available filters for the alerts list
    // Simple filters have just a test function
    // Input filters have requiresInput: true and testWithValue function
    filters: {
        triggered: { 
            id: 'triggered', 
            label: 'Triggered', 
            test: alert => alert.is_triggered 
        },
        notTriggered: { 
            id: 'notTriggered', 
            label: 'Not Triggered', 
            test: alert => !alert.is_triggered 
        },
        minimumPrice: {
            id: 'minimumPrice',
            label: 'Minimum Price',
            shortLabel: 'Min',
            requiresInput: true,
            requiresModal: true,
            inputType: 'number',
            inputPlaceholder: 'Enter minimum price...',
            testWithValue: (alert, value) => {
                const minPrice = parseInt(value);
                if (isNaN(minPrice)) return true;
                
                // For above/below alerts, use the current price for the chosen reference (high/low)
                if (alert.type === 'above' || alert.type === 'below') {
                    if (alert.current_price != null) {
                        return alert.current_price >= minPrice;
                    }
                    return false;
                }
                
                // For spread alerts with all items, use minimum_price field
                if (alert.type === 'spread' && alert.is_all_items) {
                    return (alert.minimum_price || 0) >= minPrice;
                }
                
                // For spread alerts with single item, use current low price
                if (alert.type === 'spread' && !alert.is_all_items) {
                    return (alert.spread_low || 0) >= minPrice;
                }
                
                // Default: use current low price if available
                return (alert.spread_low || alert.price || 0) >= minPrice;
            }
        },
        maximumPrice: {
            id: 'maximumPrice',
            label: 'Maximum Price',
            shortLabel: 'Max',
            requiresInput: true,
            requiresModal: true,
            inputType: 'number',
            inputPlaceholder: 'Enter maximum price...',
            testWithValue: (alert, value) => {
                const maxPrice = parseInt(value);
                if (isNaN(maxPrice)) return true;
                
                // For above/below alerts, use the current price for the chosen reference (high/low)
                if (alert.type === 'above' || alert.type === 'below') {
                    if (alert.current_price != null) {
                        return alert.current_price <= maxPrice;
                    }
                    return false;
                }
                
                // For spread alerts with all items, use maximum_price field
                if (alert.type === 'spread' && alert.is_all_items) {
                    return (alert.maximum_price || 0) <= maxPrice;
                }
                
                // For spread alerts with single item, use current high price
                if (alert.type === 'spread' && !alert.is_all_items) {
                    return (alert.spread_high || 0) <= maxPrice;
                }
                
                // Default: use current high price if available
                return (alert.spread_high || alert.price || 0) <= maxPrice;
            }
        },
        myGroups: {
            id: 'myGroups',
            label: 'My Groups',
            requiresModal: true,
            testWithValue: (alert, selectedGroups) => {
                if (!selectedGroups || selectedGroups.length === 0) return true;
                // Check if alert belongs to any of the selected groups
                const alertGroups = alert.groups || [];
                return selectedGroups.some(group => alertGroups.includes(group));
            }
        }
    },

    // DOM element selectors for the create form
    selectors: {
        create: {
            alertType: '#alert-type',
            spreadScope: '#spread-scope',
            itemName: '#item-name',
            itemId: '#item-id',
            isAllItems: '#is-all-items',
            numberItems: '#number-of-items',
            direction: '#direction',
            emailNotification: '#email-notification',
            suggestions: '#item-suggestions',
                groups: {
                    spreadScope: '#spread-scope-group',
                    numberItems: '#number-items-group',
                    itemName: '#item-name-group',
                    price: '#price-group',
                    reference: '#reference-group',
                    percentage: '#percentage-group',
                    timeFrame: '#time-frame-group',
                    direction: '#direction-group',
                    minPrice: '#min-price-group',
                    maxPrice: '#max-price-group'
                }
            },
        // Other UI elements
        myAlertsPane: '#my-alerts',
        spreadModal: '#spread-modal',
        spreadItemsList: '#spread-items-list',
        spikeModal: '#spike-modal',
        spikeItemsList: '#spike-items-list',
        groupModal: '#group-modal',
        groupList: '#group-list',
        newGroupInput: '#new-group-input',
        tabButtons: '.tab-btn',
        tabPanes: '.tab-pane'
    },
    
    // Alert type constants for comparison
    alertTypes: {
        ABOVE: 'above',
        BELOW: 'below',
        SPREAD: 'spread',
        SPIKE: 'spike'
    },
    
    // CSRF token for Django POST requests
    csrfToken: '{{ csrf_token }}'
};

// =============================================================================
// DROPDOWN SIZING (compact label, expandable options)
// =============================================================================
const DropdownSizer = {
    _canvas: null,
    
    measureText(text, select) {
        if (!this._canvas) this._canvas = document.createElement('canvas');
        const ctx = this._canvas.getContext('2d');
        const style = window.getComputedStyle(select);
        ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
        return ctx.measureText(text || '').width;
    },
    
    applySizing(select) {
        if (!select) return;
        const padding =
            parseFloat(window.getComputedStyle(select).paddingLeft || 0) +
            parseFloat(window.getComputedStyle(select).paddingRight || 0);
        const arrowSpace = 24; // room for native dropdown arrow
        
        const calcWidth = text => this.measureText(text, select) + padding + arrowSpace;
        const getExpandedWidth = () => {
            let max = 0;
            Array.from(select.options).forEach(opt => { max = Math.max(max, calcWidth(opt.text)); });
            return max || calcWidth(select.options[0]?.text || '');
        };
        
        const updateCompactWidth = () => {
            const selectedText = select.options[select.selectedIndex]?.text || select.options[0]?.text || '';
            select.dataset.compactWidth = calcWidth(selectedText);
        };
        
        const applyCompact = () => {
            const width = select.dataset.compactWidth || calcWidth(select.options[0]?.text || '');
            select.style.minWidth = `${width}px`;
        };
        
        const expandedWidth = getExpandedWidth();
        select.dataset.expandedWidth = expandedWidth;
        updateCompactWidth();
        applyCompact();
        
        const expand = () => { select.style.minWidth = `${select.dataset.expandedWidth}px`; };
        const collapse = () => { applyCompact(); };
        
        select.addEventListener('focus', expand);
        select.addEventListener('mousedown', expand);
        select.addEventListener('blur', collapse);
        select.addEventListener('change', () => {
            updateCompactWidth();
            collapse();
        });
    },
    
    init() {
        this.applySizing(document.querySelector('.action-dropdown'));
        this.applySizing(document.querySelector('.sort-dropdown'));
        this.applySizing(document.querySelector('.filter-dropdown'));
    }
};


// =============================================================================
// STATE MANAGEMENT
// =============================================================================
/**
 * Application state manager.
 * 
 * Why: Centralizing state prevents scattered variables and makes it easier
 * to track and debug the application's current status.
 * 
 * How: All mutable state is stored in this object and accessed/modified
 * through consistent patterns.
 */
const AlertsState = {
    spreadDataCache: {},            // Cache for spread alert data (keyed by alert ID)
    spikeDataCache: {},             // Cache for spike all-items data
    activeFilters: new Set(),       // Currently active filter IDs
    filterValues: {},               // Values for input-based filters (keyed by filter ID)
    alertGroups: [],                // Known alert groups
    sorting: {                      // Current sorting state
        sortKey: null,
        sortOrder: null,
        pendingKey: null
    },
    
    /**
     * Stores spread data for a specific alert in the cache.
     * This allows the spread details modal to access the data later.
     */
    setSpreadData(alertId, data) {
        this.spreadDataCache[alertId] = data;
    },
    
    /**
     * Retrieves cached spread data for an alert.
     * Returns null if no data exists for the given ID.
     */
    getSpreadData(alertId) {
        return this.spreadDataCache[alertId] || null;
    },

    setSpikeData(alertId, data) {
        this.spikeDataCache[alertId] = data;
    },

    getSpikeData(alertId) {
        return this.spikeDataCache[alertId] || null;
    },

    /**
     * Updates known alert groups from alert data payload.
     */
    setAlertGroups(groups) {
        this.alertGroups = Array.isArray(groups) ? groups : [];
    },

    /**
     * Returns known alert groups.
     */
    getAlertGroups() {
        return this.alertGroups || [];
    },
    
    /**
     * Sets a value for an input-based filter.
     */
    setFilterValue(filterId, value) {
        this.filterValues[filterId] = value;
    },
    
    /**
     * Gets the value for an input-based filter.
     */
    getFilterValue(filterId) {
        return this.filterValues[filterId] || null;
    }
};


// =============================================================================
// API COMMUNICATION
// =============================================================================
/**
 * Handles all server communication.
 * 
 * Why: Centralizing API calls makes it easier to handle errors consistently,
 * modify endpoints, and add features like request caching or retries.
 * 
 * How: Each method corresponds to a specific API action and returns a Promise.
 */
const AlertsAPI = {
    /**
     * Fetches current alerts data from the server.
     * Returns both active alerts and triggered notifications.
     */
    async fetchAlerts() {
        try {
            const response = await fetch(AlertsConfig.endpoints.alerts);
            return await response.json();
        } catch (error) {
            console.error('Error fetching alerts:', error);
            return null;
        }
    },
    
    /**
     * Dismisses a triggered alert notification.
     * The alert remains in the system but the notification banner is hidden.
     */
    async dismissAlert(alertId) {
        try {
            await fetch(AlertsConfig.endpoints.dismiss, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_id: alertId })
            });
            return true;
        } catch (error) {
            console.error('Error dismissing alert:', error);
            return false;
        }
    },
    
    /**
     * Deletes multiple alerts by their IDs.
     */
    async deleteAlerts(alertIds) {
        try {
            await fetch(AlertsConfig.endpoints.delete, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_ids: alertIds })
            });
            return true;
        } catch (error) {
            console.error('Error deleting alerts:', error);
            return false;
        }
    },

    /**
     * Adds alerts to groups (creates groups if needed).
     */
    async groupAlerts(alertIds, groups, newGroups) {
        try {
            await fetch(AlertsConfig.endpoints.group, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({
                    alert_ids: alertIds,
                    groups: groups,
                    new_groups: newGroups
                })
            });
            return true;
        } catch (error) {
            console.error('Error grouping alerts:', error);
            return false;
        }
    },

    /**
     * Deletes alert groups by name.
     */
    async deleteGroups(groups) {
        try {
            const response = await fetch(AlertsConfig.endpoints.deleteGroups, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ groups })
            });
            if (!response.ok) return false;
            const data = await response.json();
            return !!data.success;
        } catch (error) {
            console.error('Error deleting groups:', error);
            return false;
        }
    },
    
    /**
     * Updates an existing alert with new values.
     */
    async updateAlert(alertData) {
        try {
            await fetch(AlertsConfig.endpoints.update, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify(alertData)
            });
            return true;
        } catch (error) {
            console.error('Error updating alert:', error);
            return false;
        }
    },
    
    /**
     * Searches for items by name query.
     * Used for autocomplete in item name fields.
     */
    async searchItems(query) {
        try {
            const url = AlertsConfig.endpoints.itemSearch + '?q=' + encodeURIComponent(query);
            const response = await fetch(url);
            return await response.json();
        } catch (error) {
            console.error('Error searching items:', error);
            return [];
        }
    }
};


// =============================================================================
// UI RENDERING
// =============================================================================
/**
 * Handles all DOM updates and HTML rendering.
 * 
 * Why: Separating UI logic from business logic makes the code easier to test,
 * modify, and understand. Changes to how things look don't affect how they work.
 * 
 * How: Each method handles a specific rendering task and returns HTML strings
 * or directly manipulates the DOM as appropriate.
 */
const AlertsUI = {
    /**
     * Generates the triggered text for an alert based on its type and data.
     * 
     * Why: Different alert types need different information displayed when triggered.
     * - Spread (all items): Shows clickable link to view all matching items
     * - Spread (single item): Shows low, high, and spread percentage
     * - Above/Below: Shows the price movement that triggered the alert
     */
    buildTriggeredText(alert) {
        return 'Alert triggered.';
    },
    
    /**
     * Checks if an alert is a spread-all-items type.
     */
    isSpreadAllItemsAlert(alert) {
        return alert.type === AlertsConfig.alertTypes.SPREAD && 
               alert.is_all_items && 
               alert.triggered_data;
    },

    /**
     * Checks if an alert is a spike-all-items type.
     */
    isSpikeAllItemsAlert(alert) {
        return alert.type === AlertsConfig.alertTypes.SPIKE &&
               alert.is_all_items &&
               alert.triggered_data;
    },
    
    /**
     * Renders the green notification banners for triggered alerts.
     */
    renderTriggeredNotifications(triggeredAlerts) {
        if (!triggeredAlerts || triggeredAlerts.length === 0) {
            return '';
        }
        
        let html = '';
        triggeredAlerts.forEach(alert => {
            const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
            const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);
            
            // Cache spread data for later use in modal
            if (isSpreadAllItems) {
                AlertsState.setSpreadData(alert.id, alert.triggered_data);
            }
            if (isSpikeAllItems) {
                AlertsState.setSpikeData(alert.id, alert.triggered_data);
            }
            
            const clickHandler = isSpreadAllItems 
                ? 'onclick="ModalManager.showSpreadDetails(' + alert.id + ')"' 
                : (isSpikeAllItems ? 'onclick="ModalManager.showSpikeDetails(' + alert.id + ')"' : '');
            const clickableClass = (isSpreadAllItems || isSpikeAllItems) ? 'clickable-triggered' : '';
            
            html += '<div class="triggered-notification" data-alert-id="' + alert.id + '">' +
                    '<span class="' + clickableClass + '" ' + clickHandler + '>' + alert.triggered_text + '</span>' +
                    '<button class="dismiss-btn" onclick="event.stopPropagation(); AlertActions.dismiss(' + alert.id + ')">&times;</button>' +
                    '</div>';
        });
        
        return html;
    },
    
    /**
     * Renders the action dropdown and filter dropdown.
     * @param {boolean} hasAlerts - Whether there are alerts to display
     * @param {string} preservedFilterTagsHtml - HTML of preserved filter tags (optional)
     */
    renderActionButtons(hasAlerts, preservedFilterTagsHtml) {
        if (!hasAlerts) return '';
        
        // Build dropdown options (exclude already active filters)
        let options = '<option value="">Add Filter...</option>';
        for (const [id, filter] of Object.entries(AlertsConfig.filters)) {
            if (!FilterManager.isActive(id)) {
                options += '<option value="' + id + '">' + filter.label + '</option>';
            }
        }
        
        // Use preserved filter tags if provided, otherwise build from state
        let tags = preservedFilterTagsHtml || '';
        if (!preservedFilterTagsHtml) {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (filter) {
                    tags += '<span class="filter-tag" data-filter-id="' + filterId + '">' + filter.label + 
                            '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                            '</span>';
                }
            }
        }

        let sortTag = '';
        if (AlertsState.sorting.sortKey) {
            const sortOption = SortManager.options[AlertsState.sorting.sortKey];
            const orderLabel = AlertsState.sorting.sortOrder === 'asc' ? 'Ascending' : 'Descending';
            const label = sortOption ? sortOption.label : 'Sort';
            sortTag = '<span class="sort-tag" data-sort-id="' + AlertsState.sorting.sortKey + '">' +
                label + ': ' + orderLabel +
                '<button class="sort-tag-remove" onclick="clearSort()">&times;</button>' +
                '</span>';
        }

        const sortOptions = '' +
            '<option value="">Sort...</option>' +
            '<option value="lastTriggered">Last Triggered Time</option>' +
            '<option value="alertType">Alert Type</option>' +
            '<option value="thresholdDistance">Threshold Distance</option>' +
            '<option value="createdDate">Created Date</option>';
        
        return '<div class="alert-actions-wrapper">' +
               '<div class="alert-actions">' +
               '<div class="alert-actions-left">' +
               '<select id="alert-action-select" class="action-dropdown" onchange="AlertActions.handleAction(this.value); this.value=\'\';">' +
               '<option value="">Actions</option>' +
               '<option value="delete">Delete</option>' +
               '<option value="group">Add to Group</option>' +
               '</select>' +
               '</div>' +
               '<div class="alert-actions-right" id="active-filters">' +
               '<div class="alert-actions-controls">' +
               '<div class="sort-controls">' +
               '<select class="sort-dropdown" onchange="handleSortSelection(this.value); this.value=\'\';">' + sortOptions + '</select>' +
               '<div id="sort-order-picker" class="sort-order-picker" style="display: none;"></div>' +
               '</div>' +
               '<select class="filter-dropdown" onchange="addFilter(this.value); this.value=\'\';">' + options + '</select>' +
               '</div>' +
               '</div>' +
               '</div>' +
               '<div class="alert-indicators">' +
               '<div class="filter-tags">' + tags + '</div>' +
               '<div class="sort-tag-holder">' + sortTag + '</div>' +
               '</div>' +
               '</div>';
    },
    
    /**
     * Renders a single alert list item.
     */
    renderAlertItem(alert) {
        const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
        const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);
        
        // Cache spread data if triggered (for detail page)
        if (isSpreadAllItems && alert.is_triggered) {
            AlertsState.setSpreadData(alert.id, alert.triggered_data);
        }
        if (isSpikeAllItems && alert.is_triggered) {
            AlertsState.setSpikeData(alert.id, alert.triggered_data);
        }
        
        // Build triggered badge if needed
        let triggeredBadge = '';
        if (alert.is_triggered) {
            const triggeredText = this.buildTriggeredText(alert);
            triggeredBadge = '<span class="alert-triggered">' + triggeredText + '</span>';
        }

        // Show threshold percentage for all alerts
        let thresholdDisplay = '';
        const thresholdDistance = SortManager.getThresholdDistance(alert);
        if (typeof thresholdDistance === 'number' && !Number.isNaN(thresholdDistance)) {
            const formatted = thresholdDistance.toFixed(2);
            thresholdDisplay = '<span class="alert-threshold">Threshold: ' + formatted + '%</span>';
        } else {
            thresholdDisplay = '<span class="alert-threshold">Threshold: N/A</span>';
        }

        return '<li class="alert-item clickable-alert" data-alert-id="' + alert.id + '" onclick="navigateToAlertDetail(event, ' + alert.id + ')">' +
               '<input type="checkbox" class="alert-checkbox" onclick="event.stopPropagation()">' +
               '<span class="alert-icon"></span>' +
               '<span class="alert-text">' + alert.text + '</span>' +
               triggeredBadge +
               thresholdDisplay +
               '</li>';
    },
    
    /**
     * Renders the complete alerts list.
     * When groups filter is active, displays alerts grouped by their group names.
     */
    renderAlertsList(alerts) {
        if (!alerts || alerts.length === 0) {
            return '<p class="no-alerts">No active alerts. Create one to get started!</p>';
        }
        
        // Apply active filters then sort
        const filteredAlerts = SortManager.applySort(FilterManager.applyFilters(alerts));
        
        if (filteredAlerts.length === 0) {
            return '<p class="no-alerts">No alerts match the current filters.</p>';
        }
        
        // Check if groups filter is active - if so, render grouped
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        if (selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups')) {
            return this.renderGroupedAlertsList(filteredAlerts, selectedGroups);
        }
        
        let html = '<ul class="alerts-list">';
        filteredAlerts.forEach(alert => {
            html += this.renderAlertItem(alert);
        });
        html += '</ul>';
        return html;
    },
    
    /**
     * Renders alerts grouped by their group names.
     * Groups are displayed in alphabetical order, each with a header.
     */
    renderGroupedAlertsList(alerts, selectedGroups) {
        // Sort selected groups alphabetically
        const sortedGroups = [...selectedGroups].sort((a, b) => a.localeCompare(b));
        
        // Group alerts by their groups
        const groupedAlerts = {};
        sortedGroups.forEach(group => {
            groupedAlerts[group] = [];
        });
        
        alerts.forEach(alert => {
            const alertGroups = alert.groups || [];
            sortedGroups.forEach(group => {
                if (alertGroups.includes(group)) {
                    groupedAlerts[group].push(alert);
                }
            });
        });
        
        let html = '';
        sortedGroups.forEach(group => {
            const groupAlerts = groupedAlerts[group];
            if (groupAlerts.length > 0) {
                const sortedGroupAlerts = SortManager.applySort(groupAlerts);
                html += '<div class="alert-group">';
                html += '<h3 class="alert-group-header">' + group + '</h3>';
                html += '<ul class="alerts-list">';
                sortedGroupAlerts.forEach(alert => {
                    html += this.renderAlertItem(alert);
                });
                html += '</ul>';
                html += '</div>';
            }
        });
        
        if (!html) {
            return '<p class="no-alerts">No alerts found in the selected groups.</p>';
        }
        
        return html;
    },
    
    /**
     * Renders the spread details modal content.
     */
    renderSpreadItemsList(items) {
        let html = '';
        items.forEach(item => {
            const lowPrice = item.low ? item.low.toLocaleString() : 'N/A';
            const highPrice = item.high ? item.high.toLocaleString() : 'N/A';
            
            html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Low: ' + lowPrice + ' | High: ' + highPrice + '</div>' +
                    '</div>' +
                    '<span class="spread-item-percentage">' + item.spread + '%</span>' +
                    '</li>';
        });
        return html;
    },

    /**
     * Renders spike items list for all-items spike alerts.
     */
    renderSpikeItemsList(items) {
        let html = '';
        items.forEach(item => {
            const baseline = item.baseline ? item.baseline.toLocaleString() : 'N/A';
            const current = item.current ? item.current.toLocaleString() : 'N/A';
            const percent = item.percent_change != null ? item.percent_change.toFixed(2) : 'N/A';
            const pctClass = (item.percent_change != null && item.percent_change < 0)
                ? 'spread-item-percentage negative-change'
                : 'spread-item-percentage';
            html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Baseline: ' + baseline + ' | Current: ' + current + '</div>' +
                    '</div>' +
                    '<span class="' + pctClass + '">' + percent + '%</span>' +
                    '</li>';
        });
        return html;
    },
    
    /**
     * Renders autocomplete suggestions.
     */
    renderSuggestions(items) {
        let html = '';
        items.forEach(item => {
            html += '<div class="suggestion-item" data-id="' + item.id + '" data-name="' + item.name + '">' + item.name + '</div>';
        });
        return html;
    },
    
    /**
     * Updates the entire My Alerts pane with fresh data.
     * Preserves status notifications and filter tags to prevent flashing.
     */
    updateMyAlertsPane(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;

        if (data && data.groups) {
            AlertsState.setAlertGroups(data.groups);
        }
        
        // Check if any alert checkboxes are checked
        const hasCheckedAlerts = pane.querySelectorAll('.alert-checkbox:checked').length > 0;
        
        // If any checkboxes are checked, skip the update entirely to preserve selection
        if (hasCheckedAlerts) {
            return;
        }
        
        // Check if filter dropdown is currently open/focused
        const filterDropdown = pane.querySelector('.filter-dropdown');
        const isFilterDropdownOpen = filterDropdown && document.activeElement === filterDropdown;
        
        // Check if sort dropdown is currently open/focused
        const sortDropdown = pane.querySelector('.sort-dropdown');
        const isSortDropdownOpen = sortDropdown && document.activeElement === sortDropdown;
        
        // Check if actions dropdown is currently open/focused
        const actionsDropdown = pane.querySelector('.action-dropdown');
        const isActionsDropdownOpen = actionsDropdown && document.activeElement === actionsDropdown;
        
        // If there are active filters, a filter input is open, or any dropdown is open, do selective update
        const hasActiveFilters = AlertsState.activeFilters.size > 0;
        const hasFilterInput = pane.querySelector('.filter-input-container') !== null;
        
        if (hasActiveFilters || hasFilterInput || isFilterDropdownOpen || isSortDropdownOpen || isActionsDropdownOpen) {
            this.updateMyAlertsPaneSelective(data);
            return;
        }
        
        // Preserve any status notifications (e.g., "Alert created")
        const existingStatusNotifications = pane.querySelectorAll('.status-notification');
        let statusHtml = '';
        existingStatusNotifications.forEach(n => {
            statusHtml += n.outerHTML;
        });
        
        const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
        const actionsHtml = this.renderActionButtons(data.alerts && data.alerts.length > 0, '');
        
        let alertsHtml = '';
        if (data.alerts && data.alerts.length > 0) {
            alertsHtml = this.renderAlertsList(data.alerts);
        } else if (!data.triggered || data.triggered.length === 0) {
            alertsHtml = this.renderAlertsList([]);
        }
        
        pane.innerHTML = '<div id="triggered-notifications">' + statusHtml + notificationsHtml + '</div>' +
                        actionsHtml + alertsHtml;
    },
    
    /**
     * Selectively updates parts of the My Alerts pane without touching the action bar.
     * Used when filters are active to prevent filter tags from flashing.
     */
    updateMyAlertsPaneSelective(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;

        if (data && data.groups) {
            AlertsState.setAlertGroups(data.groups);
        }
        
        // Update triggered notifications (preserve status notifications)
        const notificationsContainer = pane.querySelector('#triggered-notifications');
        if (notificationsContainer) {
            const existingStatusNotifications = notificationsContainer.querySelectorAll('.status-notification');
            let statusHtml = '';
            existingStatusNotifications.forEach(n => {
                statusHtml += n.outerHTML;
            });
            const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
            notificationsContainer.innerHTML = statusHtml + notificationsHtml;
        }
        
        // Update alerts list only - find the container to replace
        const alertsList = pane.querySelector('.alerts-list');
        const alertGroup = pane.querySelector('.alert-group');
        const noAlertsMsg = pane.querySelector('.no-alerts');
        const loadingContainer = pane.querySelector('.loading-container');
        const alertsListContainer = pane.querySelector('#alerts-list-container');
        
        const filteredAlerts = FilterManager.applyFilters(data.alerts || []);
        
        // Check if groups filter is active
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');
        
        // Build the new HTML
        let newHtml = '';
        if (filteredAlerts.length === 0) {
            newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
        } else if (isGroupedView) {
            newHtml = this.renderGroupedAlertsList(filteredAlerts, selectedGroups);
        } else {
            newHtml = '<ul class="alerts-list">';
            filteredAlerts.forEach(alert => {
                newHtml += this.renderAlertItem(alert);
            });
            newHtml += '</ul>';
        }
        
        // Replace the existing content
        if (alertGroup) {
            // If we have grouped view, replace all groups
            const allGroups = pane.querySelectorAll('.alert-group');
            const firstGroup = allGroups[0];
            allGroups.forEach((g, i) => { if (i > 0) g.remove(); });
            if (firstGroup) {
                firstGroup.outerHTML = newHtml;
            }
        } else if (alertsList) {
            alertsList.outerHTML = newHtml;
        } else if (alertsListContainer) {
            // Replace the loading container with alerts
            alertsListContainer.outerHTML = newHtml;
        } else if (loadingContainer) {
            // Replace standalone loading container
            loadingContainer.outerHTML = newHtml;
        } else if (noAlertsMsg) {
            noAlertsMsg.outerHTML = newHtml;
        }
    }
};


// =============================================================================
// SORT MANAGEMENT
// =============================================================================
const SortManager = {
    options: {
        lastTriggered: { id: 'lastTriggered', label: 'Last Triggered Time', defaultOrder: 'desc' },
        alertType: { id: 'alertType', label: 'Alert Type', defaultOrder: 'asc' },
        thresholdDistance: { id: 'thresholdDistance', label: 'Threshold Distance', defaultOrder: 'asc' },
        createdDate: { id: 'createdDate', label: 'Created Date', defaultOrder: 'desc' }
    },

    getSortValue(alert, sortKey) {
        switch (sortKey) {
            case 'lastTriggered': {
                const ts = alert.last_triggered_at || alert.triggered_at || alert.triggered_time || alert.last_triggered_time;
                return this.parseDateValue(ts);
            }
            case 'alertType':
                return (alert.type || '').toString();
            case 'thresholdDistance':
                return this.getThresholdDistance(alert);
            case 'createdDate':
                return this.parseDateValue(alert.created_at);
            default:
                return null;
        }
    },

    parseDateValue(value) {
        if (!value) return null;
        const ts = Date.parse(value);
        return isNaN(ts) ? null : ts;
    },

    getThresholdDistance(alert) {
        const { alertTypes } = AlertsConfig;
        if ((alert.type === alertTypes.ABOVE || alert.type === alertTypes.BELOW) && alert.price && alert.current_price) {
            const target = Number(alert.price);
            const current = Number(alert.current_price);
            if (!target || !Number.isFinite(current)) return null;
            const percentDiff = ((current - target) / target) * 100;
            return Number.isFinite(percentDiff) ? percentDiff : null;
        }
        if (alert.type === alertTypes.SPREAD && alert.percentage != null) {
            if (alert.spread_percentage != null) {
                return Math.abs(alert.percentage - alert.spread_percentage);
            }
            if (alert.spread_current_percentage != null) {
                return Math.abs(alert.percentage - alert.spread_current_percentage);
            }
        }
        if (alert.type === alertTypes.SPIKE) {
            // Use spike triggered data when available
            if (alert.triggered_data) {
                try {
                    const data = JSON.parse(alert.triggered_data);
                    const baseline = Number(data?.baseline);
                    const current = Number(data?.current ?? alert.current_price);
                    if (Number.isFinite(baseline) && baseline !== 0 && Number.isFinite(current)) {
                        return ((current - baseline) / baseline) * 100;
                    }
                } catch (e) {
                    // ignore parse errors
                }
            }
            // Fallback to current price vs stored baseline in current_price if available (no baseline -> null)
            return null;
        }
        return null;
    },

    applySort(alerts) {
        const sorted = [...alerts];
        const { sortKey, sortOrder } = AlertsState.sorting || {};
        if (!sortKey) {
            return sorted.sort((a, b) => (a.text || '').localeCompare(b.text || ''));
        }

        const direction = sortOrder === 'asc' ? 1 : -1;

        sorted.sort((a, b) => {
            const aVal = this.getSortValue(a, sortKey);
            const bVal = this.getSortValue(b, sortKey);
            const aMissing = aVal === null || aVal === undefined || Number.isNaN(aVal);
            const bMissing = bVal === null || bVal === undefined || Number.isNaN(bVal);

            if (!aMissing || !bMissing) {
                if (aMissing) return 1;
                if (bMissing) return -1;
                if (aVal > bVal) return direction;
                if (aVal < bVal) return -direction;
            }

            return (a.text || '').localeCompare(b.text || '');
        });

        return sorted;
    },

    handleSortSelection(sortKey) {
        if (!sortKey) return;
        AlertsState.sorting.pendingKey = sortKey;
        const defaultOrder = this.options[sortKey]?.defaultOrder || 'asc';
        this.showOrderPicker(sortKey, defaultOrder);
    },

    showOrderPicker(sortKey, defaultOrder) {
        const picker = document.getElementById('sort-order-picker');
        if (!picker) return;
        AlertsRefresh.pauseForSort();
        picker.innerHTML = '' +
            '<span class="sort-order-label">Order:</span>' +
            '<button class="sort-order-btn" onclick="applySortOrder(\'asc\')">Ascending</button>' +
            '<button class="sort-order-btn" onclick="applySortOrder(\'desc\')">Descending</button>';
        picker.style.display = 'flex';

        // Preselect by applying default immediately if we already have this sort active
        if (AlertsState.sorting.sortKey === sortKey && AlertsState.sorting.sortOrder) {
            // no-op, waiting for user click
        } else {
            AlertsState.sorting.sortOrder = defaultOrder;
        }
    },

    applySortOrder(order) {
        const sortKey = AlertsState.sorting.pendingKey || AlertsState.sorting.sortKey;
        if (!sortKey) return;
        AlertsState.sorting.sortKey = sortKey;
        AlertsState.sorting.sortOrder = order || this.options[sortKey]?.defaultOrder || 'asc';
        AlertsState.sorting.pendingKey = null;
        this.hideOrderPicker();
        this.renderSortTag();
        FilterManager.updateAlertsList();
        AlertsRefresh.resumeAfterSort();
    },

    hideOrderPicker() {
        const picker = document.getElementById('sort-order-picker');
        if (picker) picker.style.display = 'none';
        AlertsRefresh.resumeAfterSort();
    },

    clearSort() {
        AlertsState.sorting = { sortKey: null, sortOrder: null, pendingKey: null };
        this.hideOrderPicker();
        this.renderSortTag();
        FilterManager.updateAlertsList();
    },

    renderSortTag() {
        const container = document.querySelector('.alert-indicators .sort-tag-holder') || document.querySelector('.alert-indicators');
        if (!container) return;
        const existing = container.querySelector('.sort-tag');
        if (existing) existing.remove();

        if (!AlertsState.sorting.sortKey) return;

        const option = this.options[AlertsState.sorting.sortKey];
        const label = option ? option.label : 'Sort';
        const orderLabel = AlertsState.sorting.sortOrder === 'asc' ? 'Ascending' : 'Descending';
        const tagHtml = '<span class="sort-tag" data-sort-id="' + AlertsState.sorting.sortKey + '">' +
            label + ': ' + orderLabel +
            '<button class="sort-tag-remove" onclick="clearSort()">&times;</button>' +
            '</span>';

        container.insertAdjacentHTML('beforeend', tagHtml);
    }
};


// =============================================================================
// FILTER MANAGEMENT
// =============================================================================
/**
 * Manages alert list filtering.
 * 
 * Why: Users need to filter alerts by various criteria (triggered status, etc.)
 * to quickly find relevant alerts.
 * 
 * How: Maintains a set of active filter IDs in AlertsState. When rendering,
 * alerts are filtered through all active filter test functions.
 */
const FilterManager = {
    /**
     * Adds a filter to the active filters set and updates the DOM.
     * For input-based filters, shows an input prompt first.
     */
    addFilter(filterId) {
        const filter = AlertsConfig.filters[filterId];
        if (!filter) return;
        if (filterId === 'myGroups' && AlertsState.activeFilters.has(filterId)) {
            this.showFilterModal(filterId);
            return;
        }
        if (AlertsState.activeFilters.has(filterId)) return;
        
        // If filter requires a modal, open it
        if (filter.requiresModal) {
            this.showFilterModal(filterId);
            return;
        }
        
        // If filter requires input, show input UI instead of adding directly
        if (filter.requiresInput) {
            this.showFilterInput(filterId);
            return;
        }
        
        this.activateFilter(filterId);
    },
    
    /**
     * Shows a modal for a modal-based filter.
     */
    showFilterModal(filterId) {
        const dropdown = document.querySelector('#active-filters .filter-dropdown');
        if (dropdown) dropdown.value = '';
        if (filterId === 'myGroups') {
            openGroupsFilterModal();
        } else if (filterId === 'minimumPrice' || filterId === 'maximumPrice') {
            openPriceFilterModal(filterId);
        }
    },
    
    /**
     * Shows the input UI for an input-based filter.
     */
    showFilterInput(filterId) {
        const filter = AlertsConfig.filters[filterId];
        const container = document.querySelector('#active-filters');
        const dropdown = container ? container.querySelector('.filter-dropdown') : null;
        if (!dropdown) return;
        
        // Create input UI
        const inputHtml = '<span class="filter-input-container" data-filter-id="' + filterId + '">' +
            '<input type="' + (filter.inputType || 'text') + '" class="filter-input" ' +
            'placeholder="' + (filter.inputPlaceholder || 'Enter value...') + '" ' +
            'onkeydown="handleFilterInputKeydown(event, \'' + filterId + '\')">' +
            '<button class="filter-input-confirm" onclick="confirmFilterInput(\'' + filterId + '\')"></button>' +
            '<button class="filter-input-cancel" onclick="cancelFilterInput(\'' + filterId + '\')">&times;</button>' +
            '</span>';
        
        dropdown.insertAdjacentHTML('beforebegin', inputHtml);
        
        // Focus the input
        const input = container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"] .filter-input');
        if (input) input.focus();
        
        // Reset dropdown
        dropdown.value = '';
    },
    
    /**
     * Confirms the input for an input-based filter and activates it.
     */
    confirmFilterInput(filterId) {
        const container = document.querySelector('#active-filters');
        const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
        const input = inputContainer ? inputContainer.querySelector('.filter-input') : null;
        
        if (!input || !input.value.trim()) {
            this.cancelFilterInput(filterId);
            return;
        }
        
        const value = input.value.trim();
        AlertsState.setFilterValue(filterId, value);
        
        // Remove input container
        inputContainer.remove();
        
        // Activate the filter with the value displayed
        this.activateFilter(filterId, value);
    },
    
    /**
     * Cancels the input for an input-based filter.
     */
    cancelFilterInput(filterId) {
        const container = document.querySelector('#active-filters');
        const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
        if (inputContainer) {
            inputContainer.remove();
        }
    },
    
    /**
     * Activates a filter and adds its tag to the DOM.
     * @param {string} filterId - The filter ID
     * @param {string} displayValue - Optional value to display in the tag
     */
    activateFilter(filterId, displayValue) {
        AlertsState.activeFilters.add(filterId);
        
        // Add filter tag to DOM
        const filter = AlertsConfig.filters[filterId];
        const container = document.querySelector('#active-filters');
        const dropdown = container ? container.querySelector('.filter-dropdown') : null;
        const tagContainer = document.querySelector('.alert-indicators .filter-tags');
        if (dropdown) {
            // Format the label based on whether it's a numeric value or not
            let label;
            if (displayValue) {
                const numValue = parseInt(displayValue);
                if (!isNaN(numValue) && filter.requiresInput) {
                    label = filter.label + ': ' + numValue.toLocaleString();
                } else {
                    label = filter.label + ': ' + displayValue;
                }
            } else {
                label = filter.label;
            }
            const tagHtml = '<span class="filter-tag" data-filter-id="' + filterId + '">' + label + 
                    '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                    '</span>';
            if (tagContainer) {
                tagContainer.insertAdjacentHTML('beforeend', tagHtml);
            } else {
                dropdown.insertAdjacentHTML('beforebegin', tagHtml);
            }
            
            // Remove the option from dropdown
            const option = dropdown.querySelector('option[value="' + filterId + '"]');
            if (option && filterId !== 'myGroups') option.remove();
        }
        
        // Only update the alerts list, not the entire pane
        this.updateAlertsList();
    },
    
    /**
     * Removes a filter from the active filters set.
     */
    removeFilter(filterId) {
        AlertsState.activeFilters.delete(filterId);
        AlertsState.filterValues[filterId] = null; // Clear any stored value
        
        const tagEl = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
        if (tagEl) tagEl.remove();
        
        // Re-add the option to dropdown
        const filter = AlertsConfig.filters[filterId];
        const dropdown = document.querySelector('#active-filters .filter-dropdown');
        if (dropdown && filter) {
            const existingOption = dropdown.querySelector('option[value="' + filterId + '"]');
            if (!existingOption) {
                const option = document.createElement('option');
                option.value = filterId;
                option.textContent = filter.label;
                dropdown.appendChild(option);
            }
        }
        
        // Only update the alerts list, not the entire pane
        this.updateAlertsList();
    },
    
    /**
     * Updates just the alerts list based on current filters.
     * Does not touch the action bar or filter tags.
     */
    async updateAlertsList() {
        const data = await AlertsAPI.fetchAlerts();
        if (!data) return;
        
        const pane = document.querySelector('#my-alerts');
        if (!pane) return;

        const alertsList = pane.querySelector('.alerts-list');
        const alertGroup = pane.querySelector('.alert-group');
        const noAlertsMsg = pane.querySelector('.no-alerts');
        const filteredAlerts = this.applyFilters(data.alerts || []);
        const sortedAlerts = SortManager.applySort(filteredAlerts);
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');

        let newHtml = '';
        if (sortedAlerts.length === 0) {
            newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
        } else if (isGroupedView) {
            newHtml = AlertsUI.renderGroupedAlertsList(sortedAlerts, selectedGroups);
        } else {
            newHtml = '<ul class="alerts-list">';
            sortedAlerts.forEach(alert => {
                newHtml += AlertsUI.renderAlertItem(alert);
            });
            newHtml += '</ul>';
        }

        if (alertGroup) {
            const allGroups = pane.querySelectorAll('.alert-group');
            const firstGroup = allGroups[0];
            allGroups.forEach((g, i) => { if (i > 0) g.remove(); });
            if (firstGroup) {
                firstGroup.outerHTML = newHtml;
            }
        } else if (alertsList) {
            alertsList.outerHTML = newHtml;
        } else if (noAlertsMsg) {
            noAlertsMsg.outerHTML = newHtml;
        }
    },
    
    /**
     * Checks if a filter is currently active.
     */
    isActive(filterId) {
        return AlertsState.activeFilters.has(filterId);
    },
    
    /**
     * Applies all active filters to an array of alerts.
     * Returns only alerts that pass ALL active filter tests.
     */
    applyFilters(alerts) {
        if (AlertsState.activeFilters.size === 0) {
            return alerts;
        }
        
        return alerts.filter(alert => {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (!filter) continue;
                
                // Use testWithValue for input-based or modal-based filters
                if ((filter.requiresInput || filter.requiresModal) && filter.testWithValue) {
                    const value = AlertsState.getFilterValue(filterId);
                    if (!filter.testWithValue(alert, value)) {
                        return false;
                    }
                } else if (filter.test && !filter.test(alert)) {
                    return false;
                }
            }
            return true;
        });
    }
};


// =============================================================================
// FORM MANAGEMENT
// =============================================================================
/**
 * Manages form field visibility and state for create/edit forms.
 * 
 * Why: Different alert types require different fields. This manager handles
 * showing/hiding the appropriate fields based on user selections.
 * 
 * How: Uses configuration-driven approach to map alert types to visible fields.
 */
const FormManager = {
    /**
     * Updates form field visibility based on selected alert type.
     * 
     * @param {string} formType - 'create' for create form
     */
    handleAlertTypeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const alertType = document.querySelector(selectors.alertType).value;
        const groups = selectors.groups;
        
        // Get all form group elements
        const elements = {
            spreadScope: document.querySelector(groups.spreadScope),
            numberItems: document.querySelector(groups.numberItems),
            itemName: document.querySelector(groups.itemName),
            price: document.querySelector(groups.price),
            reference: document.querySelector(groups.reference),
            percentage: document.querySelector(groups.percentage),
            timeFrame: document.querySelector(groups.timeFrame),
            direction: document.querySelector(groups.direction),
            minPrice: document.querySelector(groups.minPrice),
            maxPrice: document.querySelector(groups.maxPrice)
        };
        
        if (alertType === AlertsConfig.alertTypes.SPREAD) {
            // Spread alerts: show spread-specific fields
            elements.spreadScope.style.display = 'block';
            if (elements.numberItems) elements.numberItems.style.display = 'none';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'none';
            elements.percentage.style.display = 'block';
            elements.timeFrame.style.display = 'none';
            elements.direction.style.display = 'none';
            
            // Let scope change handler determine remaining visibility
            this.handleSpreadScopeChange(formType);
        } else if (alertType === AlertsConfig.alertTypes.SPIKE) {
            // Spike alerts: single item, show percentage + time frame, hide spread fields
            elements.spreadScope.style.display = 'none';
            if (elements.numberItems) elements.numberItems.style.display = 'block';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'block';
            elements.percentage.style.display = 'block';
            elements.timeFrame.style.display = 'block';
            elements.direction.style.display = 'block';
            // Spike uses min/max only when all items selected; handled in handleSpikeScopeChange
            this.handleSpikeScopeChange(formType);
        } else {
            // Above/Below alerts: show threshold fields
            elements.spreadScope.style.display = 'none';
            if (elements.numberItems) elements.numberItems.style.display = 'none';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'block';
            elements.reference.style.display = 'block';
            elements.percentage.style.display = 'none';
            elements.timeFrame.style.display = 'none';
            elements.direction.style.display = 'none';
            elements.minPrice.style.display = 'none';
            elements.maxPrice.style.display = 'none';
            
            // Reset is_all_items
            document.querySelector(selectors.isAllItems).value = 'false';
        }

        const directionInput = document.querySelector(selectors.direction);
        if (directionInput && elements.direction.style.display === 'none') {
            directionInput.value = 'both';
        }
    },
    
    /**
     * Updates form fields based on spread scope selection.
     * 
     * @param {string} formType - 'create' for create form
     */
    handleSpreadScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const spreadScope = document.querySelector(selectors.spreadScope).value;
        const groups = selectors.groups;
        
        const itemNameGroup = document.querySelector(groups.itemName);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        if (spreadScope === 'all') {
            itemNameGroup.style.display = 'none';
            minPriceGroup.style.display = 'block';
            maxPriceGroup.style.display = 'block';
            isAllItemsInput.value = 'true';
        } else {
            itemNameGroup.style.display = 'block';
            minPriceGroup.style.display = 'none';
            maxPriceGroup.style.display = 'none';
            isAllItemsInput.value = 'false';
        }
    },
    
    /**
     * Updates form fields based on spike number-of-items selection.
     */
    handleSpikeScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const numberItemsSelect = document.querySelector(selectors.numberItems);
        const groups = selectors.groups;
        const itemNameGroup = document.querySelector(groups.itemName);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        const selection = numberItemsSelect ? numberItemsSelect.value : 'one';
        const isAll = selection === 'all';
        if (itemNameGroup) itemNameGroup.style.display = isAll ? 'none' : 'block';
        if (minPriceGroup) minPriceGroup.style.display = isAll ? 'block' : 'none';
        if (maxPriceGroup) maxPriceGroup.style.display = isAll ? 'block' : 'none';
        if (isAllItemsInput) isAllItemsInput.value = isAll ? 'true' : 'false';
    }
};


// =============================================================================
// MODAL MANAGEMENT
// =============================================================================
/**
 * Controls modal dialogs (spread details modal and spike details modal).
 * 
 * Why: Modals have common behavior that should be handled consistently.
 */
const ModalManager = {
    /**
     * Opens spread details modal with matching items.
     */
    showSpreadDetails(alertId) {
        const dataStr = AlertsState.getSpreadData(alertId);
        
        if (!dataStr) {
            console.error('No spread data found for alert', alertId);
            return;
        }
        
        const data = JSON.parse(dataStr);
        const list = document.querySelector(AlertsConfig.selectors.spreadItemsList);
        list.innerHTML = AlertsUI.renderSpreadItemsList(data);
        
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'flex';
    },
    
    /**
     * Closes the spread details modal.
     */
    closeSpreadModal() {
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'none';
    },

    /**
     * Opens spike details modal with matching items.
     */
    showSpikeDetails(alertId) {
        const dataStr = AlertsState.getSpikeData(alertId);
        
        if (!dataStr) {
            console.error('No spike data found for alert', alertId);
            return;
        }
        
        let data = [];
        try {
            data = JSON.parse(dataStr);
        } catch (e) {
            console.error('Failed to parse spike data', e);
            return;
        }
        const list = document.getElementById('spike-items-list');
        if (list) {
            list.innerHTML = AlertsUI.renderSpikeItemsList(data);
        }
        
        document.getElementById('spike-modal').style.display = 'flex';
    },

    /**
     * Closes the spike details modal.
     */
    closeSpikeModal() {
        const modal = document.getElementById('spike-modal');
        if (modal) modal.style.display = 'none';
    }
};


// =============================================================================
// ALERT ACTIONS
// =============================================================================
/**
 * Handles user actions on alerts (dismiss, delete, save).
 */
const AlertActions = {
    /**
     * Handles selection from the actions dropdown.
     */
    handleAction(action) {
        if (action === 'delete') {
            this.confirmDelete();
        } else if (action === 'group') {
            GroupManager.open();
        }
    },

    /**
     * Dismisses a triggered alert notification.
     */
    async dismiss(alertId) {
        // Animate out immediately for responsive feedback
        const notification = document.querySelector('.triggered-notification[data-alert-id="' + alertId + '"]');
        if (notification) {
            notification.classList.add('dismissing');
        }
        
        await AlertsAPI.dismissAlert(alertId);
    },
    
    /**
     * Confirms deletion of selected alerts.
     * 
     * What: Deletes selected alerts with smooth animation
     * Why: Provides visual feedback and smooth UX when removing alerts
     * How: Animates selected items out, waits for animation, then calls API
     *      and refreshes the list
     */
    async confirmDelete() {
        const selectedItems = [];
        const selectedIds = [];
        
        document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
            const alertItem = cb.closest('.alert-item');
            if (alertItem) {
                selectedItems.push(alertItem);
                selectedIds.push(alertItem.dataset.alertId);
            }
        });
        
        if (selectedIds.length === 0) {
            alert('Please select at least one alert to delete.');
            return;
        }

        const confirmed = window.confirm('Delete selected alert' + (selectedIds.length > 1 ? 's' : '') + '?');
        if (!confirmed) {
            return;
        }
        
        // Animate items out
        selectedItems.forEach(item => {
            item.classList.add('deleting');
        });
        
        // Wait for animation to complete (300ms matches CSS transition)
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Call API to delete
        const success = await AlertsAPI.deleteAlerts(selectedIds);
        if (success) {
            this.clearSelections();
            // Show status notification
            this.showStatusNotification('Alert' + (selectedIds.length > 1 ? 's' : '') + ' deleted');
            await AlertsRefresh.refresh();
        } else {
            selectedItems.forEach(item => item.classList.remove('deleting'));
        }
    },

    /**
     * Clears any selected checkboxes.
     */
    clearSelections() {
        document.querySelectorAll('.alert-checkbox').forEach(cb => cb.checked = false);
    },
    
    /**
     * Shows a status notification at the top of the alerts pane.
     * 
     * What: Creates and displays a dismissible status message
     * Why: Provides user feedback for actions like delete
     * How: Inserts notification HTML into triggered-notifications container
     */
    showStatusNotification(message) {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;
        
        const notification = document.createElement('div');
        notification.className = 'triggered-notification status-notification';
        notification.innerHTML = message + 
            '<button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>';
        
        container.insertBefore(notification, container.firstChild);
    }
};


// =============================================================================
// GROUP MANAGEMENT
// =============================================================================
/**
 * Handles organizing alerts into groups.
 */
const GroupManager = {
    escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&#39;');
    },

    open() {
        const selectedIds = this.getSelectedAlertIds();
        if (selectedIds.length === 0) {
            alert('Please select at least one alert first.');
            return;
        }

        this.renderExistingGroups();
        this.clearNewGroupInput();
        const modal = document.querySelector(AlertsConfig.selectors.groupModal);
        if (modal) {
            modal.style.display = 'flex';
        }
    },

    close() {
        const modal = document.querySelector(AlertsConfig.selectors.groupModal);
        if (modal) {
            modal.style.display = 'none';
        }
    },

    clearNewGroupInput() {
        const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
        if (input) input.value = '';
    },

    renderExistingGroups() {
        const list = document.querySelector(AlertsConfig.selectors.groupList);
        if (!list) return;

        const groups = AlertsState.getAlertGroups();
        if (!groups || groups.length === 0) {
            list.innerHTML = '<p class="no-alerts">No groups yet. Add a new one below.</p>';
            return;
        }

        list.innerHTML = '';
        groups.forEach(name => {
            const pill = document.createElement('span');
            pill.className = 'group-pill';
            pill.dataset.group = name;
            pill.textContent = name;
            pill.onclick = function() {
                this.classList.toggle('selected');
            };
            list.appendChild(pill);
        });
    },

    getSelectedAlertIds() {
        const ids = [];
        document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
            const item = cb.closest('.alert-item');
            if (item && item.dataset.alertId) {
                ids.push(item.dataset.alertId);
            }
        });
        return ids;
    },

    parseNewGroups() {
        const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
        if (!input || !input.value.trim()) return [];
        return input.value.split(',')
            .map(g => g.trim())
            .filter(g => g.length > 0);
    },

    getSelectedGroups() {
        const selected = [];
        document.querySelectorAll(AlertsConfig.selectors.groupList + ' .group-pill.selected')
            .forEach(pill => selected.push(pill.dataset.group));
        return selected;
    },

    async save() {
        const alertIds = this.getSelectedAlertIds();
        if (alertIds.length === 0) {
            alert('Please select at least one alert first.');
            return;
        }

        const existingGroups = this.getSelectedGroups();
        const newGroups = this.parseNewGroups();

        if (existingGroups.length === 0 && newGroups.length === 0) {
            alert('Please choose an existing group or add a new one.');
            return;
        }

        const success = await AlertsAPI.groupAlerts(alertIds, existingGroups, newGroups);
        if (success) {
            AlertActions.showStatusNotification('Alert' + (alertIds.length > 1 ? 's' : '') + ' organized into group(s)');
            this.close();
            AlertActions.clearSelections();
            await AlertsRefresh.refresh();
        }
    },

    async deleteSelectedGroups() {
        const selectedGroups = this.getSelectedGroups();
        if (selectedGroups.length === 0) {
            alert('Please select at least one group to delete.');
            return;
        }

        const confirmed = window.confirm('Delete selected group' + (selectedGroups.length > 1 ? 's' : '') + '? This will remove them from all alerts.');
        if (!confirmed) return;

        const success = await AlertsAPI.deleteGroups(selectedGroups);
        if (success) {
            AlertActions.showStatusNotification('Group' + (selectedGroups.length > 1 ? 's' : '') + ' deleted');
            // Optimistically remove from local state to reflect immediately
            const remaining = AlertsState.getAlertGroups().filter(g => !selectedGroups.includes(g));
            AlertsState.setAlertGroups(remaining);
            await AlertsRefresh.refresh();
            this.renderExistingGroups();
        } else {
            alert('Failed to delete selected group(s). Please try again.');
        }
    }
};


// =============================================================================
// AUTOCOMPLETE MANAGEMENT
// =============================================================================
/**
 * Manages item search autocomplete functionality.
 * 
 * Why: Both create and edit forms need autocomplete. This manager provides
 * reusable autocomplete logic for any item name input.
 */
const AutocompleteManager = {
    /**
     * Tracks the currently selected suggestion index for each dropdown.
     * Keys are dropdown element IDs, values are the selected index (-1 = none).
     */
    selectedIndex: {},
    
    /**
     * Sets up autocomplete for an input/dropdown pair with full keyboard support.
     * 
     * What: Enables item search with suggestions dropdown
     * Why: Users need to find items by name, and keyboard navigation improves UX
     * How: Listens for input changes to fetch suggestions, and keydown events
     *      for arrow key navigation, Enter to select, and Escape to close
     * 
     * @param {HTMLElement} input - The text input element
     * @param {HTMLElement} hiddenInput - Hidden input to store selected item ID
     * @param {HTMLElement} dropdown - The suggestions dropdown container
     */
    setup(input, hiddenInput, dropdown) {
        if (!input || !dropdown) return;
        
        const dropdownId = dropdown.id;
        this.selectedIndex[dropdownId] = -1;
        
        /**
         * Updates visual highlighting of the currently selected suggestion.
         * Adds 'selected' class to the active item and scrolls it into view.
         */
        const updateSelection = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                if (index === this.selectedIndex[dropdownId]) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        };
        
        /**
         * Selects the currently highlighted suggestion.
         * Sets the input value and hidden ID, then closes the dropdown.
         */
        const selectCurrentItem = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            const index = this.selectedIndex[dropdownId];
            
            if (index >= 0 && index < items.length) {
                const selectedItem = items[index];
                input.value = selectedItem.dataset.name;
                hiddenInput.value = selectedItem.dataset.id;
                dropdown.style.display = 'none';
                this.selectedIndex[dropdownId] = -1;
            }
        };
        
        /**
         * Resets the selection index when new suggestions are loaded.
         */
        const resetSelection = () => {
            this.selectedIndex[dropdownId] = -1;
        };
        
        // Handle input changes - fetch suggestions
        input.addEventListener('input', async () => {
            const query = input.value;
            
            if (query.length < AlertsConfig.timing.minSearchLength) {
                dropdown.style.display = 'none';
                resetSelection();
                return;
            }
            
            const items = await AlertsAPI.searchItems(query);
            
            if (items.length > 0) {
                dropdown.innerHTML = AlertsUI.renderSuggestions(items);
                dropdown.style.display = 'block';
                resetSelection();
            } else {
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle keyboard navigation
        input.addEventListener('keydown', (e) => {
            // Only handle keys when dropdown is visible
            if (dropdown.style.display === 'none') return;
            
            const items = dropdown.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            switch (e.key) {
                case 'ArrowDown':
                    // Move selection down, wrap to top if at bottom
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        (this.selectedIndex[dropdownId] + 1) % items.length;
                    updateSelection();
                    break;
                    
                case 'ArrowUp':
                    // Move selection up, wrap to bottom if at top
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        this.selectedIndex[dropdownId] <= 0 
                            ? items.length - 1 
                            : this.selectedIndex[dropdownId] - 1;
                    updateSelection();
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Tab moves selection up like ArrowUp
                        this.selectedIndex[dropdownId] = 
                            this.selectedIndex[dropdownId] <= 0 
                                ? items.length - 1 
                                : this.selectedIndex[dropdownId] - 1;
                    } else {
                        // Tab moves selection down like ArrowDown
                        this.selectedIndex[dropdownId] = 
                            (this.selectedIndex[dropdownId] + 1) % items.length;
                    }
                    updateSelection();
                    break;
                    
                case 'Enter':
                    // Enter selects current item
                    if (this.selectedIndex[dropdownId] >= 0) {
                        e.preventDefault();
                        selectCurrentItem();
                    }
                    break;
                    
                case 'Escape':
                    // Escape closes dropdown without selecting
                    e.preventDefault();
                    dropdown.style.display = 'none';
                    resetSelection();
                    break;
            }
        });
        
        // Handle mouse click on suggestion
        dropdown.addEventListener('click', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                input.value = e.target.dataset.name;
                hiddenInput.value = e.target.dataset.id;
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle mouse hover to update selection
        dropdown.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (item === e.target) {
                        this.selectedIndex[dropdownId] = index;
                    }
                });
                updateSelection();
            }
        });
    },
    
    /**
     * Initializes autocomplete for both forms.
     */
    init() {
        // Create form autocomplete
        const createSelectors = AlertsConfig.selectors.create;
        this.setup(
            document.querySelector(createSelectors.itemName),
            document.querySelector(createSelectors.itemId),
            document.querySelector(createSelectors.suggestions)
        );
    }
};


// =============================================================================
// ALERTS REFRESH
// =============================================================================
/**
 * Handles periodic refresh of alerts data.
 * 
 * Why: Alerts can be triggered by the background script at any time.
 * Periodic refresh ensures the UI stays in sync.
 */
const AlertsRefresh = {
    intervalId: null,
    pausedForSort: false,
    
    /**
     * Fetches fresh data and updates the UI.
     */
    async refresh() {
        const data = await AlertsAPI.fetchAlerts();
        if (data) {
            AlertsUI.updateMyAlertsPane(data);
        }
    },
    
    /**
     * Starts the periodic refresh interval.
     */
    start() {
        if (this.intervalId) return;
        this.refresh();
        this.intervalId = setInterval(
            () => this.refresh(), 
            AlertsConfig.timing.refreshInterval
        );
    },
    
    /**
     * Temporarily pause refresh while user chooses sort order.
     */
    pauseForSort() {
        this.pausedForSort = true;
        this.stop();
    },
    
    /**
     * Resume refresh if it was paused for sort selection.
     */
    resumeAfterSort() {
        if (!this.pausedForSort) return;
        this.pausedForSort = false;
        this.start();
    },
    
    /**
     * Stops the periodic refresh.
     */
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }
};


// =============================================================================
// TAB NAVIGATION
// =============================================================================
/**
 * Manages tab switching between views.
 */
const TabManager = {
    /**
     * Switches to a specific tab.
     */
    switchTo(tabId) {
        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-tab') === tabId) {
                btn.classList.add('active');
            }
        });
        
        document.querySelectorAll(AlertsConfig.selectors.tabPanes).forEach(pane => {
            pane.style.display = 'none';
        });
        document.getElementById(tabId).style.display = 'block';
    },
    
    /**
     * Initializes tab click handlers.
     */
    init() {
        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(button => {
            button.addEventListener('click', function() {
                const tabId = button.getAttribute('data-tab');
                TabManager.switchTo(tabId);
            });
        });
    }
};


// =============================================================================
// EVENT MANAGEMENT
// =============================================================================
/**
 * Sets up all event listeners for the alerts system.
 */
const EventManager = {
    /**
     * Sets up modal event listeners.
     */
    setupModalEvents() {
        const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
        const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
        const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);
        
        // Close spread modal on backdrop click
        if (spreadModal) {
            spreadModal.addEventListener('click', function(e) {
                if (e.target.id === 'spread-modal') {
                    ModalManager.closeSpreadModal();
                }
            });
        }

        // Close spike modal on backdrop click
        if (spikeModal) {
            spikeModal.addEventListener('click', function(e) {
                if (e.target.id === 'spike-modal') {
                    ModalManager.closeSpikeModal();
                }
            });
        }

        // Close group modal on backdrop click
        if (groupModal) {
            groupModal.addEventListener('click', function(e) {
                if (e.target.id === 'group-modal') {
                    GroupManager.close();
                }
            });
        }
        
        // Close modals on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
                if (spreadModal && spreadModal.style.display === 'flex') {
                    ModalManager.closeSpreadModal();
                }
                const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);
                if (spikeModal && spikeModal.style.display === 'flex') {
                    ModalManager.closeSpikeModal();
                }
                const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
                if (groupModal && groupModal.style.display === 'flex') {
                    GroupManager.close();
                }
            }
        });
    },
    
    /**
     * Sets up autocomplete dropdown close on outside click.
     */
    setupAutocompleteEvents() {
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.form-group')) {
                const createSuggestions = document.querySelector(AlertsConfig.selectors.create.suggestions);
                
                if (createSuggestions) createSuggestions.style.display = 'none';
            }
        });
    },
    
    /**
     * Initializes all event listeners.
     */
    init() {
        this.setupModalEvents();
        this.setupAutocompleteEvents();
    }
};


// =============================================================================
// GLOBAL FUNCTION EXPORTS
// =============================================================================
/**
 * These functions are exposed globally for use in onclick handlers in HTML.
 */

// Form handlers
function handleAlertTypeChange() {
    FormManager.handleAlertTypeChange('create');
}

function handleSpreadScopeChange() {
    FormManager.handleSpreadScopeChange('create');
}

function handleSpikeScopeChange() {
    FormManager.handleSpikeScopeChange('create');
}

// Modal handlers
function closeSpreadModal() {
    ModalManager.closeSpreadModal();
}

function showSpreadDetails(alertId) {
    ModalManager.showSpreadDetails(alertId);
}

function closeSpikeModal() {
    ModalManager.closeSpikeModal();
}

function showSpikeDetails(alertId) {
    ModalManager.showSpikeDetails(alertId);
}

// Navigate to alert detail page
function navigateToAlertDetail(event, alertId) {
    // Don't navigate if clicking on checkbox
    if (event.target.classList.contains('alert-checkbox')) {
        return;
    }
    window.location.href = '/alerts/' + alertId + '/';
}

// Alert action handlers
function dismissAlert(alertId) {
    AlertActions.dismiss(alertId);
}

function dismissStatusNotification(button) {
    const notification = button.closest('.triggered-notification');
    if (notification) {
        notification.classList.add('dismissing');
        setTimeout(() => notification.remove(), 300);
    }
}

function addFilter(filterId) {
    if (filterId) {
        FilterManager.addFilter(filterId);
    }
}

function removeFilter(filterId) {
    // Animate the tag out first
    const tag = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
    if (tag) {
        tag.classList.add('removing');
        setTimeout(() => {
            FilterManager.removeFilter(filterId);
        }, 300);
    } else {
        FilterManager.removeFilter(filterId);
    }
}

function confirmFilterInput(filterId) {
    FilterManager.confirmFilterInput(filterId);
}

function cancelFilterInput(filterId) {
    FilterManager.cancelFilterInput(filterId);
}

function handleFilterInputKeydown(event, filterId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        confirmFilterInput(filterId);
    } else if (event.key === 'Escape') {
        event.preventDefault();
        cancelFilterInput(filterId);
    }
}

// Sort handlers
function handleSortSelection(sortKey) {
    SortManager.handleSortSelection(sortKey);
}

function applySortOrder(order) {
    SortManager.applySortOrder(order);
}

function clearSort() {
    SortManager.clearSort();
}

// Groups filter modal functions
function openGroupsFilterModal() {
    const modal = document.getElementById('groups-filter-modal');
    const listContainer = document.getElementById('groups-filter-list');
    const noGroupsMsg = document.getElementById('no-groups-message');
    
    const groups = AlertsState.getAlertGroups();
    const selectedGroups = AlertsState.getFilterValue('myGroups') || [];
    
    if (groups.length === 0) {
        listContainer.style.display = 'none';
        noGroupsMsg.style.display = 'block';
    } else {
        listContainer.style.display = 'block';
        noGroupsMsg.style.display = 'none';
        
        listContainer.innerHTML = '';
        groups.forEach(group => {
            const pill = document.createElement('span');
            pill.className = 'group-pill' + (selectedGroups.includes(group) ? ' selected' : '');
            pill.textContent = group;
            pill.dataset.group = group;
            pill.addEventListener('click', function() {
                this.classList.toggle('selected');
            });
            listContainer.appendChild(pill);
        });
    }
    
    modal.style.display = 'flex';
}

function closeGroupsFilterModal() {
    const modal = document.getElementById('groups-filter-modal');
    modal.style.display = 'none';
}

function applyGroupsFilter() {
    const pills = document.querySelectorAll('#groups-filter-list .group-pill.selected');
    const selectedGroups = Array.from(pills).map(pill => pill.dataset.group);
    const sortedSelectedGroups = selectedGroups.slice().sort((a, b) => a.localeCompare(b));
    
    if (sortedSelectedGroups.length === 0) {
        // If no groups selected, remove the filter if it exists
        if (AlertsState.activeFilters.has('myGroups')) {
            FilterManager.removeFilter('myGroups');
        }
        closeGroupsFilterModal();
        return;
    }
    
    AlertsState.setFilterValue('myGroups', sortedSelectedGroups);
    
    // If filter not already active, activate it
    if (!AlertsState.activeFilters.has('myGroups')) {
        const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
        FilterManager.activateFilter('myGroups', displayValue);
    } else {
        // Update the filter tag label
        const tag = document.querySelector('.filter-tag[data-filter-id="myGroups"]');
        if (tag) {
            const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
            tag.innerHTML = 'My Groups: ' + displayValue + 
                '<button class="filter-tag-remove" onclick="removeFilter(\'myGroups\')">&times;</button>';
        }
        FilterManager.updateAlertsList();
    }
    
    closeGroupsFilterModal();
}

function openPriceFilterModal(filterId) {
    const modal = document.getElementById('price-filter-modal');
    const title = document.getElementById('price-filter-title');
    const label = document.getElementById('price-filter-label');
    const input = document.getElementById('price-filter-input');
    if (!modal || !title || !label || !input) return;
    modal.dataset.filterId = filterId;
    const isMin = filterId === 'minimumPrice';
    title.textContent = isMin ? 'Set Minimum Price' : 'Set Maximum Price';
    label.textContent = isMin ? 'Minimum Price' : 'Maximum Price';
    input.placeholder = isMin ? 'Enter minimum price...' : 'Enter maximum price...';
    input.value = '';
    modal.style.display = 'flex';
    setTimeout(() => input.focus(), 0);
}

function closePriceFilterModal() {
    const modal = document.getElementById('price-filter-modal');
    if (modal) modal.style.display = 'none';
}

function applyPriceFilter() {
    const modal = document.getElementById('price-filter-modal');
    const input = document.getElementById('price-filter-input');
    if (!modal || !input) return;
    const filterId = modal.dataset.filterId;
    const value = input.value.trim();
    if (!filterId || !value) {
        closePriceFilterModal();
        return;
    }
    AlertsState.setFilterValue(filterId, value);
    FilterManager.activateFilter(filterId, value);
    closePriceFilterModal();
}

function confirmDelete() {
    AlertActions.confirmDelete();
}


// =============================================================================
// INITIALIZATION
// =============================================================================
/**
 * Initialize the alerts system when the script loads.
 */
(function init() {
    TabManager.init();
    AutocompleteManager.init();
    EventManager.init();
    DropdownSizer.init();
    AlertsRefresh.start();
    
    // Check for deleted parameter and show notification
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('deleted') === '1') {
        AlertActions.showStatusNotification('Alert deleted');
        // Remove the parameter from URL without reload
        const newUrl = window.location.pathname;
        window.history.replaceState({}, document.title, newUrl);
    }
})();
</script>

{% endblock %}
