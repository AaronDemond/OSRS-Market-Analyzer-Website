{% extends 'base.html' %}

{% block title %}Alerts - OSRS Market Tracker{% endblock %}

{% block content %}
<h1>Alerts</h1>
<hr>

<div class="alert-tabs">
    <button class="tab-btn active" data-tab="my-alerts">My Alerts</button>
    <button class="tab-btn" data-tab="create-alert">Create Alert</button>
    <button class="tab-btn" data-tab="edit-delete-alert">Edit Alert</button>
</div>

<div class="tab-content">
    <div id="my-alerts" class="tab-pane active">
        <div id="triggered-notifications">
            {% for message in messages %}
                <div class="triggered-notification status-notification">
                    {{ message }}
                    <button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>
                </div>
            {% endfor %}
            {% for alert in triggered_alerts %}
                <div class="triggered-notification" data-alert-id="{{ alert.id }}">
                    {{ alert.triggered_text }}
                    <button class="dismiss-btn" onclick="dismissAlert({{ alert.id }})">&times;</button>
                </div>
            {% endfor %}
        </div>
        {% if all_alerts %}
        <div class="alert-actions">
            <div class="alert-actions-left">
                <button class="action-btn delete-btn" onclick="toggleDeleteMode()">Delete Alert(s)</button>
                <button class="action-btn confirm-delete-btn" onclick="confirmDelete()" style="display: none;">Confirm Delete</button>
                <button class="action-btn cancel-btn" onclick="cancelDeleteMode()" style="display: none;">Cancel</button>
            </div>
            <div class="alert-actions-right" id="active-filters">
                <select class="filter-dropdown" onchange="addFilter(this.value); this.value='';">
                    <option value="">Add Filter...</option>
                    <option value="triggered">Triggered</option>
                    <option value="notTriggered">Not Triggered</option>
                </select>
            </div>
        </div>
            <ul class="alerts-list">
                {% for alert in all_alerts %}
                    <li class="alert-item" data-alert-id="{{ alert.id }}">
                        <input type="checkbox" class="alert-checkbox" style="display: none;">
                        <span class="alert-icon">ðŸ””</span>
                        <span class="alert-text">{{ alert }}</span>
                        {% if alert.is_triggered %}
                            <span class="alert-triggered">TRIGGERED: {{alert.triggered_text}} </span>
                        {% endif %}
                    </li>
                {% endfor %}
            </ul>
        {% elif not triggered_alerts %}
            <p class="no-alerts">No active alerts. Create one to get started!</p>
        {% endif %}
    </div>
    <div id="create-alert" class="tab-pane" style="display: none;">
        <form method="POST" action="{% url 'create_alert' %}" class="create-alert-form">
            {% csrf_token %}
            <div class="form-group">
                <label for="alert-type">Alert Type</label>
                <select name="type" id="alert-type" required onchange="handleAlertTypeChange()">
                    <option value="above" selected>Above Threshold</option>
                    <option value="below">Below Threshold</option>
                    <option value="spread">Spread</option>
                </select>
            </div>
            
            <!-- Spread-specific fields -->
            <div class="form-group" id="spread-scope-group" style="display: none;">
                <label for="spread-scope">Apply To</label>
                <select name="spread_scope" id="spread-scope" onchange="handleSpreadScopeChange()">
                    <option value="all">All Items</option>
                    <option value="specific">Specific Item</option>
                </select>
            </div>
            
            <!-- Item fields (shown for above/below, or spread with specific item) -->
            <div class="form-group" id="item-name-group">
                <label for="item-name">Item Name</label>
                <input type="text" name="item_name" id="item-name" autocomplete="off">
                <input type="hidden" name="item_id" id="item-id">
                <input type="hidden" name="is_all_items" id="is-all-items" value="false">
                <div id="item-suggestions" class="suggestions-dropdown"></div>
            </div>
            
            <!-- Price fields (shown for above/below only) -->
            <div class="form-group" id="price-group">
                <label for="price">Price Threshold</label>
                <input type="number" name="price" id="price">
            </div>
            <div class="form-group" id="reference-group">
                <label for="reference">Reference Price</label>
                <select name="reference" id="reference">
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                </select>
            </div>
            
            <!-- Percentage field (shown for spread only) -->
            <div class="form-group" id="percentage-group" style="display: none;">
                <label for="percentage">Spread Percentage (%)</label>
                <input type="number" name="percentage" id="percentage" step="0.1" min="0">
            </div>
            
            <!-- Min/Max price fields (shown for spread all items only) -->
            <div class="form-group" id="min-price-group" style="display: none;">
                <label for="minimum-price">Minimum Price</label>
                <input type="number" name="minimum_price" id="minimum-price" min="0">
            </div>
            <div class="form-group" id="max-price-group" style="display: none;">
                <label for="maximum-price">Maximum Price</label>
                <input type="number" name="maximum_price" id="maximum-price" min="0">
            </div>
            
            <div class="form-group checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" name="email_notification" id="email-notification">
                    Receive Email Notification
                </label>
            </div>
            
            <button type="submit" class="btn-create-alert">Create Alert</button>
        </form>
    </div>
    <div id="edit-delete-alert" class="tab-pane" style="display: none;">
        {% if all_alerts %}
            <ul class="alerts-list edit-alerts-list">
                {% for alert in all_alerts %}
                    <li class="alert-item clickable-alert" onclick="openEditModal({{ alert.id }}, '{{ alert.type }}', '{{ alert.item_name|default_if_none:"" }}', {{ alert.item_id|default_if_none:"null" }}, {{ alert.price|default_if_none:"null" }}, '{{ alert.reference|default_if_none:"" }}', {{ alert.percentage|default_if_none:"null" }}, {{ alert.is_all_items|yesno:"true,false,false" }}, {{ alert.minimum_price|default_if_none:"null" }}, {{ alert.maximum_price|default_if_none:"null" }}, {{ alert.email_notification|yesno:"true,false,false" }})">
                        <span class="alert-icon">ðŸ””</span>
                        <span class="alert-text">{{ alert }}</span>
                        <span class="edit-hint">Click to edit</span>
                    </li>
                {% endfor %}
            </ul>
        {% else %}
            <p class="no-alerts">No alerts to edit.</p>
        {% endif %}
    </div>
</div>

<!-- Edit Modal -->
<div id="edit-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Edit Alert</h2>
            <button class="modal-close" onclick="closeEditModal()">&times;</button>
        </div>
        <form id="edit-alert-form" class="edit-alert-form">
            <input type="hidden" id="edit-alert-id">
            <input type="hidden" id="edit-is-all-items">
            <div class="form-group">
                <label for="edit-alert-type">Alert Type</label>
                <select name="type" id="edit-alert-type" required onchange="handleEditAlertTypeChange()">
                    <option value="above">Above Threshold</option>
                    <option value="below">Below Threshold</option>
                    <option value="spread">Spread</option>
                </select>
            </div>
            
            <!-- Spread-specific fields -->
            <div class="form-group" id="edit-spread-scope-group" style="display: none;">
                <label for="edit-spread-scope">Apply To</label>
                <select name="spread_scope" id="edit-spread-scope" onchange="handleEditSpreadScopeChange()">
                    <option value="all">All Items</option>
                    <option value="specific">Specific Item</option>
                </select>
            </div>
            
            <div class="form-group" id="edit-item-name-group">
                <label for="edit-item-name">Item Name</label>
                <input type="text" name="item_name" id="edit-item-name" autocomplete="off">
                <input type="hidden" name="item_id" id="edit-item-id">
                <div id="edit-item-suggestions" class="suggestions-dropdown"></div>
            </div>
            <div class="form-group" id="edit-price-group">
                <label for="edit-price">Price Threshold</label>
                <input type="number" name="price" id="edit-price">
            </div>
            <div class="form-group" id="edit-reference-group">
                <label for="edit-reference">Reference Price</label>
                <select name="reference" id="edit-reference">
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                </select>
            </div>
            
            <!-- Percentage field (shown for spread only) -->
            <div class="form-group" id="edit-percentage-group" style="display: none;">
                <label for="edit-percentage">Spread Percentage (%)</label>
                <input type="number" name="percentage" id="edit-percentage" step="0.1" min="0">
            </div>
            
            <!-- Min/Max price fields (shown for spread all items only) -->
            <div class="form-group" id="edit-min-price-group" style="display: none;">
                <label for="edit-minimum-price">Minimum Price</label>
                <input type="number" name="minimum_price" id="edit-minimum-price" min="0">
            </div>
            <div class="form-group" id="edit-max-price-group" style="display: none;">
                <label for="edit-maximum-price">Maximum Price</label>
                <input type="number" name="maximum_price" id="edit-maximum-price" min="0">
            </div>
            
            <div class="form-group checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" name="email_notification" id="edit-email-notification">
                    Receive Email Notification
                </label>
            </div>
            
            <div class="modal-buttons">
                <button type="button" class="btn-save" onclick="saveAlert()">Save</button>
                <button type="button" class="btn-cancel" onclick="closeEditModal()">Cancel</button>
            </div>
        </form>
    </div>
</div>

<!-- Spread Details Modal -->
<div id="spread-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spread Alert Details</h2>
            <button class="modal-close" onclick="closeSpreadModal()">&times;</button>
        </div>
        <div id="spread-modal-body">
            <ul id="spread-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpreadModal()">Close</button>
        </div>
    </div>
</div>
<style>
    .alert-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }
    .tab-btn {
        padding: 10px 20px;
        border: none;
        background-color: transparent;
        cursor: pointer;
        font-size: 16px;
        border-bottom: 2px solid transparent;
    }
    .tab-btn:hover {
        border-bottom: 2px solid #ccc;
    }
    .tab-btn.active {
        border-bottom: 2px solid #007bff;
        color: #007bff;
    }
    .tab-content {
        padding: 20px;
    }
    .alerts-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .alert-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 15px 20px;
        margin-bottom: 10px;
        background-color: #cce5ff;
        border-left: 4px solid #007bff;
        border-radius: 8px;
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        max-height: 200px;
        overflow: hidden;
    }
    .alert-item:hover {
        transform: translateX(5px);
        box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
    }
    .alert-item.deleting {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .alert-text {
        flex: 1;
    }
    .alert-triggered {
        font-weight: 700;
        color: #8b5cf6;
        background-color: #ede9fe;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.85rem;
        letter-spacing: 0.5px;
    }
    .alert-icon {
        font-size: 1.4rem;
    }
    .alert-text {
        font-size: 1rem;
        color: #333;
    }
    .no-alerts {
        color: #6c757d;
        font-style: italic;
        padding: 20px;
        text-align: center;
    }
    .alert-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
    }
    .alert-actions-left {
        display: flex;
        gap: 10px;
    }
    .alert-actions-right {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .action-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s ease;
    }
    .edit-btn {
        background-color: #007bff;
        color: white;
    }
    .edit-btn:hover {
        background-color: #0056b3;
    }
    .delete-btn {
        background-color: #dc3545;
        color: white;
    }
    .delete-btn:hover {
        background-color: #c82333;
    }
    .confirm-delete-btn {
        background-color: #dc3545;
        color: white;
    }
    .confirm-delete-btn:hover {
        background-color: #c82333;
    }
    .cancel-btn {
        background-color: #6c757d;
        color: white;
    }
    .cancel-btn:hover {
        background-color: #5a6268;
    }
    .alert-checkbox {
        width: 20px;
        height: 20px;
        cursor: pointer;
        accent-color: #dc3545;
    }
    .alert-item.delete-mode {
        background-color: #fff3cd;
        border-left-color: #dc3545;
    }
    .triggered-notification {
        background-color: #28a745;
        color: white;
        padding: 15px 40px 15px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        position: relative;
        font-weight: 500;
        transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        max-height: 100px;
        overflow: hidden;
    }
    .triggered-notification.dismissing {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .triggered-notification .dismiss-btn {
        position: absolute;
        top: 50%;
        right: 15px;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        opacity: 0.8;
    }
    .triggered-notification .dismiss-btn:hover {
        opacity: 1;
    }
    /* Filter UI styles */
    .filter-dropdown {
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 14px;
        cursor: pointer;
        background-color: white;
    }
    .filter-dropdown:focus {
        outline: none;
        border-color: #007bff;
    }
    .active-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 15px;
        min-height: 0;
    }
    .filter-tag {
        display: inline-flex;
        align-items: center;
        background-color: #007bff;
        color: white;
        padding: 6px 10px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        animation: filterTagIn 0.3s ease forwards;
        max-width: 200px;
        overflow: hidden;
    }
    .filter-tag.removing {
        animation: filterTagOut 0.3s ease forwards;
    }
    @keyframes filterTagIn {
        from {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
            margin: 0;
        }
        to {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 10px;
        }
    }
    @keyframes filterTagOut {
        from {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 10px;
        }
        to {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
            margin: 0;
        }
    }
    .filter-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 6px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.8;
        padding: 0;
    }
    .filter-tag-remove:hover {
        opacity: 1;
    }
    .create-alert-form {
        max-width: 400px;
    }
    .form-group {
        margin-bottom: 15px;
        position: relative;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #333;
    }
    .form-group input,
    .form-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 14px;
    }
    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
    }
    .checkbox-group {
        display: flex;
        align-items: center;
    }
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-weight: 600;
        color: #333;
    }
    .checkbox-label input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #007bff;
    }
    .btn-create-alert {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-create-alert:hover {
        background-color: #0056b3;
    }
    .suggestions-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 5px 5px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
    }
    .suggestion-item {
        padding: 10px;
        cursor: pointer;
    }
    .suggestion-item:hover,
    .suggestion-item.selected {
        background-color: #007bff;
        color: white;
    }
    .clickable-alert {
        cursor: pointer;
    }
    .clickable-alert:hover {
        background-color: #b8daff;
    }
    .edit-hint {
        font-size: 0.8rem;
        color: #6c757d;
        font-style: italic;
        margin-left: auto;
    }
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .modal-content {
        background-color: white;
        padding: 30px;
        border-radius: 12px;
        width: 100%;
        max-width: 450px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    .modal-header h2 {
        margin: 0;
        color: #333;
    }
    .modal-close {
        background: none;
        border: none;
        font-size: 28px;
        cursor: pointer;
        color: #666;
        line-height: 1;
    }
    .modal-close:hover {
        color: #333;
    }
    .modal-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
    .btn-save {
        flex: 1;
        background-color: #28a745;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-save:hover {
        background-color: #218838;
    }
    .btn-cancel {
        flex: 1;
        background-color: #6c757d;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
    }
    .btn-cancel:hover {
        background-color: #5a6268;
    }
    .edit-alert-form {
        max-width: 100%;
    }
    .modal-content-large {
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
    }
    #spread-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #spread-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #spread-items-list li:last-child {
        border-bottom: none;
    }
    .spread-item-name {
        font-weight: 600;
        color: #333;
    }
    .spread-item-details {
        color: #666;
        font-size: 0.9rem;
    }
    .spread-item-percentage {
        font-weight: 700;
        color: #28a745;
        font-size: 1.1rem;
    }
    .clickable-triggered {
        cursor: pointer;
        text-decoration: underline;
    }
    .clickable-triggered:hover {
        opacity: 0.8;
    }
</style>

<script>
/**
 * =============================================================================
 * OSRS ALERTS MANAGEMENT SYSTEM
 * =============================================================================
 * 
 * This module handles all client-side functionality for the alerts system:
 * - Creating and editing alerts (above/below threshold, spread alerts)
 * - Displaying triggered alerts with real-time updates
 * - Managing alert lifecycle (dismiss, delete)
 * - Item search autocomplete functionality
 * - Modal management for spread details and editing
 * 
 * Architecture:
 * - AlertsConfig: Central configuration object for settings and selectors
 * - AlertsState: Manages application state (delete mode, etc.)
 * - AlertsAPI: Handles all server communication
 * - AlertsUI: Manages DOM updates and rendering
 * - FormManager: Handles form field visibility and validation
 * - ModalManager: Controls modal dialogs
 * - AutocompleteManager: Handles item search suggestions
 * - EventManager: Sets up all event listeners
 * 
 * =============================================================================
 */

// =============================================================================
// CONFIGURATION
// =============================================================================
/**
 * Central configuration object containing all settings, selectors, and constants.
 * 
 * Why: Centralizing configuration makes it easy to modify settings without
 * searching through code. It also makes the codebase more maintainable.
 * 
 * How: All DOM selectors, API endpoints, and timing settings are defined here
 * and referenced throughout the application.
 */
const AlertsConfig = {
    // API endpoints for server communication
    endpoints: {
        alerts: '/api/alerts/',
        dismiss: '/api/alerts/dismiss/',
        delete: '/api/alerts/delete/',
        update: '/api/alerts/update/',
        itemSearch: '/api/items/'
    },
    
    // Timing settings (in milliseconds)
    timing: {
        refreshInterval: 5000,      // How often to poll for alert updates
        minSearchLength: 2          // Minimum characters before searching
    },
    
    // Available filters for the alerts list
    filters: {
        triggered: { id: 'triggered', label: 'Triggered', test: alert => alert.is_triggered },
        notTriggered: { id: 'notTriggered', label: 'Not Triggered', test: alert => !alert.is_triggered }
    },
    
    // DOM element selectors for the create form
    selectors: {
        create: {
            alertType: '#alert-type',
            spreadScope: '#spread-scope',
            itemName: '#item-name',
            itemId: '#item-id',
            isAllItems: '#is-all-items',
            emailNotification: '#email-notification',
            suggestions: '#item-suggestions',
            groups: {
                spreadScope: '#spread-scope-group',
                itemName: '#item-name-group',
                price: '#price-group',
                reference: '#reference-group',
                percentage: '#percentage-group',
                minPrice: '#min-price-group',
                maxPrice: '#max-price-group'
            }
        },
        // DOM element selectors for the edit form
        edit: {
            modal: '#edit-modal',
            alertId: '#edit-alert-id',
            alertType: '#edit-alert-type',
            spreadScope: '#edit-spread-scope',
            itemName: '#edit-item-name',
            itemId: '#edit-item-id',
            isAllItems: '#edit-is-all-items',
            price: '#edit-price',
            reference: '#edit-reference',
            percentage: '#edit-percentage',
            minimumPrice: '#edit-minimum-price',
            maximumPrice: '#edit-maximum-price',
            emailNotification: '#edit-email-notification',
            suggestions: '#edit-item-suggestions',
            groups: {
                spreadScope: '#edit-spread-scope-group',
                itemName: '#edit-item-name-group',
                price: '#edit-price-group',
                reference: '#edit-reference-group',
                percentage: '#edit-percentage-group',
                minPrice: '#edit-min-price-group',
                maxPrice: '#edit-max-price-group'
            }
        },
        // Other UI elements
        myAlertsPane: '#my-alerts',
        spreadModal: '#spread-modal',
        spreadItemsList: '#spread-items-list',
        tabButtons: '.tab-btn',
        tabPanes: '.tab-pane'
    },
    
    // Alert type constants for comparison
    alertTypes: {
        ABOVE: 'above',
        BELOW: 'below',
        SPREAD: 'spread'
    },
    
    // CSRF token for Django POST requests
    csrfToken: '{{ csrf_token }}'
};


// =============================================================================
// STATE MANAGEMENT
// =============================================================================
/**
 * Application state manager.
 * 
 * Why: Centralizing state prevents scattered variables and makes it easier
 * to track and debug the application's current status.
 * 
 * How: All mutable state is stored in this object and accessed/modified
 * through consistent patterns.
 */
const AlertsState = {
    deleteMode: false,              // Whether delete mode is active
    spreadDataCache: {},            // Cache for spread alert data (keyed by alert ID)
    activeFilters: new Set(),       // Currently active filter IDs
    
    /**
     * Stores spread data for a specific alert in the cache.
     * This allows the spread details modal to access the data later.
     */
    setSpreadData(alertId, data) {
        this.spreadDataCache[alertId] = data;
    },
    
    /**
     * Retrieves cached spread data for an alert.
     * Returns null if no data exists for the given ID.
     */
    getSpreadData(alertId) {
        return this.spreadDataCache[alertId] || null;
    }
};


// =============================================================================
// API COMMUNICATION
// =============================================================================
/**
 * Handles all server communication.
 * 
 * Why: Centralizing API calls makes it easier to handle errors consistently,
 * modify endpoints, and add features like request caching or retries.
 * 
 * How: Each method corresponds to a specific API action and returns a Promise.
 */
const AlertsAPI = {
    /**
     * Fetches current alerts data from the server.
     * Returns both active alerts and triggered notifications.
     */
    async fetchAlerts() {
        try {
            const response = await fetch(AlertsConfig.endpoints.alerts);
            return await response.json();
        } catch (error) {
            console.error('Error fetching alerts:', error);
            return null;
        }
    },
    
    /**
     * Dismisses a triggered alert notification.
     * The alert remains in the system but the notification banner is hidden.
     */
    async dismissAlert(alertId) {
        try {
            await fetch(AlertsConfig.endpoints.dismiss, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_id: alertId })
            });
            return true;
        } catch (error) {
            console.error('Error dismissing alert:', error);
            return false;
        }
    },
    
    /**
     * Deletes multiple alerts by their IDs.
     */
    async deleteAlerts(alertIds) {
        try {
            await fetch(AlertsConfig.endpoints.delete, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_ids: alertIds })
            });
            return true;
        } catch (error) {
            console.error('Error deleting alerts:', error);
            return false;
        }
    },
    
    /**
     * Updates an existing alert with new values.
     */
    async updateAlert(alertData) {
        try {
            await fetch(AlertsConfig.endpoints.update, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify(alertData)
            });
            return true;
        } catch (error) {
            console.error('Error updating alert:', error);
            return false;
        }
    },
    
    /**
     * Searches for items by name query.
     * Used for autocomplete in item name fields.
     */
    async searchItems(query) {
        try {
            const url = AlertsConfig.endpoints.itemSearch + '?q=' + encodeURIComponent(query);
            const response = await fetch(url);
            return await response.json();
        } catch (error) {
            console.error('Error searching items:', error);
            return [];
        }
    }
};


// =============================================================================
// UI RENDERING
// =============================================================================
/**
 * Handles all DOM updates and HTML rendering.
 * 
 * Why: Separating UI logic from business logic makes the code easier to test,
 * modify, and understand. Changes to how things look don't affect how they work.
 * 
 * How: Each method handles a specific rendering task and returns HTML strings
 * or directly manipulates the DOM as appropriate.
 */
const AlertsUI = {
    /**
     * Generates the triggered text for an alert based on its type and data.
     * 
     * Why: Different alert types need different information displayed when triggered.
     * - Spread (all items): Shows clickable link to view all matching items
     * - Spread (single item): Shows low, high, and spread percentage
     * - Above/Below: Shows the price movement that triggered the alert
     */
    buildTriggeredText(alert) {
        const { alertTypes } = AlertsConfig;
        
        // Spread alert for all items - show clickable link
        if (alert.type === alertTypes.SPREAD && alert.is_all_items && alert.triggered_data) {
            return 'Alert triggered. Click for details';
        }
        
        // Spread alert for single item - show price details
        if (alert.type === alertTypes.SPREAD && !alert.is_all_items) {
            if (alert.spread_high && alert.spread_low) {
                return 'Alert triggered. Low: ' + alert.spread_low.toLocaleString() + 
                       ', High: ' + alert.spread_high.toLocaleString() + 
                       ', Spread: ' + alert.spread_percentage + '%';
            }
        }
        
        // Above/Below alert - show price movement
        if ((alert.type === alertTypes.ABOVE || alert.type === alertTypes.BELOW) && alert.current_price) {
            const refLabel = alert.reference === 'high' ? 'High' : 'Low';
            const direction = alert.type === alertTypes.ABOVE ? 'rose above' : 'fell below';
            return 'Alert triggered. ' + refLabel + ' price ' + direction + ' ' +
                   alert.price.toLocaleString() + ' to ' + alert.current_price.toLocaleString();
        }
        
        // Default fallback
        return 'Alert triggered.';
    },
    
    /**
     * Checks if an alert is a spread-all-items type.
     */
    isSpreadAllItemsAlert(alert) {
        return alert.type === AlertsConfig.alertTypes.SPREAD && 
               alert.is_all_items && 
               alert.triggered_data;
    },
    
    /**
     * Renders the green notification banners for triggered alerts.
     */
    renderTriggeredNotifications(triggeredAlerts) {
        if (!triggeredAlerts || triggeredAlerts.length === 0) {
            return '';
        }
        
        let html = '';
        triggeredAlerts.forEach(alert => {
            const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
            
            // Cache spread data for later use in modal
            if (isSpreadAllItems) {
                AlertsState.setSpreadData(alert.id, alert.triggered_data);
            }
            
            const clickHandler = isSpreadAllItems 
                ? 'onclick="ModalManager.showSpreadDetails(' + alert.id + ')"' 
                : '';
            const clickableClass = isSpreadAllItems ? 'clickable-triggered' : '';
            
            html += '<div class="triggered-notification" data-alert-id="' + alert.id + '">' +
                    '<span class="' + clickableClass + '" ' + clickHandler + '>' + alert.triggered_text + '</span>' +
                    '<button class="dismiss-btn" onclick="event.stopPropagation(); AlertActions.dismiss(' + alert.id + ')">&times;</button>' +
                    '</div>';
        });
        
        return html;
    },
    
    /**
     * Renders the action buttons (Delete, Confirm, Cancel) and filter dropdown.
     * @param {boolean} hasAlerts - Whether there are alerts to display
     * @param {string} preservedFilterTagsHtml - HTML of preserved filter tags (optional)
     */
    renderActionButtons(hasAlerts, preservedFilterTagsHtml) {
        if (!hasAlerts) return '';
        
        const { deleteMode } = AlertsState;
        
        // Build dropdown options (exclude already active filters)
        let options = '<option value="">Add Filter...</option>';
        for (const [id, filter] of Object.entries(AlertsConfig.filters)) {
            if (!FilterManager.isActive(id)) {
                options += '<option value="' + id + '">' + filter.label + '</option>';
            }
        }
        
        // Use preserved filter tags if provided, otherwise build from state
        let tags = preservedFilterTagsHtml || '';
        if (!preservedFilterTagsHtml) {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (filter) {
                    tags += '<span class="filter-tag" data-filter-id="' + filterId + '">' + filter.label + 
                            '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                            '</span>';
                }
            }
        }
        
        return '<div class="alert-actions">' +
               '<div class="alert-actions-left">' +
               '<button class="action-btn delete-btn" onclick="AlertActions.toggleDeleteMode()" ' +
               'style="' + (deleteMode ? 'display:none' : '') + '">Delete Alert(s)</button>' +
               '<button class="action-btn confirm-delete-btn" onclick="AlertActions.confirmDelete()" ' +
               'style="' + (deleteMode ? '' : 'display:none') + '">Confirm Delete</button>' +
               '<button class="action-btn cancel-btn" onclick="AlertActions.cancelDeleteMode()" ' +
               'style="' + (deleteMode ? '' : 'display:none') + '">Cancel</button>' +
               '</div>' +
               '<div class="alert-actions-right" id="active-filters">' +
               tags +
               '<select class="filter-dropdown" onchange="addFilter(this.value); this.value=\'\';">' + options + '</select>' +
               '</div>' +
               '</div>';
    },
    
    /**
     * Renders a single alert list item.
     */
    renderAlertItem(alert) {
        const { deleteMode } = AlertsState;
        const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
        
        // Cache spread data if triggered
        if (isSpreadAllItems && alert.is_triggered) {
            AlertsState.setSpreadData(alert.id, alert.triggered_data);
        }
        
        const clickHandler = isSpreadAllItems && alert.is_triggered 
            ? 'onclick="ModalManager.showSpreadDetails(' + alert.id + ')"' 
            : '';
        const clickableClass = isSpreadAllItems && alert.is_triggered 
            ? 'clickable-triggered' 
            : '';
        
        // Build triggered badge if needed
        let triggeredBadge = '';
        if (alert.is_triggered) {
            const triggeredText = this.buildTriggeredText(alert);
            triggeredBadge = '<span class="alert-triggered ' + clickableClass + '" ' + clickHandler + '>' + triggeredText + '</span>';
        }
        
        return '<li class="alert-item ' + (deleteMode ? 'delete-mode' : '') + '" data-alert-id="' + alert.id + '">' +
               '<input type="checkbox" class="alert-checkbox" style="' + (deleteMode ? 'display:block' : 'display:none') + '">' +
               '<span class="alert-icon">ðŸ””</span>' +
               '<span class="alert-text">' + alert.text + '</span>' +
               triggeredBadge +
               '</li>';
    },
    
    /**
     * Renders the complete alerts list.
     */
    renderAlertsList(alerts) {
        if (!alerts || alerts.length === 0) {
            return '<p class="no-alerts">No active alerts. Create one to get started!</p>';
        }
        
        // Apply active filters
        const filteredAlerts = FilterManager.applyFilters(alerts);
        
        if (filteredAlerts.length === 0) {
            return '<p class="no-alerts">No alerts match the current filters.</p>';
        }
        
        let html = '<ul class="alerts-list">';
        filteredAlerts.forEach(alert => {
            html += this.renderAlertItem(alert);
        });
        html += '</ul>';
        return html;
    },
    
    /**
     * Renders the spread details modal content.
     */
    renderSpreadItemsList(items) {
        let html = '';
        items.forEach(item => {
            const lowPrice = item.low ? item.low.toLocaleString() : 'N/A';
            const highPrice = item.high ? item.high.toLocaleString() : 'N/A';
            
            html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Low: ' + lowPrice + ' | High: ' + highPrice + '</div>' +
                    '</div>' +
                    '<span class="spread-item-percentage">' + item.spread + '%</span>' +
                    '</li>';
        });
        return html;
    },
    
    /**
     * Renders autocomplete suggestions.
     */
    renderSuggestions(items) {
        let html = '';
        items.forEach(item => {
            html += '<div class="suggestion-item" data-id="' + item.id + '" data-name="' + item.name + '">' + item.name + '</div>';
        });
        return html;
    },
    
    /**
     * Updates the entire My Alerts pane with fresh data.
     * Preserves status notifications and filter tags to prevent flashing.
     */
    updateMyAlertsPane(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;
        
        // If there are active filters, do a selective update to avoid flashing
        if (AlertsState.activeFilters.size > 0) {
            this.updateMyAlertsPaneSelective(data);
            return;
        }
        
        // Preserve any status notifications (e.g., "Alert created")
        const existingStatusNotifications = pane.querySelectorAll('.status-notification');
        let statusHtml = '';
        existingStatusNotifications.forEach(n => {
            statusHtml += n.outerHTML;
        });
        
        const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
        const actionsHtml = this.renderActionButtons(data.alerts && data.alerts.length > 0, '');
        
        let alertsHtml = '';
        if (data.alerts && data.alerts.length > 0) {
            alertsHtml = this.renderAlertsList(data.alerts);
        } else if (!data.triggered || data.triggered.length === 0) {
            alertsHtml = this.renderAlertsList([]);
        }
        
        pane.innerHTML = '<div id="triggered-notifications">' + statusHtml + notificationsHtml + '</div>' +
                        actionsHtml + alertsHtml;
    },
    
    /**
     * Selectively updates parts of the My Alerts pane without touching the action bar.
     * Used when filters are active to prevent filter tags from flashing.
     */
    updateMyAlertsPaneSelective(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;
        
        // Update triggered notifications (preserve status notifications)
        const notificationsContainer = pane.querySelector('#triggered-notifications');
        if (notificationsContainer) {
            const existingStatusNotifications = notificationsContainer.querySelectorAll('.status-notification');
            let statusHtml = '';
            existingStatusNotifications.forEach(n => {
                statusHtml += n.outerHTML;
            });
            const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
            notificationsContainer.innerHTML = statusHtml + notificationsHtml;
        }
        
        // Update alerts list only
        const alertsList = pane.querySelector('.alerts-list');
        const noAlertsMsg = pane.querySelector('.no-alerts');
        
        const filteredAlerts = FilterManager.applyFilters(data.alerts || []);
        
        if (alertsList) {
            if (filteredAlerts.length === 0) {
                alertsList.outerHTML = '<p class="no-alerts">No alerts match the current filters.</p>';
            } else {
                let html = '';
                filteredAlerts.forEach(alert => {
                    html += this.renderAlertItem(alert);
                });
                alertsList.innerHTML = html;
            }
        } else if (noAlertsMsg && filteredAlerts.length > 0) {
            let html = '<ul class="alerts-list">';
            filteredAlerts.forEach(alert => {
                html += this.renderAlertItem(alert);
            });
            html += '</ul>';
            noAlertsMsg.outerHTML = html;
        }
    }
};


// =============================================================================
// FILTER MANAGEMENT
// =============================================================================
/**
 * Manages alert list filtering.
 * 
 * Why: Users need to filter alerts by various criteria (triggered status, etc.)
 * to quickly find relevant alerts.
 * 
 * How: Maintains a set of active filter IDs in AlertsState. When rendering,
 * alerts are filtered through all active filter test functions.
 */
const FilterManager = {
    /**
     * Adds a filter to the active filters set and updates the DOM.
     */
    addFilter(filterId) {
        if (AlertsConfig.filters[filterId] && !AlertsState.activeFilters.has(filterId)) {
            AlertsState.activeFilters.add(filterId);
            
            // Add filter tag to DOM
            const filter = AlertsConfig.filters[filterId];
            const container = document.querySelector('#active-filters');
            const dropdown = container ? container.querySelector('.filter-dropdown') : null;
            if (dropdown) {
                const tagHtml = '<span class="filter-tag" data-filter-id="' + filterId + '">' + filter.label + 
                        '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                        '</span>';
                dropdown.insertAdjacentHTML('beforebegin', tagHtml);
                
                // Remove the option from dropdown
                const option = dropdown.querySelector('option[value="' + filterId + '"]');
                if (option) option.remove();
            }
            
            // Only update the alerts list, not the entire pane
            this.updateAlertsList();
        }
    },
    
    /**
     * Removes a filter from the active filters set.
     */
    removeFilter(filterId) {
        AlertsState.activeFilters.delete(filterId);
        
        // Re-add the option to dropdown
        const filter = AlertsConfig.filters[filterId];
        const dropdown = document.querySelector('#active-filters .filter-dropdown');
        if (dropdown && filter) {
            const option = document.createElement('option');
            option.value = filterId;
            option.textContent = filter.label;
            dropdown.appendChild(option);
        }
        
        // Only update the alerts list, not the entire pane
        this.updateAlertsList();
    },
    
    /**
     * Updates just the alerts list based on current filters.
     * Does not touch the action bar or filter tags.
     */
    async updateAlertsList() {
        const data = await AlertsAPI.fetchAlerts();
        if (!data) return;
        
        const alertsList = document.querySelector('#my-alerts .alerts-list');
        const noAlertsMsg = document.querySelector('#my-alerts .no-alerts');
        
        if (alertsList) {
            const filteredAlerts = this.applyFilters(data.alerts || []);
            if (filteredAlerts.length === 0) {
                alertsList.outerHTML = '<p class="no-alerts">No alerts match the current filters.</p>';
            } else {
                let html = '';
                filteredAlerts.forEach(alert => {
                    html += AlertsUI.renderAlertItem(alert);
                });
                alertsList.innerHTML = html;
            }
        } else if (noAlertsMsg) {
            const filteredAlerts = this.applyFilters(data.alerts || []);
            if (filteredAlerts.length > 0) {
                let html = '<ul class="alerts-list">';
                filteredAlerts.forEach(alert => {
                    html += AlertsUI.renderAlertItem(alert);
                });
                html += '</ul>';
                noAlertsMsg.outerHTML = html;
            }
        }
    },
    
    /**
     * Checks if a filter is currently active.
     */
    isActive(filterId) {
        return AlertsState.activeFilters.has(filterId);
    },
    
    /**
     * Applies all active filters to an array of alerts.
     * Returns only alerts that pass ALL active filter tests.
     */
    applyFilters(alerts) {
        if (AlertsState.activeFilters.size === 0) {
            return alerts;
        }
        
        return alerts.filter(alert => {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (filter && !filter.test(alert)) {
                    return false;
                }
            }
            return true;
        });
    }
};


// =============================================================================
// FORM MANAGEMENT
// =============================================================================
/**
 * Manages form field visibility and state for create/edit forms.
 * 
 * Why: Different alert types require different fields. This manager handles
 * showing/hiding the appropriate fields based on user selections.
 * 
 * How: Uses configuration-driven approach to map alert types to visible fields.
 */
const FormManager = {
    /**
     * Updates form field visibility based on selected alert type.
     * 
     * @param {string} formType - Either 'create' or 'edit'
     */
    handleAlertTypeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const alertType = document.querySelector(selectors.alertType).value;
        const groups = selectors.groups;
        
        // Get all form group elements
        const elements = {
            spreadScope: document.querySelector(groups.spreadScope),
            itemName: document.querySelector(groups.itemName),
            price: document.querySelector(groups.price),
            reference: document.querySelector(groups.reference),
            percentage: document.querySelector(groups.percentage),
            minPrice: document.querySelector(groups.minPrice),
            maxPrice: document.querySelector(groups.maxPrice)
        };
        
        if (alertType === AlertsConfig.alertTypes.SPREAD) {
            // Spread alerts: show spread-specific fields
            elements.spreadScope.style.display = 'block';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'none';
            elements.percentage.style.display = 'block';
            
            // Let scope change handler determine remaining visibility
            this.handleSpreadScopeChange(formType);
        } else {
            // Above/Below alerts: show threshold fields
            elements.spreadScope.style.display = 'none';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'block';
            elements.reference.style.display = 'block';
            elements.percentage.style.display = 'none';
            elements.minPrice.style.display = 'none';
            elements.maxPrice.style.display = 'none';
            
            // Reset is_all_items
            document.querySelector(selectors.isAllItems).value = 'false';
        }
    },
    
    /**
     * Updates form fields based on spread scope selection.
     * 
     * @param {string} formType - Either 'create' or 'edit'
     */
    handleSpreadScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const spreadScope = document.querySelector(selectors.spreadScope).value;
        const groups = selectors.groups;
        
        const itemNameGroup = document.querySelector(groups.itemName);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        if (spreadScope === 'all') {
            itemNameGroup.style.display = 'none';
            minPriceGroup.style.display = 'block';
            maxPriceGroup.style.display = 'block';
            isAllItemsInput.value = 'true';
        } else {
            itemNameGroup.style.display = 'block';
            minPriceGroup.style.display = 'none';
            maxPriceGroup.style.display = 'none';
            isAllItemsInput.value = 'false';
        }
    },
    
    /**
     * Collects all form values for the edit form.
     */
    getEditFormData() {
        const selectors = AlertsConfig.selectors.edit;
        
        return {
            alert_id: document.querySelector(selectors.alertId).value,
            type: document.querySelector(selectors.alertType).value,
            item_name: document.querySelector(selectors.itemName).value,
            item_id: document.querySelector(selectors.itemId).value,
            price: document.querySelector(selectors.price).value,
            reference: document.querySelector(selectors.reference).value,
            percentage: document.querySelector(selectors.percentage).value,
            is_all_items: document.querySelector(selectors.isAllItems).value === 'true',
            minimum_price: document.querySelector(selectors.minimumPrice).value,
            maximum_price: document.querySelector(selectors.maximumPrice).value,
            email_notification: document.querySelector(selectors.emailNotification).checked
        };
    },
    
    /**
     * Populates the edit form with existing alert data.
     */
    populateEditForm(alertData) {
        const selectors = AlertsConfig.selectors.edit;
        
        document.querySelector(selectors.alertId).value = alertData.id;
        document.querySelector(selectors.alertType).value = alertData.type;
        document.querySelector(selectors.itemName).value = alertData.itemName || '';
        document.querySelector(selectors.itemId).value = alertData.itemId || '';
        document.querySelector(selectors.price).value = alertData.price || '';
        document.querySelector(selectors.reference).value = alertData.reference || 'high';
        document.querySelector(selectors.percentage).value = alertData.percentage || '';
        document.querySelector(selectors.isAllItems).value = alertData.isAllItems ? 'true' : 'false';
        document.querySelector(selectors.minimumPrice).value = alertData.minPrice || '';
        document.querySelector(selectors.maximumPrice).value = alertData.maxPrice || '';
        document.querySelector(selectors.emailNotification).checked = alertData.emailNotification || false;
        
        // Set spread scope dropdown if spread alert
        if (alertData.type === AlertsConfig.alertTypes.SPREAD) {
            document.querySelector(selectors.spreadScope).value = alertData.isAllItems ? 'all' : 'specific';
        }
        
        // Update field visibility
        this.handleAlertTypeChange('edit');
    }
};


// =============================================================================
// MODAL MANAGEMENT
// =============================================================================
/**
 * Controls modal dialogs (edit modal and spread details modal).
 * 
 * Why: Modals have common behavior that should be handled consistently.
 */
const ModalManager = {
    /**
     * Opens the edit modal with alert data.
     */
    openEditModal(id, type, itemName, itemId, price, reference, percentage, isAllItems, minPrice, maxPrice, emailNotification) {
        FormManager.populateEditForm({
            id, type, itemName, itemId, price, reference, 
            percentage, isAllItems, minPrice, maxPrice, emailNotification
        });
        
        document.querySelector(AlertsConfig.selectors.edit.modal).style.display = 'flex';
    },
    
    /**
     * Closes the edit modal.
     */
    closeEditModal() {
        document.querySelector(AlertsConfig.selectors.edit.modal).style.display = 'none';
    },
    
    /**
     * Opens spread details modal with matching items.
     */
    showSpreadDetails(alertId) {
        const dataStr = AlertsState.getSpreadData(alertId);
        
        if (!dataStr) {
            console.error('No spread data found for alert', alertId);
            return;
        }
        
        const data = JSON.parse(dataStr);
        const list = document.querySelector(AlertsConfig.selectors.spreadItemsList);
        list.innerHTML = AlertsUI.renderSpreadItemsList(data);
        
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'flex';
    },
    
    /**
     * Closes the spread details modal.
     */
    closeSpreadModal() {
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'none';
    }
};


// =============================================================================
// ALERT ACTIONS
// =============================================================================
/**
 * Handles user actions on alerts (dismiss, delete, save).
 */
const AlertActions = {
    /**
     * Dismisses a triggered alert notification.
     */
    async dismiss(alertId) {
        // Animate out immediately for responsive feedback
        const notification = document.querySelector('.triggered-notification[data-alert-id="' + alertId + '"]');
        if (notification) {
            notification.classList.add('dismissing');
        }
        
        await AlertsAPI.dismissAlert(alertId);
    },
    
    /**
     * Toggles delete mode on.
     */
    toggleDeleteMode() {
        AlertsState.deleteMode = true;
        
        document.querySelectorAll('.alert-checkbox').forEach(cb => cb.style.display = 'block');
        document.querySelectorAll('.alert-item').forEach(item => item.classList.add('delete-mode'));
        
        const deleteBtn = document.querySelector('.delete-btn');
        const confirmBtn = document.querySelector('.confirm-delete-btn');
        const cancelBtn = document.querySelector('.cancel-btn');
        
        if (deleteBtn) deleteBtn.style.display = 'none';
        if (confirmBtn) confirmBtn.style.display = 'inline-block';
        if (cancelBtn) cancelBtn.style.display = 'inline-block';
    },
    
    /**
     * Cancels delete mode.
     */
    cancelDeleteMode() {
        AlertsState.deleteMode = false;
        
        document.querySelectorAll('.alert-checkbox').forEach(cb => {
            cb.style.display = 'none';
            cb.checked = false;
        });
        document.querySelectorAll('.alert-item').forEach(item => item.classList.remove('delete-mode'));
        
        const deleteBtn = document.querySelector('.delete-btn');
        const confirmBtn = document.querySelector('.confirm-delete-btn');
        const cancelBtn = document.querySelector('.cancel-btn');
        
        if (deleteBtn) deleteBtn.style.display = 'inline-block';
        if (confirmBtn) confirmBtn.style.display = 'none';
        if (cancelBtn) cancelBtn.style.display = 'none';
    },
    
    /**
     * Confirms deletion of selected alerts.
     * 
     * What: Deletes selected alerts with smooth animation
     * Why: Provides visual feedback and smooth UX when removing alerts
     * How: Animates selected items out, waits for animation, then calls API
     *      and refreshes the list
     */
    async confirmDelete() {
        const selectedItems = [];
        const selectedIds = [];
        
        document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
            const alertItem = cb.closest('.alert-item');
            if (alertItem) {
                selectedItems.push(alertItem);
                selectedIds.push(alertItem.dataset.alertId);
            }
        });
        
        if (selectedIds.length === 0) {
            alert('Please select at least one alert to delete.');
            return;
        }
        
        // Animate items out
        selectedItems.forEach(item => {
            item.classList.add('deleting');
        });
        
        // Wait for animation to complete (300ms matches CSS transition)
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Call API to delete
        const success = await AlertsAPI.deleteAlerts(selectedIds);
        if (success) {
            this.cancelDeleteMode();
            // Remove deleted alerts from the Edit Alert tab as well
            this.removeFromEditTab(selectedIds);
            // Show status notification
            this.showStatusNotification('Alert' + (selectedIds.length > 1 ? 's' : '') + ' deleted');
            await AlertsRefresh.refresh();
        }
    },
    
    /**
     * Shows a status notification at the top of the alerts pane.
     * 
     * What: Creates and displays a dismissible status message
     * Why: Provides user feedback for actions like delete
     * How: Inserts notification HTML into triggered-notifications container
     */
    showStatusNotification(message) {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;
        
        const notification = document.createElement('div');
        notification.className = 'triggered-notification status-notification';
        notification.innerHTML = message + 
            '<button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>';
        
        container.insertBefore(notification, container.firstChild);
    },
    
    /**
     * Removes alerts from the Edit Alert tab by their IDs.
     * 
     * What: Finds and removes alert items from the edit alerts list
     * Why: After deletion, alerts should not appear in Edit tab until page refresh
     * How: Parses onclick handlers to find matching alert IDs and removes elements
     */
    removeFromEditTab(alertIds) {
        const editList = document.querySelector('.edit-alerts-list');
        if (!editList) return;
        
        editList.querySelectorAll('.alert-item').forEach(item => {
            // Extract alert ID from onclick handler (first parameter)
            const onclick = item.getAttribute('onclick');
            if (onclick) {
                const match = onclick.match(/openEditModal\((\d+)/);
                if (match && alertIds.includes(match[1])) {
                    item.classList.add('deleting');
                    setTimeout(() => item.remove(), 300);
                }
            }
        });
    },
    
    /**
     * Saves changes from the edit modal.
     */
    async save() {
        const alertData = FormManager.getEditFormData();
        
        const success = await AlertsAPI.updateAlert(alertData);
        if (success) {
            ModalManager.closeEditModal();
            location.reload();
        }
    }
};


// =============================================================================
// AUTOCOMPLETE MANAGEMENT
// =============================================================================
/**
 * Manages item search autocomplete functionality.
 * 
 * Why: Both create and edit forms need autocomplete. This manager provides
 * reusable autocomplete logic for any item name input.
 */
const AutocompleteManager = {
    /**
     * Tracks the currently selected suggestion index for each dropdown.
     * Keys are dropdown element IDs, values are the selected index (-1 = none).
     */
    selectedIndex: {},
    
    /**
     * Sets up autocomplete for an input/dropdown pair with full keyboard support.
     * 
     * What: Enables item search with suggestions dropdown
     * Why: Users need to find items by name, and keyboard navigation improves UX
     * How: Listens for input changes to fetch suggestions, and keydown events
     *      for arrow key navigation, Enter to select, and Escape to close
     * 
     * @param {HTMLElement} input - The text input element
     * @param {HTMLElement} hiddenInput - Hidden input to store selected item ID
     * @param {HTMLElement} dropdown - The suggestions dropdown container
     */
    setup(input, hiddenInput, dropdown) {
        if (!input || !dropdown) return;
        
        const dropdownId = dropdown.id;
        this.selectedIndex[dropdownId] = -1;
        
        /**
         * Updates visual highlighting of the currently selected suggestion.
         * Adds 'selected' class to the active item and scrolls it into view.
         */
        const updateSelection = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                if (index === this.selectedIndex[dropdownId]) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        };
        
        /**
         * Selects the currently highlighted suggestion.
         * Sets the input value and hidden ID, then closes the dropdown.
         */
        const selectCurrentItem = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            const index = this.selectedIndex[dropdownId];
            
            if (index >= 0 && index < items.length) {
                const selectedItem = items[index];
                input.value = selectedItem.dataset.name;
                hiddenInput.value = selectedItem.dataset.id;
                dropdown.style.display = 'none';
                this.selectedIndex[dropdownId] = -1;
            }
        };
        
        /**
         * Resets the selection index when new suggestions are loaded.
         */
        const resetSelection = () => {
            this.selectedIndex[dropdownId] = -1;
        };
        
        // Handle input changes - fetch suggestions
        input.addEventListener('input', async () => {
            const query = input.value;
            
            if (query.length < AlertsConfig.timing.minSearchLength) {
                dropdown.style.display = 'none';
                resetSelection();
                return;
            }
            
            const items = await AlertsAPI.searchItems(query);
            
            if (items.length > 0) {
                dropdown.innerHTML = AlertsUI.renderSuggestions(items);
                dropdown.style.display = 'block';
                resetSelection();
            } else {
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle keyboard navigation
        input.addEventListener('keydown', (e) => {
            // Only handle keys when dropdown is visible
            if (dropdown.style.display === 'none') return;
            
            const items = dropdown.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            switch (e.key) {
                case 'ArrowDown':
                    // Move selection down, wrap to top if at bottom
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        (this.selectedIndex[dropdownId] + 1) % items.length;
                    updateSelection();
                    break;
                    
                case 'ArrowUp':
                    // Move selection up, wrap to bottom if at top
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        this.selectedIndex[dropdownId] <= 0 
                            ? items.length - 1 
                            : this.selectedIndex[dropdownId] - 1;
                    updateSelection();
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Tab moves selection up like ArrowUp
                        this.selectedIndex[dropdownId] = 
                            this.selectedIndex[dropdownId] <= 0 
                                ? items.length - 1 
                                : this.selectedIndex[dropdownId] - 1;
                    } else {
                        // Tab moves selection down like ArrowDown
                        this.selectedIndex[dropdownId] = 
                            (this.selectedIndex[dropdownId] + 1) % items.length;
                    }
                    updateSelection();
                    break;
                    
                case 'Enter':
                    // Enter selects current item
                    if (this.selectedIndex[dropdownId] >= 0) {
                        e.preventDefault();
                        selectCurrentItem();
                    }
                    break;
                    
                case 'Escape':
                    // Escape closes dropdown without selecting
                    e.preventDefault();
                    dropdown.style.display = 'none';
                    resetSelection();
                    break;
            }
        });
        
        // Handle mouse click on suggestion
        dropdown.addEventListener('click', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                input.value = e.target.dataset.name;
                hiddenInput.value = e.target.dataset.id;
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle mouse hover to update selection
        dropdown.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (item === e.target) {
                        this.selectedIndex[dropdownId] = index;
                    }
                });
                updateSelection();
            }
        });
    },
    
    /**
     * Initializes autocomplete for both forms.
     */
    init() {
        // Create form autocomplete
        const createSelectors = AlertsConfig.selectors.create;
        this.setup(
            document.querySelector(createSelectors.itemName),
            document.querySelector(createSelectors.itemId),
            document.querySelector(createSelectors.suggestions)
        );
        
        // Edit form autocomplete
        const editSelectors = AlertsConfig.selectors.edit;
        this.setup(
            document.querySelector(editSelectors.itemName),
            document.querySelector(editSelectors.itemId),
            document.querySelector(editSelectors.suggestions)
        );
    }
};


// =============================================================================
// ALERTS REFRESH
// =============================================================================
/**
 * Handles periodic refresh of alerts data.
 * 
 * Why: Alerts can be triggered by the background script at any time.
 * Periodic refresh ensures the UI stays in sync.
 */
const AlertsRefresh = {
    intervalId: null,
    
    /**
     * Fetches fresh data and updates the UI.
     */
    async refresh() {
        // Don't refresh during delete mode
        if (AlertsState.deleteMode) return;
        
        const data = await AlertsAPI.fetchAlerts();
        if (data) {
            AlertsUI.updateMyAlertsPane(data);
        }
    },
    
    /**
     * Starts the periodic refresh interval.
     */
    start() {
        this.refresh();
        this.intervalId = setInterval(
            () => this.refresh(), 
            AlertsConfig.timing.refreshInterval
        );
    },
    
    /**
     * Stops the periodic refresh.
     */
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }
};


// =============================================================================
// TAB NAVIGATION
// =============================================================================
/**
 * Manages tab switching between views.
 */
const TabManager = {
    /**
     * Switches to a specific tab.
     */
    switchTo(tabId) {
        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-tab') === tabId) {
                btn.classList.add('active');
            }
        });
        
        document.querySelectorAll(AlertsConfig.selectors.tabPanes).forEach(pane => {
            pane.style.display = 'none';
        });
        document.getElementById(tabId).style.display = 'block';
    },
    
    /**
     * Initializes tab click handlers.
     */
    init() {
        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(button => {
            button.addEventListener('click', function() {
                const tabId = button.getAttribute('data-tab');
                TabManager.switchTo(tabId);
            });
        });
    }
};


// =============================================================================
// EVENT MANAGEMENT
// =============================================================================
/**
 * Sets up all event listeners for the alerts system.
 */
const EventManager = {
    /**
     * Sets up modal event listeners.
     */
    setupModalEvents() {
        const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
        
        // Close spread modal on backdrop click
        if (spreadModal) {
            spreadModal.addEventListener('click', function(e) {
                if (e.target.id === 'spread-modal') {
                    ModalManager.closeSpreadModal();
                }
            });
        }
        
        // Close modals on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
                if (spreadModal && spreadModal.style.display === 'flex') {
                    ModalManager.closeSpreadModal();
                }
            }
        });
    },
    
    /**
     * Sets up autocomplete dropdown close on outside click.
     */
    setupAutocompleteEvents() {
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.form-group')) {
                const createSuggestions = document.querySelector(AlertsConfig.selectors.create.suggestions);
                const editSuggestions = document.querySelector(AlertsConfig.selectors.edit.suggestions);
                
                if (createSuggestions) createSuggestions.style.display = 'none';
                if (editSuggestions) editSuggestions.style.display = 'none';
            }
        });
    },
    
    /**
     * Initializes all event listeners.
     */
    init() {
        this.setupModalEvents();
        this.setupAutocompleteEvents();
    }
};


// =============================================================================
// GLOBAL FUNCTION EXPORTS
// =============================================================================
/**
 * These functions are exposed globally for use in onclick handlers in HTML.
 */

// Form handlers
function handleAlertTypeChange() {
    FormManager.handleAlertTypeChange('create');
}

function handleSpreadScopeChange() {
    FormManager.handleSpreadScopeChange('create');
}

function handleEditAlertTypeChange() {
    FormManager.handleAlertTypeChange('edit');
}

function handleEditSpreadScopeChange() {
    FormManager.handleSpreadScopeChange('edit');
}

// Modal handlers
function openEditModal(id, type, itemName, itemId, price, reference, percentage, isAllItems, minPrice, maxPrice, emailNotification) {
    ModalManager.openEditModal(id, type, itemName, itemId, price, reference, percentage, isAllItems, minPrice, maxPrice, emailNotification);
}

function closeEditModal() {
    ModalManager.closeEditModal();
}

function closeSpreadModal() {
    ModalManager.closeSpreadModal();
}

function showSpreadDetails(alertId) {
    ModalManager.showSpreadDetails(alertId);
}

// Alert action handlers
function dismissAlert(alertId) {
    AlertActions.dismiss(alertId);
}

function dismissStatusNotification(button) {
    const notification = button.closest('.triggered-notification');
    if (notification) {
        notification.classList.add('dismissing');
        setTimeout(() => notification.remove(), 300);
    }
}

function addFilter(filterId) {
    if (filterId) {
        FilterManager.addFilter(filterId);
    }
}

function removeFilter(filterId) {
    // Animate the tag out first
    const tag = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
    if (tag) {
        tag.classList.add('removing');
        setTimeout(() => {
            FilterManager.removeFilter(filterId);
        }, 300);
    } else {
        FilterManager.removeFilter(filterId);
    }
}

function toggleDeleteMode() {
    AlertActions.toggleDeleteMode();
}

function cancelDeleteMode() {
    AlertActions.cancelDeleteMode();
}

function confirmDelete() {
    AlertActions.confirmDelete();
}

function saveAlert() {
    AlertActions.save();
}


// =============================================================================
// INITIALIZATION
// =============================================================================
/**
 * Initialize the alerts system when the script loads.
 */
(function init() {
    TabManager.init();
    AutocompleteManager.init();
    EventManager.init();
    AlertsRefresh.start();
})();
</script>

{% endblock %}
