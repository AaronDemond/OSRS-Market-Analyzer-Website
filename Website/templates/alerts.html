{% extends 'base.html' %}

{% block title %}Alerts - GE Tools{% endblock %}

{% block content %}
<div class="page-header">
    <div class="page-header-icon">
        <svg fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"/>
        </svg>
    </div>
    <div class="page-header-text">
        <h1>Alerts</h1>
        <p>Set up price alerts and get notified when items hit your targets. Click on individual alerts to get more details.</p>
    </div>
</div>

<div class="alert-tabs">
    <button class="tab-btn active" data-tab="my-alerts">My Alerts</button>
    <button class="tab-btn" data-tab="create-alert">Create Alert</button>
</div>

<div class="tab-content">
    <div id="my-alerts" class="tab-pane active">
        <div id="triggered-notifications">
            {% for message in messages %}
                <div class="triggered-notification status-notification">
                    {{ message }}
                    <button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>
                </div>
            {% endfor %}
            {% for alert in triggered_alerts %}
                <div class="triggered-notification" data-alert-id="{{ alert.id }}">
                    {{ alert.triggered_text }}
                </div>
            {% endfor %}
        </div>
        {% if has_alerts %}
        <div class="alert-actions-wrapper">
            <div class="alert-actions">
                <div class="alert-actions-left">
                    <div class="custom-dropdown-wrapper">
                        <button type="button" class="btn-dropdown btn-actions" id="actionsDropdownBtn">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                            </svg>
                            <span class="btn-text">Actions</span>
                        </button>
                        <div class="custom-dropdown-menu" id="actionsDropdownMenu">
                            <div class="custom-dropdown-header">Actions</div>
                            <div class="custom-dropdown-item" data-action="delete">
                                <span>Delete</span>
                            </div>
                            <div class="custom-dropdown-item" data-action="group">
                                <span>Add to Group</span>
                            </div>
                        </div>
                    </div>
                    <div class="alert-search-wrapper">
                        <svg class="alert-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                        </svg>
                        <input type="text" class="alert-search-input" id="alertSearchInput" placeholder="Search alerts..." autocomplete="off">
                        <button type="button" class="alert-search-clear" id="alertSearchClear" title="Clear search">×</button>
                    </div>
                </div>
                <div class="alert-actions-right" id="active-filters">
                    <div class="alert-actions-controls">
                        <div class="sort-controls">
                            <div class="sort-indicator-wrapper" id="sortIndicatorWrapper">
                                <div class="sort-indicator" id="sortIndicator">
                                    <span class="sort-indicator-label">Sorted by:</span>
                                    <span class="sort-indicator-value" id="sortIndicatorValue"></span>
                                    <span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">↓</span>
                                    <span class="sort-indicator-clear" id="sortIndicatorClear" title="Clear sort">×</span>
                                </div>
                            </div>
                            <div class="custom-dropdown-wrapper">
                                <button type="button" class="btn-dropdown btn-sort" id="sortDropdownBtn">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
                                    </svg>
                                    <span class="btn-text">Sort</span>
                                </button>
                                <div class="custom-dropdown-menu" id="sortDropdownMenu">
                                    <div class="custom-dropdown-header">Sort by</div>
                                    <div class="custom-dropdown-item" data-sort="alphabetically">
                                        <span>Alphabetically</span>
                                        <span class="sort-check">✓</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="lastTriggered">
                                        <span>Last Triggered Time</span>
                                        <span class="sort-check">✓</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="alertType">
                                        <span>Alert Type</span>
                                        <span class="sort-check">✓</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="thresholdDistance">
                                        <span>Threshold Distance</span>
                                        <span class="sort-check">✓</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="createdDate">
                                        <span>Created Date</span>
                                        <span class="sort-check">✓</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="custom-dropdown-wrapper">
                            <button type="button" class="btn-dropdown btn-filter" id="filterDropdownBtn">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>
                                </svg>
                                <span class="btn-text">Filters</span>
                                <span class="filter-badge" id="filterBadge" style="display: none;">0</span>
                            </button>
                            <div class="custom-dropdown-menu" id="filterDropdownMenu">
                                <div class="custom-dropdown-header">Filter by</div>
                                <div class="custom-dropdown-item" data-filter="triggered">
                                    <span>Triggered</span>
                                    <span class="filter-check">✓</span>
                                    <span class="filter-clear" title="Clear filter">×</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="notTriggered">
                                    <span>Not Triggered</span>
                                    <span class="filter-check">✓</span>
                                    <span class="filter-clear" title="Clear filter">×</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="priceRange">
                                    <span>Price</span>
                                    <span class="filter-check">✓</span>
                                    <span class="filter-clear" title="Clear filter">×</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="myGroups">
                                    <span>My Groups</span>
                                    <span class="filter-check">✓</span>
                                    <span class="filter-clear" title="Clear filter">×</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Mobile sort indicator row (shown on smaller screens) -->
            <div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">
                <div class="sort-indicator" id="sortIndicatorMobile">
                    <span class="sort-indicator-label">Sorted by:</span>
                    <span class="sort-indicator-value" id="sortIndicatorValueMobile"></span>
                    <span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">↓</span>
                    <span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">×</span>
                </div>
            </div>
            <div class="alert-indicators">
                <div class="filter-tags"></div>
                <div class="sort-tag-holder"></div>
            </div>
        </div>
        <div id="alerts-list-container">
            <div class="loading-container">
                <div class="loading-spinner"></div>
                <span class="loading-text">Loading</span>
            </div>
        </div>
        {% elif not triggered_alerts %}
            <p class="no-alerts">No active alerts. Create one to get started!</p>
        {% endif %}
    </div>
    <div id="create-alert" class="tab-pane" style="display: none;">
        <form method="POST" action="{% url 'create_alert' %}" class="create-alert-form">
            {% csrf_token %}
            
            <div class="form-group">
                <label for="alert-type">Alert Type</label>
                <select name="type" id="alert-type" required onchange="handleAlertTypeChange()">
                    <option value="above" selected>Above Threshold</option>
                    <option value="below">Below Threshold</option>
                    <option value="spread">Spread</option>
                    <option value="spike">Spike</option>
                    <option value="sustained">Sustained Move</option>
                </select>
                <button type="button" class="alert-help-btn" onclick="openAlertHelpModal()">
                    <svg viewBox="0 0 20 20" fill="currentColor" width="16" height="16">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                    </svg>
                    How do alerts work?
                </button>
            </div>
            <div class="form-group">
                <label for="alert-group">Group</label>
                <select name="group_id" id="alert-group">
                    <option value="">No Group</option>
                </select>

                <small class="form-hint">Group your alerts. You can always add a group later</small>
            </div>

            <!-- Number of items (shown for spike only) -->
            <div class="form-group" id="number-items-group" style="display: none;">
                <label for="number-of-items">Number of Items</label>
                <select name="number_of_items" id="number-of-items" onchange="handleSpikeScopeChange()">
                    <option value="one" selected>One</option>
                    <option value="all">All</option>
                </select>

                <small class="form-hint">Choose to track a single item or all items</small>
            </div>
            
            <!-- Spread-specific fields -->
            <div class="form-group" id="spread-scope-group" style="display: none;">
                <label for="spread-scope">Apply To</label>
                <select name="spread_scope" id="spread-scope" onchange="handleSpreadScopeChange()">
                    <option value="all">All Items</option>
                    <option value="specific">Specific Item</option>
                </select>

                <small class="form-hint">Choose to track a single item or all items</small>
            </div>
            
            <!-- Item Name -->
            <div class="form-group" id="item-name-group">
                <label for="item-name">Item Name</label>
                <input type="text" name="item_name" id="item-name" autocomplete="off">
                <input type="hidden" name="item_id" id="item-id">
                <input type="hidden" name="is_all_items" id="is-all-items" value="false">
                <div id="item-suggestions" class="suggestions-dropdown"></div>
                <small class="form-hint">Item name you wish to track</small>
            </div>
            
            <!-- Price Threshold -->
            <div class="form-group" id="price-group">
                <label for="price">Price Threshold</label>
                <input type="number" name="price" id="price">
                <small class="form-hint">Target price</small>
            </div>
            
            <!-- Reference Price -->
            <div class="form-group" id="reference-group">
                <label for="reference">Reference Price</label>
                <select name="reference" id="reference">
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                </select>
                <small class="form-hint">Price your alert will youse to make calculations</small>
            </div>
            
            <!-- Percentage field (shown for spread or spike) -->
            <div class="form-group" id="percentage-group" style="display: none;">
                <label for="percentage">Percentage (%)</label>
                <input type="number" name="percentage" id="percentage" step="0.001" min="0.001">
                <small class="form-hint">Target percentage your alert must hit</small>
            </div>

            <!-- Time frame field (shown for spike only) -->
            <div class="form-group" id="time-frame-group" style="display: none;">
                <label for="time-frame">Time Frame (minutes)</label>
                <input type="number" name="time_frame" id="time-frame" min="1" step="1" placeholder="e.g. 10">
                <small class="form-hint">Time frame your alert must trigger within.</small>
            </div>
            
            <!-- Direction field (shown for spike only) -->
            <div class="form-group" id="direction-group" style="display: none;">
                <label for="direction">Direction</label>
                <select name="direction" id="direction">
                    <option value="both" selected>Both</option>
                    <option value="up">Up</option>
                    <option value="down">Down</option>
                </select>

                <small class="form-hint">Direction your alert will track</small>
            </div>
            
            <!-- Sustained Move scope selector -->
            <div class="form-group" id="sustained-scope-group" style="display: none;">
                <label for="sustained-scope">Apply To</label>
                <select name="sustained_scope" id="sustained-scope" onchange="handleSustainedScopeChange()">
                    <option value="specific" selected>Specific Item(s)</option>
                    <option value="all">All Items</option>
                </select>
                <small class="form-hint">Choose to track a single item or all items</small>
            </div>
            
            <!-- Multi-item selector for sustained move -->
            <div class="form-group" id="sustained-items-group" style="display: none;">
                <label for="sustained-item-input">Items</label>
                <div class="multi-item-selector">
                    <div class="selected-items-container" id="selected-items-container"></div>
                    <input type="text" id="sustained-item-input" placeholder="Type to search items..." autocomplete="off">
                    <input type="hidden" name="sustained_item_ids" id="sustained-item-ids" value="">
                    <div id="sustained-item-suggestions" class="suggestions-dropdown"></div>
                </div>
                <small class="form-hint">Add one or more items to monitor</small>
            </div>
            
            <!-- Min/Max price fields -->
            <div class="form-group" id="min-price-group" style="display: none;">
                <label for="minimum-price">Minimum Price</label>
                <input type="number" name="minimum_price" id="minimum-price" min="0">
            </div>
            <div class="form-group" id="max-price-group" style="display: none;">
                <label for="maximum-price">Maximum Price</label>
                <input type="number" name="maximum_price" id="maximum-price" min="0">
            </div>
            
            <!-- Sustained Move specific fields -->
            <div class="form-group" id="min-consecutive-moves-group" style="display: none;">
                <label for="min-consecutive-moves">Min Consecutive Moves</label>
                <input type="number" name="min_consecutive_moves" id="min-consecutive-moves" min="2" step="1" placeholder="e.g. 5">
                <small class="form-hint">Number of price changes in same direction</small>
            </div>
            <div class="form-group" id="min-move-percentage-group" style="display: none;">
                <label for="min-move-percentage">Min Move %</label>
                <input type="number" name="min_move_percentage" id="min-move-percentage" min="0.01" step="0.01" placeholder="e.g. 0.5">
                <small class="form-hint">Min % change to count as move</small>
            </div>
            <div class="form-group" id="min-volume-group" style="display: none;">
                <label for="min-volume">Min Volume</label>
                <input type="number" name="min_volume" id="min-volume" min="0" step="1" placeholder="e.g. 10000">
                <small class="form-hint">Min trading volume</small>
            </div>
            <div class="form-group" id="volatility-buffer-group" style="display: none;">
                <label for="volatility-buffer-size">Volatility Buffer (N)</label>
                <input type="number" name="volatility_buffer_size" id="volatility-buffer-size" min="5" step="1" placeholder="e.g. 20">
                <small class="form-hint">Rolling buffer size for avg volatility</small>
            </div>
            <div class="form-group" id="volatility-multiplier-group" style="display: none;">
                <label for="volatility-multiplier">Volatility Multiplier (K)</label>
                <input type="number" name="volatility_multiplier" id="volatility-multiplier" min="0.1" step="0.1" placeholder="e.g. 1.5">
                <small class="form-hint">Streak must move ≥ K × avg volatility</small>
            </div>
            
            <!-- Market Pressure Filter (sustained only) -->
            <div class="form-group" id="pressure-strength-group" style="display: none;">
                <label for="min-pressure-strength">Market Pressure</label>
                <select name="min_pressure_strength" id="min-pressure-strength">
                    <option value="">No Pressure Filter</option>
                    <option value="weak">Weak+ (any time delta)</option>
                    <option value="moderate">Moderate+ (&lt;5min)</option>
                    <option value="strong">Strong (&lt;1min)</option>
                </select>
                <small class="form-hint">BUY=up, SELL=down direction match</small>
            </div>
            <div class="form-group" id="pressure-spread-group" style="display: none;">
                <label for="min-pressure-spread">Min Spread % for Pressure</label>
                <input type="number" name="min_pressure_spread_pct" id="min-pressure-spread" min="0.01" step="0.01" placeholder="e.g. 0.2">
                <small class="form-hint">Minimum high-low spread % to confirm pressure</small>
            </div>
            
            <div class="form-group checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" name="email_notification" id="email-notification">
                    Receive SMS Notification
                </label>
            </div>
            
            <button type="submit" class="btn-create-alert">Create Alert</button>
        </form>
    </div>
</div>

<!-- Spread Details Modal -->
<div id="spread-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spread Alert Details</h2>
            <button class="modal-close" onclick="closeSpreadModal()">&times;</button>
        </div>
        <div id="spread-modal-body">
            <ul id="spread-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpreadModal()">Close</button>
        </div>
    </div>
</div>

<!-- Spike Details Modal -->
<div id="spike-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spike Alert Details</h2>
            <button class="modal-close" onclick="closeSpikeModal()">&times;</button>
        </div>
        <div id="spike-modal-body">
            <ul id="spike-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpikeModal()">Close</button>
        </div>
    </div>
</div>

<!-- Group Alerts Modal -->
<div id="group-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Organize Alerts</h2>
            <button class="modal-close" onclick="GroupManager.close()">&times;</button>
        </div>
        <div class="form-group">
            <label>Existing Groups</label>
            <div id="group-list" class="group-list"></div>
        </div>
        <div class="form-group">
            <label for="new-group-input">Add New Groups</label>
            <input type="text" id="new-group-input" placeholder="Comma-separated, e.g. Bossing, Supplies">
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="GroupManager.save()">Save</button>
            <button type="button" class="btn-cancel" onclick="GroupManager.deleteSelectedGroups()" style="margin: 0 auto;">Delete Group(s)</button>
            <button type="button" class="btn-cancel" onclick="GroupManager.close()">Cancel</button>
        </div>
    </div>
</div>

<!-- Groups Filter Modal -->
<div id="groups-filter-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Filter by Groups</h2>
            <button class="modal-close" onclick="closeGroupsFilterModal()">&times;</button>
        </div>
        <div class="form-group">
            <label>Select Groups to Display</label>
            <div id="groups-filter-list" class="group-list pill-padding"></div>
            <p id="no-groups-message" class="no-alerts" style="display: none;">No groups available. Create groups by organizing your alerts first.</p>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="applyGroupsFilter()">Apply Filter</button>
            <button type="button" class="btn-cancel" onclick="closeGroupsFilterModal()">Cancel</button>
        </div>
    </div>
</div>

<!-- Price Filter Modal -->
<div id="price-filter-modal" class="modal filter-modal-styled" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Filter by Price</h2>
            <button class="modal-close" onclick="closePriceFilterModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="filter-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
            </div>
            <p class="filter-description">Show alerts with current price in a specific range.</p>
            <div class="form-group">
                <label for="price-filter-min">Minimum Price</label>
                <input type="number" id="price-filter-min" placeholder="No minimum">
            </div>
            <div class="form-group">
                <label for="price-filter-max">Maximum Price</label>
                <input type="number" id="price-filter-max" placeholder="No maximum">
            </div>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-clear" onclick="clearPriceFilter()">Clear</button>
            <button type="button" class="btn-save" onclick="applyPriceFilter()">Apply Filter</button>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-confirm-modal" class="modal delete-confirm-modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Confirm Delete</h2>
            <button class="modal-close" onclick="closeDeleteConfirmModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="delete-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
            </div>
            <p id="delete-confirm-message">Are you sure you want to delete the selected alerts?</p>
            <p class="delete-warning">This action cannot be undone.</p>
        </div>
        <div class="modal-footer">
            <button type="button" class="btn-cancel" onclick="closeDeleteConfirmModal()">Cancel</button>
            <button type="button" class="btn-confirm-delete" onclick="executeDelete()">Delete</button>
        </div>
    </div>
</div>
<style>
    :root {
        /* Neutrals */
        --bg: #F8F9FA;
        --surface: #FFFFFF;
        --surface-2: #F5F6F8;
        --border: #E5E7EB;
        --text: #374151;
        --text-muted: #6B7280;
        --muted: #6B7280;
        /* Brand - muted */
        --primary: #6366F1;
        --primary-hover: #5558E3;
        /* Semantics - muted */
        --success: #22C55E;
        --success-muted: #4ADE80;
        --danger: #EF4444;
        --danger-muted: #F87171;
        --warning: #F59E0B;
        --info: #3B82F6;
        /* Hover */
        --hover-orange: #F97316;
        --hover-orange-light: #FDBA74;
    }

    /* Alert Help Button */
    .alert-help-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
        padding: 8px 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    
    .alert-help-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .alert-help-btn svg {
        flex-shrink: 0;
    }

    /* Alert Help Modal */
    .alert-help-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        animation: fadeIn 0.2s ease;
    }
    
    .alert-help-modal-overlay.open {
        display: flex;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .alert-help-modal {
        background: white;
        border-radius: 16px;
        max-width: 800px;
        width: 100%;
        max-height: 85vh;
        overflow: hidden;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        animation: slideUp 0.3s ease;
    }
    
    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .alert-help-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    .alert-help-modal-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .alert-help-modal-close {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        font-size: 24px;
        line-height: 1;
    }
    
    .alert-help-modal-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }
    
    .alert-help-modal-body {
        padding: 0;
        overflow-y: auto;
        max-height: calc(85vh - 80px);
    }
    
    .alert-help-tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
        background: var(--surface-2);
        overflow-x: auto;
    }
    
    .alert-help-tab {
        padding: 14px 20px;
        background: none;
        border: none;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        border-bottom: 3px solid transparent;
        margin-bottom: -1px;
    }
    
    .alert-help-tab:hover {
        color: var(--text);
        background: rgba(0, 0, 0, 0.03);
    }
    
    .alert-help-tab.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        background: white;
    }
    
    .alert-help-content {
        padding: 24px;
    }
    
    .alert-help-section {
        display: none;
    }
    
    .alert-help-section.active {
        display: block;
    }
    
    .alert-help-section h3 {
        font-size: 22px;
        font-weight: 600;
        color: var(--text);
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .alert-help-section h3 .alert-type-badge {
        font-size: 12px;
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: 500;
    }
    
    .alert-type-badge.above { background: #DCFCE7; color: #166534; }
    .alert-type-badge.below { background: #FEE2E2; color: #991B1B; }
    .alert-type-badge.spread { background: #E0E7FF; color: #3730A3; }
    .alert-type-badge.spike { background: #FEF3C7; color: #92400E; }
    .alert-type-badge.sustained { background: #F3E8FF; color: #6B21A8; }
    
    .alert-help-section .subtitle {
        font-size: 15px;
        color: var(--text-muted);
        margin-bottom: 20px;
        line-height: 1.6;
    }
    
    .alert-help-card {
        background: var(--surface-2);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .alert-help-card h4 {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
        margin: 0 0 12px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .alert-help-card h4 svg {
        color: var(--primary);
    }
    
    .alert-help-card p {
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.7;
        margin: 0;
    }
    
    .alert-help-card ul {
        margin: 12px 0 0 0;
        padding-left: 20px;
    }
    
    .alert-help-card li {
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.8;
    }
    
    .alert-help-card li strong {
        color: var(--text);
    }
    
    .recommended-values {
        background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        border: 1px solid #86efac;
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px;
    }
    
    .recommended-values h4 {
        font-size: 15px;
        font-weight: 600;
        color: #166534;
        margin: 0 0 12px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .recommended-values .value-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
    }
    
    .recommended-value {
        background: white;
        border-radius: 8px;
        padding: 12px 16px;
        border: 1px solid #bbf7d0;
    }
    
    .recommended-value .label {
        font-size: 12px;
        color: #166534;
        font-weight: 500;
        margin-bottom: 4px;
    }
    
    .recommended-value .value {
        font-size: 16px;
        font-weight: 600;
        color: #14532d;
    }
    
    .example-scenario {
        background: #fffbeb;
        border: 1px solid #fde68a;
        border-radius: 12px;
        padding: 20px;
        margin-top: 16px;
    }
    
    .example-scenario h4 {
        font-size: 14px;
        font-weight: 600;
        color: #92400e;
        margin: 0 0 10px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .example-scenario p {
        font-size: 14px;
        color: #78350f;
        line-height: 1.7;
        margin: 0;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 30px;
    }
    
    .page-header-icon {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
    }
    
    .page-header-icon svg {
        width: 24px;
        height: 24px;
        color: white;
    }
    
    .page-header-text h1 {
        font-size: 1.75rem;
        font-weight: 700;
        color: var(--text);
        margin: 0 0 2px 0;
        letter-spacing: -0.02em;
    }
    
    .page-header-text p {
        color: var(--muted);
        margin: 0;
        font-size: 0.95rem;
    }

    /* Tabs styling */
    .alert-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 24px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 0;
    }
    
    .tab-btn {
        padding: 12px 24px;
        border: none;
        background: transparent;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        color: var(--muted);
        border-bottom: 3px solid transparent;
        margin-bottom: -1px;
        transition: all 0.2s ease;
        border-radius: 8px 8px 0 0;
    }
    
    .tab-btn:hover {
        color: var(--text);
        background: var(--surface-2);
    }
    
    .tab-btn.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        background: transparent;
    }
    
    .tab-content {
        padding: 0;
    }

    /* Alert items */
    .alerts-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    
    .alert-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        margin-bottom: 10px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-left: 4px solid var(--primary);
        border-radius: 10px;
        transition: all 0.2s ease;
        max-height: 200px;
        overflow: hidden;
    }
    
    .alert-item:hover {
        transform: translateX(4px);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        border-left-color: var(--primary-hover);
    }
    
    .alert-item.deleting {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    
    .alert-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
    }
    
    .alert-text {
        font-size: 0.95rem;
        color: var(--text);
    }
    
    .alert-sort-info {
        font-size: 0.8rem;
        color: var(--muted);
        font-style: italic;
    }
    
    .alert-status {
        font-weight: 600;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        letter-spacing: 0.3px;
        flex-shrink: 0;
        margin-right: 8px;
    }
    
    .alert-status-active {
        color: #16A34A;
        background: #DCFCE7;
    }
    
    .alert-status-inactive {
        color: #DC2626;
        background: #FEE2E2;
    }
    
    .alert-triggered {
        font-weight: 600;
        color: #7C3AED;
        background: #EDE9FE;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        letter-spacing: 0.3px;
        flex-shrink: 0;
    }
    
    .alert-icon {
        width: 32px;
        height: 32px;
        object-fit: contain;
        flex-shrink: 0;
    }
    
    .alert-icon-placeholder {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        flex-shrink: 0;
    }
    
    .alert-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
        margin-right: 4px;
    }
    
    .no-alerts {
        color: var(--muted);
        font-style: italic;
        padding: 40px 20px;
        text-align: center;
        background: var(--surface);
        border: 1px dashed var(--border);
        border-radius: 12px;
    }

    /* Loading Indicator */
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        gap: 16px;
    }
    
    .loading-spinner {
        width: 48px;
        height: 48px;
        border: 4px solid var(--border);
        border-top: 4px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        font-size: 1rem;
        font-weight: 500;
        color: var(--muted);
    }

    /* Alert groups */
    .alert-group {
        margin-bottom: 25px;
    }
    
    .alert-group-header {
        font-size: 1rem;
        font-weight: 600;
        color: var(--primary);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 2px solid var(--hover-orange);
    }

    /* Actions wrapper */
    .alert-actions-wrapper {
        margin-bottom: 4px;
    }
    
    .alert-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: nowrap;
    }
    
    .alert-actions-left {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-shrink: 0;
    }
    
    /* Search Bar */
    .alert-search-wrapper {
        position: relative;
        display: flex;
        align-items: center;
    }
    
    .alert-search-icon {
        position: absolute;
        left: 10px;
        width: 16px;
        height: 16px;
        color: var(--text-muted);
        pointer-events: none;
    }
    
    .alert-search-input {
        padding: 8px 32px 8px 32px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 14px;
        width: 300px;
        transition: all 0.15s;
    }
    
    .alert-search-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .alert-search-input::placeholder {
        color: var(--text-muted);
    }
    
    .alert-search-clear {
        position: absolute;
        right: 8px;
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        font-size: 16px;
        padding: 2px 6px;
        border-radius: 4px;
        display: none;
    }
    
    .alert-search-clear:hover {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
    }
    
    .alert-search-wrapper.has-value .alert-search-clear {
        display: block;
    }
    
    .alert-actions-right {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .alert-actions-controls {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* Custom Dropdowns */
    .custom-dropdown-wrapper {
        position: relative;
    }
    
    .btn-dropdown {
        padding: 8px 14px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
    }
    
    .btn-dropdown:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }
    
    .btn-dropdown.has-active {
        background: rgba(99, 102, 241, 0.1);
        border-color: var(--primary);
        color: var(--primary);
    }
    
    .btn-dropdown svg {
        width: 16px;
        height: 16px;
    }
    
    .filter-badge {
        background: var(--primary);
        color: white;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 4px;
    }
    
    .custom-dropdown-menu {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 6px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        min-width: 180px;
        z-index: 1000;
        display: none;
        padding: 6px;
    }
    
    /* Right-align sort and filter dropdowns on desktop */
    #sortDropdownMenu,
    #filterDropdownMenu {
        left: auto;
        right: 0;
    }
    
    .custom-dropdown-menu.show {
        display: block;
    }
    
    .custom-dropdown-header {
        padding: 8px 10px 6px;
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 6px;
    }
    
    .custom-dropdown-item {
        padding: 10px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.15s;
        border-radius: 6px;
        margin: 2px 0;
        background: var(--surface-2);
        border: 1px solid transparent;
    }
    
    .custom-dropdown-item:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.3);
    }
    
    .custom-dropdown-item.active {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
        color: var(--primary);
    }
    
    .custom-dropdown-item.active:hover {
        background: rgba(99, 102, 241, 0.25);
    }
    
    .custom-dropdown-item .filter-check,
    .custom-dropdown-item .sort-check {
        color: var(--primary);
        display: none;
        font-weight: 600;
    }
    
    .custom-dropdown-item.active .sort-check {
        display: inline;
    }
    
    .custom-dropdown-item .filter-clear {
        display: none;
        color: var(--danger);
        font-size: 18px;
        font-weight: 600;
        line-height: 1;
        padding: 0 2px;
        border-radius: 4px;
        transition: all 0.15s;
    }
    
    .custom-dropdown-item.active .filter-clear {
        display: inline;
    }
    
    .custom-dropdown-item .filter-clear:hover {
        background: rgba(239, 68, 68, 0.15);
    }

    /* Sort controls */
    .sort-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    /* Sort indicator - styled like flips page */
    .sort-indicator-wrapper {
        position: relative;
    }
    
    .sort-indicator {


        margin-top:7px;
        display: none;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 13px;
        color: var(--text);
        transition: all 0.3s ease;
    }
    
    .sort-indicator.active {
        display: inline-flex;
    }
    
    .sort-indicator-label {
        color: var(--text-muted);
    }
    
    .sort-indicator-value {
        font-weight: 500;
        color: var(--primary);
    }
    
    .sort-indicator-arrow {
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
        transition: all 0.15s;
        font-size: 14px;
        user-select: none;
        background: var(--surface-2);
        border: 1px solid var(--border);
        margin-left: 4px;
    }
    
    .sort-indicator-arrow:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.4);
    }
    
    .sort-indicator-clear {
        cursor: pointer;
        color: var(--danger);
        font-size: 16px;
        font-weight: 600;
        line-height: 1;
        padding: 0 4px;
        border-radius: 4px;
        transition: all 0.15s;
        margin-left: 4px;
    }
    
    .sort-indicator-clear:hover {
        background: rgba(239, 68, 68, 0.15);
    }
    
    /* Mobile sort indicator row - hidden by default, shown at smaller breakpoints */
    .sort-indicator-mobile-row {
        display: none;
    }
    
    .sort-indicator-mobile-row .sort-indicator {
        display: none;
    }
    
    .sort-indicator-mobile-row .sort-indicator.active {
        display: inline-flex;
    }

    /* Filter and sort tags */
    .alert-indicators {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        flex-wrap: wrap-reverse;
        gap: 8px;
        margin-top: 4px;
    }
    
    .filter-tags {
        display: contents;
    }
    
    .sort-tag-holder {
        display: contents;
    }
    
    .filter-tag {
        display: inline-flex;
        align-items: center;
        background: var(--primary);
        color: white;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        animation: filterTagIn 0.3s ease forwards;
        max-width: 200px;
        overflow: hidden;
    }
    
    .filter-tag.removing {
        animation: filterTagOut 0.3s ease forwards;
    }
    
    @keyframes filterTagIn {
        from {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
        }
        to {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 12px;
        }
    }
    
    @keyframes filterTagOut {
        from {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 12px;
        }
        to {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
        }
    }
    
    .filter-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 6px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.8;
        padding: 0;
    }
    
    .filter-tag-remove:hover {
        opacity: 1;
    }
    
    .sort-tag {
        background: var(--hover-orange);
        color: white;
        padding: 6px 12px;
        border-radius: 20px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
        font-size: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }
    
    .sort-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 4px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.85;
        padding: 0;
    }
    
    .sort-tag-remove:hover {
        opacity: 1;
    }

    /* Delete Confirmation Modal */
    .delete-confirm-modal .modal-content {
        max-width: 400px;
        border-radius: 12px;
        overflow: hidden;
    }
    
    .delete-confirm-modal .modal-header {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        color: white;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .delete-confirm-modal .modal-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
    }
    
    .delete-confirm-modal .modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        opacity: 0.8;
        line-height: 1;
    }
    
    .delete-confirm-modal .modal-close:hover {
        opacity: 1;
    }
    
    .delete-confirm-modal .modal-body {
        padding: 24px;
        text-align: center;
    }
    
    .delete-confirm-modal .delete-icon {
        width: 64px;
        height: 64px;
        background: #FEE2E2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
    }
    
    .delete-confirm-modal .delete-icon svg {
        width: 32px;
        height: 32px;
        color: #DC2626;
    }

    .sort-indicator {
        margin-top:0px;
    }
    
    .delete-confirm-modal .modal-body p {
        color: var(--text);
        margin: 0 0 8px 0;
    }
    
    .delete-confirm-modal .delete-warning {
        color: var(--muted);
        font-size: 13px;
        margin-top: 8px;
    }
    
    .delete-confirm-modal .modal-footer {
        padding: 16px 24px;
        display: flex;
        justify-content: center;
        gap: 12px;
        border-top: 1px solid var(--border);
    }
    
    .delete-confirm-modal .btn-cancel {
        background: var(--surface-2);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 10px 24px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
    }
    
    .delete-confirm-modal .btn-cancel:hover {
        background: var(--surface);
        border-color: var(--muted);
    }
    
    .delete-confirm-modal .btn-confirm-delete {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        border: none;
        color: white;
        padding: 10px 24px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
    }
    
    .delete-confirm-modal .btn-confirm-delete:hover {
        background: linear-gradient(135deg, #B91C1C 0%, #991B1B 100%);
        transform: translateY(-1px);
    }

    /* Success notifications */
    .triggered-notification {
        background: linear-gradient(135deg, #22C55E 0%, #16A34A 100%);
        color: white;
        padding: 14px 40px 14px 16px;
        border-radius: 10px;
        margin-bottom: 12px;
        position: relative;
        font-weight: 500;
        transition: all 0.3s ease;
        max-height: 100px;
        overflow: hidden;
    }
    
    .triggered-notification.dismissing {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    
    .triggered-notification .dismiss-btn {
        position: absolute;
        top: 50%;
        right: 12px;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        opacity: 0.8;
    }
    
    .triggered-notification .dismiss-btn:hover {
        opacity: 1;
    }
    
    /* Error notification variant (red) */
    .triggered-notification.error-notification {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
    }

    /* Create alert form */
    .create-alert-form {
        max-width: 100%;
        background: var(--surface);
        padding: 24px;
        border-radius: 12px;
        border: 1px solid var(--border);
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: flex-start;
    }
    
    .create-alert-form > .form-group {
        width: 250px;
        flex-shrink: 0;
        margin-bottom: 0;
    }
    
    .create-alert-form > .checkbox-group {
        width: 100%;
        flex-basis: 100%;
    }
    
    .create-alert-form > button {
        width: 100%;
        flex-basis: 100%;
        margin-top: 8px;
    }
    
    @media (max-width: 600px) {
        .create-alert-form > .form-group {
            width: 100%;
        }
    }
    
    .form-error-container {
        margin-bottom: 16px;
    }
    
    .actions-error-container {
        margin-bottom: 12px;
    }
    
    .form-group {
        margin-bottom: 18px;
        position: relative;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: var(--text);
        font-size: 14px;
    }
    
    .form-group input,
    .form-group select {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 15px;
        color: var(--text);
        background: var(--surface);
        transition: all 0.15s;
    }
    
    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    
    .form-group input::placeholder {
        color: var(--muted);
    }
    
    .form-hint {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-top: 4px;
        line-height: 1.4;
    }
    
    /* Multi-item selector styles */
    .multi-item-selector {
        position: relative;
    }
    
    .multi-item-selector input[type="text"] {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 15px;
        color: var(--text);
        background: var(--surface);
        transition: all 0.15s;
    }
    
    .multi-item-selector input[type="text"]:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    
    .selected-items-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
        min-height: 0;
    }
    
    .selected-items-container:empty {
        display: none;
    }
    
    .selected-item-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: var(--primary);
        color: white;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
        animation: chipIn 0.15s ease-out;
    }
    
    @keyframes chipIn {
        from {
            opacity: 0;
            transform: scale(0.8);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .selected-item-chip .chip-remove {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        cursor: pointer;
        font-size: 12px;
        line-height: 1;
        transition: background 0.15s;
    }
    
    .selected-item-chip .chip-remove:hover {
        background: rgba(255, 255, 255, 0.4);
    }
    
    .checkbox-group {
        display: flex;
        align-items: center;
    }
    
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        font-weight: 500;
        color: var(--text);
    }
    
    .checkbox-label input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
    }
    
    .btn-create-alert {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        border: none;
        padding: 12px 28px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.15s;
    }
    
    .btn-create-alert:hover {
        background: linear-gradient(135deg, #0e8377 0%, #2dd36f 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
    }

    /* Suggestions dropdown */
    .suggestions-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .suggestion-item {
        padding: 10px 14px;
        cursor: pointer;
        transition: background 0.15s;
        font-size: 14px;
    }
    
    .suggestion-item:hover,
    .suggestion-item.selected {
        background: var(--primary);
        color: white;
    }
    
    .clickable-alert {
        cursor: pointer;
    }
    
    .clickable-alert:hover {
        background: rgba(99, 102, 241, 0.08);
    }

    /* Modals */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    
    .modal-content {
        background: var(--surface);
        padding: 0;
        border-radius: 12px;
        width: 100%;
        max-width: 450px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        overflow: hidden;
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        color: white;
    }
    
    .modal-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: white;
        line-height: 1;
        opacity: 0.8;
    }
    
    .modal-close:hover {
        opacity: 1;
    }
    
    .modal-content .form-group {
        padding: 0 20px;
        margin-top: 20px;
    }
    
    .modal-buttons {
        display: flex;
        gap: 10px;
        padding: 20px;
    }
    
    .btn-save {
        flex: 1;
        background: linear-gradient(135deg, #22C55E 0%, #16A34A 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.15s;
    }
    
    .btn-save:hover {
        background: linear-gradient(135deg, #16A34A 0%, #15803D 100%);
        transform: translateY(-1px);
    }
    
    .btn-cancel {
        flex: 1;
        background: var(--surface-2);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        transition: all 0.15s;
    }
    
    .btn-cancel:hover {
        background: var(--surface);
        border-color: var(--muted);
    }
    
    .btn-clear {
        flex: 0 0 auto;
        background: var(--surface-2);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        transition: all 0.15s;
    }
    
    .btn-clear:hover {
        background: var(--surface);
        border-color: var(--muted);
    }
    
    /* Styled filter modal */
    .filter-modal-styled .modal-content {
        max-width: 380px;
    }
    
    .filter-modal-styled .modal-body {
        padding: 20px;
        text-align: center;
    }
    
    .filter-modal-styled .filter-icon {
        width: 56px;
        height: 56px;
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
    }
    
    .filter-modal-styled .filter-icon svg {
        width: 28px;
        height: 28px;
        color: white;
    }
    
    .filter-modal-styled .filter-description {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 20px;
    }
    
    .filter-modal-styled .form-group {
        text-align: left;
        padding: 0;
        margin-bottom: 16px;
    }
    
    .filter-modal-styled .form-group:last-of-type {
        margin-bottom: 0;
    }
    
    .filter-modal-styled .form-group label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 6px;
    }
    
    .filter-modal-styled .form-group input {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 14px;
        color: var(--text);
        background: var(--surface);
        transition: border-color 0.15s, box-shadow 0.15s;
        box-sizing: border-box;
    }
    
    .filter-modal-styled .form-group input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .filter-modal-styled .form-group input::placeholder {
        color: var(--muted);
    }
    
    .modal-content-large {
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
    }

    /* Group pills */
    .group-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 5px 0;
    }
    
    .group-checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        border: 1px solid var(--border);
        border-radius: 20px;
        background: var(--surface);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s;
    }
    
    .group-checkbox-label:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }
    
    .group-checkbox-label input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: var(--primary);
    }
    
    .group-checkbox-label input[type="checkbox"]:checked + span {
        font-weight: 600;
        color: var(--primary);
    }
    
    .group-pill {
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        border: 1px solid var(--border);
        border-radius: 20px;
        background: var(--surface);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s;
        user-select: none;
    }
    
    .group-pill:hover {
        background: var(--surface-2);
        border-color: var(--muted);
    }
    
    .group-pill.selected {
        background: var(--hover-orange);
        border-color: var(--hover-orange);
        color: white;
    }
    
    .group-pill.selected:hover {
        background: #EA580C;
        border-color: #EA580C;
    }

    /* Action buttons */
    .action-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.15s;
    }
    
    .edit-btn {
        background: var(--primary);
        color: white;
    }
    
    .edit-btn:hover {
        background: var(--primary-hover);
    }
    
    .delete-btn {
        background: var(--danger);
        color: white;
    }
    
    .delete-btn:hover {
        background: #DC2626;
    }
    
    .confirm-delete-btn {
        background: var(--danger);
        color: white;
    }
    
    .confirm-delete-btn:hover {
        background: #DC2626;
    }
    
    .cancel-btn {
        background: var(--muted);
        color: white;
    }
    
    .cancel-btn:hover {
        background: #4B5563;
    }

    /* Spread items list */
    #spread-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #spread-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #spread-items-list li:last-child {
        border-bottom: none;
    }
    #spike-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #spike-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #spike-items-list li:last-child {
        border-bottom: none;
    }
    .spread-item-name {
        font-weight: 600;
        color: #333;
    }
    .spread-item-details {
        color: #666;
        font-size: 0.9rem;
    }
    .spread-item-percentage {
        font-weight: 700;
        color: #28a745;
        font-size: 1.1rem;
    }
    .spread-item-percentage.negative-change {
        color: #dc3545;
    }

    /* Medium screen - sort indicator on separate row */
    @media (max-width: 1250px) {
        .alert-actions-wrapper {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

    .sort-indicator {
        margin-top:7px;
    }
        
        .alert-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            width: 100%;
        }
        
        /* Hide sort indicator from its normal position */
        .sort-controls .sort-indicator-wrapper {
            display: none;
        }
        
        /* Show sort indicator in mobile row, aligned right */
        .sort-indicator-mobile-row {
            display: block;
            text-align: right;
            margin-bottom: -2px;
        }
        
        /* When sort indicator is not active, collapse the row */
        .sort-indicator-mobile-row:not(:has(.sort-indicator.active)) {
            display: none;
        }
        
        .sort-indicator-mobile-row .sort-indicator.active {
            display: inline-flex;
        }
    }

    /* Tablet/Mobile Responsive Styles */
    @media (max-width: 950px) {

        .alert-actions {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 10px;
            width: 100%;
        }
        
        /* Row 1: Search takes full width (spans all 3 columns) */
        .alert-actions-left {
            grid-column: 1 / -1;
            grid-row: 1;
            display: contents;
        }
        
        .alert-actions-left .alert-search-wrapper {
            grid-column: 1 / -1;
            grid-row: 1;
            width: 100%;
        }
        
        /* Actions dropdown - first item in row 2 */
        .alert-actions-left .custom-dropdown-wrapper {
            grid-column: 1;
            grid-row: 2;
            min-width: 0;
        }
        
        /* Row 2: Sort and Filters */
        .alert-actions-right {
            display: contents;
        }
        
        .alert-actions-controls {
            display: contents;
        }
        
        .sort-controls {
            display: contents;
        }
        
        /* Sort dropdown - second item in row 2 */
        .sort-controls .custom-dropdown-wrapper {
            grid-column: 2;
            grid-row: 2;
            min-width: 0;
        }
        
        /* Filter dropdown - third item in row 2 */
        .alert-actions-controls > .custom-dropdown-wrapper {
            grid-column: 3;
            grid-row: 2;
            min-width: 0;
        }
        
        .btn-dropdown {
            width: 100%;
            justify-content: center;
            min-width: 0;
            overflow: hidden;
        }
        
        /* Hide button icons on mobile, show only text */
        .btn-dropdown svg {
            display: none;
        }
        
        .alert-search-input {
            width: 100%;
        }
        
        /* Reset dropdown alignment */
        .custom-dropdown-menu,
        #sortDropdownMenu {
            width: 100%;
            left: 0;
            right: 0;
        }
        
        /* Filter dropdown right-aligned */
        #filterDropdownMenu {
            width: auto;
            min-width: 180px;
            left: auto;
            right: 0;
        }
        
        .sort-indicator-wrapper {
            display: none;
        }
        
        /* Hide item icon on small screens */
        .alert-icon,
        .alert-icon-placeholder {
            display: none;
        }
        
        .alert-threshold-label {
            display: none;
        }
    }
</style>

<script>
/**
 * =============================================================================
 * OSRS ALERTS MANAGEMENT SYSTEM
 * =============================================================================
 * 
 * This module handles all client-side functionality for the alerts system:
 * - Creating and editing alerts (above/below threshold, spread alerts)
 * - Displaying triggered alerts with real-time updates
 * - Managing alert lifecycle (dismiss, delete)
 * - Item search autocomplete functionality
 * - Modal management for spread details and editing
 * 
 * Architecture:
 * - AlertsConfig: Central configuration object for settings and selectors
 * - AlertsState: Manages application state (filters, cached data, etc.)
 * - AlertsAPI: Handles all server communication
 * - AlertsUI: Manages DOM updates and rendering
 * - FormManager: Handles form field visibility and validation
 * - ModalManager: Controls modal dialogs
 * - AutocompleteManager: Handles item search suggestions
 * - EventManager: Sets up all event listeners
 * 
 * =============================================================================
 */

// =============================================================================
// CONFIGURATION
// =============================================================================
/**
 * Central configuration object containing all settings, selectors, and constants.
 * 
 * Why: Centralizing configuration makes it easy to modify settings without
 * searching through code. It also makes the codebase more maintainable.
 * 
 * How: All DOM selectors, API endpoints, and timing settings are defined here
 * and referenced throughout the application.
 */
const AlertsConfig = {
    // API endpoints for server communication
    endpoints: {
        alerts: '/api/alerts/',
        dismiss: '/api/alerts/dismiss/',
        delete: '/api/alerts/delete/',
        update: '/api/alerts/update/',
        group: '/api/alerts/group/',
        deleteGroups: '/api/alerts/groups/delete/',
        itemSearch: '/api/items/'
    },
    
    // Timing settings (in milliseconds)
    timing: {
        refreshInterval: 5000,      // How often to poll for alert updates
        minSearchLength: 2          // Minimum characters before searching
    },
    
    // Available filters for the alerts list
    // Simple filters have just a test function
    // Input filters have requiresInput: true and testWithValue function
    filters: {
        triggered: { 
            id: 'triggered', 
            label: 'Triggered', 
            test: alert => alert.is_triggered 
        },
        notTriggered: { 
            id: 'notTriggered', 
            label: 'Not Triggered', 
            test: alert => !alert.is_triggered 
        },
        priceRange: {
            id: 'priceRange',
            label: 'Price',
            shortLabel: 'Price',
            requiresModal: true,
            testWithValue: (alert, value) => {
                if (!value) return true;
                const { min, max } = value;
                const minPrice = min != null && min !== '' ? parseInt(min) : null;
                const maxPrice = max != null && max !== '' ? parseInt(max) : null;
                
                // Get the current price for the alert
                let currentPrice = null;
                
                // For above/below alerts, use the current price
                if (alert.type === 'above' || alert.type === 'below') {
                    currentPrice = alert.current_price;
                }
                // For spread alerts with all items, use average of min/max
                else if (alert.type === 'spread' && alert.is_all_items) {
                    const minP = alert.minimum_price || 0;
                    const maxP = alert.maximum_price || 0;
                    currentPrice = (minP + maxP) / 2;
                }
                // For spread alerts with single item, use average of low/high
                else if (alert.type === 'spread' && !alert.is_all_items) {
                    const low = alert.spread_low || 0;
                    const high = alert.spread_high || 0;
                    currentPrice = (low + high) / 2;
                }
                // For spike alerts, use current price
                else if (alert.type === 'spike') {
                    currentPrice = alert.current_price;
                }
                // Default fallback
                else {
                    currentPrice = alert.current_price || alert.price || 0;
                }
                
                if (currentPrice == null) return true;
                
                // Check min bound (inclusive)
                if (minPrice != null && !isNaN(minPrice) && currentPrice < minPrice) {
                    return false;
                }
                
                // Check max bound (inclusive)
                if (maxPrice != null && !isNaN(maxPrice) && currentPrice > maxPrice) {
                    return false;
                }
                
                return true;
            }
        },
        myGroups: {
            id: 'myGroups',
            label: 'My Groups',
            requiresModal: true,
            testWithValue: (alert, selectedGroups) => {
                if (!selectedGroups || selectedGroups.length === 0) return true;
                // Check if alert belongs to any of the selected groups
                const alertGroups = alert.groups || [];
                return selectedGroups.some(group => alertGroups.includes(group));
            }
        }
    },

    // DOM element selectors for the create form
    selectors: {
        create: {
            alertType: '#alert-type',
            spreadScope: '#spread-scope',
            sustainedScope: '#sustained-scope',
            itemName: '#item-name',
            itemId: '#item-id',
            isAllItems: '#is-all-items',
            numberItems: '#number-of-items',
            direction: '#direction',
            emailNotification: '#email-notification',
            suggestions: '#item-suggestions',
            sustainedItemInput: '#sustained-item-input',
            sustainedItemIds: '#sustained-item-ids',
            sustainedItemSuggestions: '#sustained-item-suggestions',
            selectedItemsContainer: '#selected-items-container',
            alertGroup: '#alert-group',
                groups: {
                    spreadScope: '#spread-scope-group',
                    sustainedScope: '#sustained-scope-group',
                    sustainedItems: '#sustained-items-group',
                    numberItems: '#number-items-group',
                    itemName: '#item-name-group',
                    price: '#price-group',
                    reference: '#reference-group',
                    percentage: '#percentage-group',
                    timeFrame: '#time-frame-group',
                    direction: '#direction-group',
                    minPrice: '#min-price-group',
                    maxPrice: '#max-price-group',
                    minConsecutiveMoves: '#min-consecutive-moves-group',
                    minMovePercentage: '#min-move-percentage-group',
                    volatilityBuffer: '#volatility-buffer-group',
                    volatilityMultiplier: '#volatility-multiplier-group',
                    minVolume: '#min-volume-group',
                    pressureStrength: '#pressure-strength-group',
                    pressureSpread: '#pressure-spread-group'
                }
            },
        // Other UI elements
        myAlertsPane: '#my-alerts',
        spreadModal: '#spread-modal',
        spreadItemsList: '#spread-items-list',
        spikeModal: '#spike-modal',
        spikeItemsList: '#spike-items-list',
        groupModal: '#group-modal',
        groupList: '#group-list',
        newGroupInput: '#new-group-input',
        tabButtons: '.tab-btn',
        tabPanes: '.tab-pane'
    },
    
    // Alert type constants for comparison
    alertTypes: {
        ABOVE: 'above',
        BELOW: 'below',
        SPREAD: 'spread',
        SPIKE: 'spike',
        SUSTAINED: 'sustained'
    },
    
    // CSRF token for Django POST requests
    csrfToken: '{{ csrf_token }}'
};

// =============================================================================
// DROPDOWN SIZING (compact label, expandable options)
// =============================================================================
const DropdownSizer = {
    _canvas: null,
    
    measureText(text, select) {
        if (!this._canvas) this._canvas = document.createElement('canvas');
        const ctx = this._canvas.getContext('2d');
        const style = window.getComputedStyle(select);
        ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
        return ctx.measureText(text || '').width;
    },
    
    applySizing(select) {
        if (!select) return;
        const padding =
            parseFloat(window.getComputedStyle(select).paddingLeft || 0) +
            parseFloat(window.getComputedStyle(select).paddingRight || 0);
        const arrowSpace = 24; // room for native dropdown arrow
        
        const calcWidth = text => this.measureText(text, select) + padding + arrowSpace;
        const getExpandedWidth = () => {
            let max = 0;
            Array.from(select.options).forEach(opt => { max = Math.max(max, calcWidth(opt.text)); });
            return max || calcWidth(select.options[0]?.text || '');
        };
        
        const updateCompactWidth = () => {
            const selectedText = select.options[select.selectedIndex]?.text || select.options[0]?.text || '';
            select.dataset.compactWidth = calcWidth(selectedText);
        };
        
        const applyCompact = () => {
            const width = select.dataset.compactWidth || calcWidth(select.options[0]?.text || '');
            select.style.minWidth = `${width}px`;
        };
        
        const expandedWidth = getExpandedWidth();
        select.dataset.expandedWidth = expandedWidth;
        updateCompactWidth();
        applyCompact();
        
        const expand = () => { select.style.minWidth = `${select.dataset.expandedWidth}px`; };
        const collapse = () => { applyCompact(); };
        
        select.addEventListener('focus', expand);
        select.addEventListener('mousedown', expand);
        select.addEventListener('blur', collapse);
        select.addEventListener('change', () => {
            updateCompactWidth();
            collapse();
        });
    },
    
    init() {
        this.applySizing(document.querySelector('.action-dropdown'));
        this.applySizing(document.querySelector('.sort-dropdown'));
        this.applySizing(document.querySelector('.filter-dropdown'));
    }
};


// =============================================================================
// STATE MANAGEMENT
// =============================================================================
/**
 * Application state manager.
 * 
 * Why: Centralizing state prevents scattered variables and makes it easier
 * to track and debug the application's current status.
 * 
 * How: All mutable state is stored in this object and accessed/modified
 * through consistent patterns.
 */
const AlertsState = {
    spreadDataCache: {},            // Cache for spread alert data (keyed by alert ID)
    spikeDataCache: {},             // Cache for spike all-items data
    activeFilters: new Set(),       // Currently active filter IDs
    filterValues: {},               // Values for input-based filters (keyed by filter ID)
    alertGroups: [],                // Known alert groups
    cachedAlerts: [],               // Cached alerts data for instant filtering/sorting
    searchQuery: '',                // Current search query
    iconCache: {},                  // Cache for item icons (keyed by item_id)
    sorting: {                      // Current sorting state
        sortKey: null,
        sortOrder: null,
        pendingKey: null
    },
    
    /**
     * Stores spread data for a specific alert in the cache.
     * This allows the spread details modal to access the data later.
     */
    setSpreadData(alertId, data) {
        this.spreadDataCache[alertId] = data;
    },
    
    /**
     * Retrieves cached spread data for an alert.
     * Returns null if no data exists for the given ID.
     */
    getSpreadData(alertId) {
        return this.spreadDataCache[alertId] || null;
    },

    setSpikeData(alertId, data) {
        this.spikeDataCache[alertId] = data;
    },

    getSpikeData(alertId) {
        return this.spikeDataCache[alertId] || null;
    },

    /**
     * Updates known alert groups from alert data payload.
     */
    setAlertGroups(groups) {
        this.alertGroups = Array.isArray(groups) ? groups : [];
        // Update the create form group dropdown
        this.updateGroupDropdown();
    },
    
    /**
     * Updates the group dropdown in the create alert form.
     */
    updateGroupDropdown() {
        const dropdown = document.querySelector(AlertsConfig.selectors.create.alertGroup);
        if (!dropdown) return;
        
        const currentValue = dropdown.value;
        dropdown.innerHTML = '<option value="">No Group</option>';
        
        this.alertGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            dropdown.appendChild(option);
        });
        
        // Restore selection if still valid
        if (currentValue && this.alertGroups.includes(currentValue)) {
            dropdown.value = currentValue;
        }
    },

    /**
     * Returns known alert groups.
     */
    getAlertGroups() {
        return this.alertGroups || [];
    },
    
    /**
     * Caches the alerts array for instant filtering/sorting.
     */
    setCachedAlerts(alerts) {
        this.cachedAlerts = Array.isArray(alerts) ? alerts : [];
    },
    
    /**
     * Returns the cached alerts array.
     */
    getCachedAlerts() {
        return this.cachedAlerts || [];
    },
    
    /**
     * Sets a value for an input-based filter.
     */
    setFilterValue(filterId, value) {
        this.filterValues[filterId] = value;
    },
    
    /**
     * Gets the value for an input-based filter.
     */
    getFilterValue(filterId) {
        return this.filterValues[filterId] || null;
    }
};


// =============================================================================
// API COMMUNICATION
// =============================================================================
/**
 * Handles all server communication.
 * 
 * Why: Centralizing API calls makes it easier to handle errors consistently,
 * modify endpoints, and add features like request caching or retries.
 * 
 * How: Each method corresponds to a specific API action and returns a Promise.
 */
const AlertsAPI = {
    /**
     * Fetches current alerts data from the server.
     * Returns both active alerts and triggered notifications.
     */
    async fetchAlerts() {
        try {
            const response = await fetch(AlertsConfig.endpoints.alerts);
            return await response.json();
        } catch (error) {
            console.error('Error fetching alerts:', error);
            return null;
        }
    },
    
    /**
     * Dismisses a triggered alert notification.
     * The alert remains in the system but the notification banner is hidden.
     */
    async dismissAlert(alertId) {
        try {
            await fetch(AlertsConfig.endpoints.dismiss, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_id: alertId })
            });
            return true;
        } catch (error) {
            console.error('Error dismissing alert:', error);
            return false;
        }
    },
    
    /**
     * Deletes multiple alerts by their IDs.
     */
    async deleteAlerts(alertIds) {
        try {
            await fetch(AlertsConfig.endpoints.delete, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ alert_ids: alertIds })
            });
            return true;
        } catch (error) {
            console.error('Error deleting alerts:', error);
            return false;
        }
    },

    /**
     * Adds alerts to groups (creates groups if needed).
     */
    async groupAlerts(alertIds, groups, newGroups) {
        try {
            await fetch(AlertsConfig.endpoints.group, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({
                    alert_ids: alertIds,
                    groups: groups,
                    new_groups: newGroups
                })
            });
            return true;
        } catch (error) {
            console.error('Error grouping alerts:', error);
            return false;
        }
    },

    /**
     * Deletes alert groups by name.
     */
    async deleteGroups(groups) {
        try {
            const response = await fetch(AlertsConfig.endpoints.deleteGroups, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify({ groups })
            });
            if (!response.ok) return false;
            const data = await response.json();
            return !!data.success;
        } catch (error) {
            console.error('Error deleting groups:', error);
            return false;
        }
    },
    
    /**
     * Updates an existing alert with new values.
     */
    async updateAlert(alertData) {
        try {
            await fetch(AlertsConfig.endpoints.update, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': AlertsConfig.csrfToken
                },
                body: JSON.stringify(alertData)
            });
            return true;
        } catch (error) {
            console.error('Error updating alert:', error);
            return false;
        }
    },
    
    /**
     * Searches for items by name query.
     * Used for autocomplete in item name fields.
     */
    async searchItems(query) {
        try {
            const url = AlertsConfig.endpoints.itemSearch + '?q=' + encodeURIComponent(query);
            const response = await fetch(url);
            return await response.json();
        } catch (error) {
            console.error('Error searching items:', error);
            return [];
        }
    }
};


// =============================================================================
// UI RENDERING
// =============================================================================
/**
 * Handles all DOM updates and HTML rendering.
 * 
 * Why: Separating UI logic from business logic makes the code easier to test,
 * modify, and understand. Changes to how things look don't affect how they work.
 * 
 * How: Each method handles a specific rendering task and returns HTML strings
 * or directly manipulates the DOM as appropriate.
 */
const AlertsUI = {
    /**
     * Generates the triggered text for an alert based on its type and data.
     * 
     * Why: Different alert types need different information displayed when triggered.
     * - Spread (all items): Shows clickable link to view all matching items
     * - Spread (single item): Shows low, high, and spread percentage
     * - Above/Below: Shows the price movement that triggered the alert
     */
    buildTriggeredText(alert) {
        return 'Triggered';
    },
    
    /**
     * Checks if an alert is a spread-all-items type.
     */
    isSpreadAllItemsAlert(alert) {
        return alert.type === AlertsConfig.alertTypes.SPREAD && 
               alert.is_all_items && 
               alert.triggered_data;
    },

    /**
     * Checks if an alert is a spike-all-items type.
     */
    isSpikeAllItemsAlert(alert) {
        return alert.type === AlertsConfig.alertTypes.SPIKE &&
               alert.is_all_items &&
               alert.triggered_data;
    },
    
    /**
     * Renders the green notification banners for triggered alerts.
     */
    renderTriggeredNotifications(triggeredAlerts) {
        if (!triggeredAlerts || triggeredAlerts.length === 0) {
            return '';
        }
        
        // DEBUG: Log triggered alerts data
        console.log('=== TRIGGERED ALERTS DEBUG ===');
        console.log('Number of triggered alerts:', triggeredAlerts.length);
        triggeredAlerts.forEach((alert, index) => {
            console.log(`Alert ${index}:`, {
                id: alert.id,
                type: alert.type,
                triggered_text: alert.triggered_text,
                triggered_data: alert.triggered_data,
                direction: alert.direction,
                is_all_items: alert.is_all_items,
                // Sustained-specific fields
                sustained_item_name: alert.sustained_item_name,
                sustained_direction: alert.sustained_direction,
                sustained_streak_count: alert.sustained_streak_count,
                sustained_total_move: alert.sustained_total_move,
                sustained_start_price: alert.sustained_start_price,
                sustained_current_price: alert.sustained_current_price,
                sustained_volume: alert.sustained_volume
            });
        });
        console.log('==============================');
        
        let html = '';
        triggeredAlerts.forEach(alert => {
            const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
            const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);
            
            // Cache spread data for later use in modal
            if (isSpreadAllItems) {
                AlertsState.setSpreadData(alert.id, alert.triggered_data);
            }
            if (isSpikeAllItems) {
                AlertsState.setSpikeData(alert.id, alert.triggered_data);
            }
            
            const clickHandler = isSpreadAllItems 
                ? 'onclick="ModalManager.showSpreadDetails(' + alert.id + ')"' 
                : (isSpikeAllItems ? 'onclick="ModalManager.showSpikeDetails(' + alert.id + ')"' : '');
            const clickableClass = (isSpreadAllItems || isSpikeAllItems) ? 'clickable-triggered' : '';
            
            html += '<div class="triggered-notification" data-alert-id="' + alert.id + '">' +
                    '<span class="' + clickableClass + '" ' + clickHandler + '>' + alert.triggered_text + '</span>' +
                    '</div>';
        });
        
        return html;
    },
    
    /**
     * Renders the action dropdown and filter dropdown.
     * @param {boolean} hasAlerts - Whether there are alerts to display
     * @param {string} preservedFilterTagsHtml - HTML of preserved filter tags (optional)
     */
    renderActionButtons(hasAlerts, preservedFilterTagsHtml) {
        if (!hasAlerts) return '';
        
        // Build filter dropdown items
        let filterItems = '';
        for (const [id, filter] of Object.entries(AlertsConfig.filters)) {
            const isActive = FilterManager.isActive(id);
            filterItems += '<div class="custom-dropdown-item' + (isActive ? ' active' : '') + '" data-filter="' + id + '">' +
                '<span>' + filter.label + '</span>' +
                '<span class="filter-check">✓</span>' +
                '<span class="filter-clear" title="Clear filter">×</span>' +
                '</div>';
        }
        
        // Use preserved filter tags if provided, otherwise build from state
        let tags = preservedFilterTagsHtml || '';
        if (!preservedFilterTagsHtml) {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (filter) {
                    tags += '<span class="filter-tag" data-filter-id="' + filterId + '">' + filter.label + 
                            '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                            '</span>';
                }
            }
        }

        // Build sort indicator HTML (desktop)
        let sortIndicatorHtml = '';
        // Build mobile sort indicator HTML
        let mobileSortIndicatorHtml = '';
        
        if (AlertsState.sorting.sortKey) {
            const sortOption = SortManager.options[AlertsState.sorting.sortKey];
            const label = sortOption ? sortOption.label : 'Sort';
            const arrow = AlertsState.sorting.sortOrder === 'asc' ? '↑' : '↓';
            sortIndicatorHtml = '<div class="sort-indicator-wrapper" id="sortIndicatorWrapper">' +
                '<div class="sort-indicator active" id="sortIndicator">' +
                '<span class="sort-indicator-label">Sorted by:</span>' +
                '<span class="sort-indicator-value" id="sortIndicatorValue">' + label + '</span>' +
                '<span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">' + arrow + '</span>' +
                '<span class="sort-indicator-clear" id="sortIndicatorClear" title="Clear sort">×</span>' +
                '</div>' +
                '</div>';
            mobileSortIndicatorHtml = '<div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">' +
                '<div class="sort-indicator active" id="sortIndicatorMobile">' +
                '<span class="sort-indicator-label">Sorted by:</span>' +
                '<span class="sort-indicator-value" id="sortIndicatorValueMobile">' + label + '</span>' +
                '<span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">' + arrow + '</span>' +
                '<span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">×</span>' +
                '</div>' +
                '</div>';
        } else {
            sortIndicatorHtml = '<div class="sort-indicator-wrapper" id="sortIndicatorWrapper">' +
                '<div class="sort-indicator" id="sortIndicator">' +
                '<span class="sort-indicator-label">Sorted by:</span>' +
                '<span class="sort-indicator-value" id="sortIndicatorValue"></span>' +
                '<span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">↓</span>' +
                '<span class="sort-indicator-clear" id="sortIndicatorClear" title="Clear sort">×</span>' +
                '</div>' +
                '</div>';
            mobileSortIndicatorHtml = '<div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">' +
                '<div class="sort-indicator" id="sortIndicatorMobile">' +
                '<span class="sort-indicator-label">Sorted by:</span>' +
                '<span class="sort-indicator-value" id="sortIndicatorValueMobile"></span>' +
                '<span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">↓</span>' +
                '<span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">×</span>' +
                '</div>' +
                '</div>';
        }

        // Build sort dropdown items
        const currentSortKey = AlertsState.sorting.sortKey;
        const sortItems = '' +
            '<div class="custom-dropdown-item' + (currentSortKey === 'alphabetically' ? ' active' : '') + '" data-sort="alphabetically"><span>Alphabetically</span><span class="sort-check">✓</span></div>' +
            '<div class="custom-dropdown-item' + (currentSortKey === 'lastTriggered' ? ' active' : '') + '" data-sort="lastTriggered"><span>Last Triggered Time</span><span class="sort-check">✓</span></div>' +
            '<div class="custom-dropdown-item' + (currentSortKey === 'alertType' ? ' active' : '') + '" data-sort="alertType"><span>Alert Type</span><span class="sort-check">✓</span></div>' +
            '<div class="custom-dropdown-item' + (currentSortKey === 'thresholdDistance' ? ' active' : '') + '" data-sort="thresholdDistance"><span>Threshold Distance</span><span class="sort-check">✓</span></div>' +
            '<div class="custom-dropdown-item' + (currentSortKey === 'createdDate' ? ' active' : '') + '" data-sort="createdDate"><span>Created Date</span><span class="sort-check">✓</span></div>';

        // Calculate filter badge
        const activeCount = AlertsState.activeFilters.size;
        const filterBadge = activeCount > 0 
            ? '<span class="filter-badge" id="filterBadge">' + activeCount + '</span>'
            : '<span class="filter-badge" id="filterBadge" style="display: none;">0</span>';
        const filterBtnClass = activeCount > 0 ? 'btn-dropdown btn-filter has-active' : 'btn-dropdown btn-filter';
        
        // Build search bar with current value preserved
        const searchValue = AlertsState.searchQuery || '';
        const searchHasValue = searchValue.length > 0 ? ' has-value' : '';
        const searchBarHtml = '' +
            '<div class="alert-search-wrapper' + searchHasValue + '">' +
            '<svg class="alert-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>' +
            '</svg>' +
            '<input type="text" class="alert-search-input" id="alertSearchInput" placeholder="Search alerts..." autocomplete="off" value="' + searchValue.replace(/"/g, '&quot;') + '">' +
            '<button type="button" class="alert-search-clear" id="alertSearchClear" title="Clear search">×</button>' +
            '</div>';
        
        return '<div class="alert-actions-wrapper">' +
               '<div class="alert-actions">' +
               '<div class="alert-actions-left">' +
               '<div class="custom-dropdown-wrapper">' +
               '<button type="button" class="btn-dropdown btn-actions" id="actionsDropdownBtn">' +
               '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
               '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>' +
               '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>' +
               '</svg>' +
               '<span class="btn-text">Actions</span>' +
               '</button>' +
               '<div class="custom-dropdown-menu" id="actionsDropdownMenu">' +
               '<div class="custom-dropdown-header">Actions</div>' +
               '<div class="custom-dropdown-item" data-action="delete"><span>Delete</span></div>' +
               '<div class="custom-dropdown-item" data-action="group"><span>Add to Group</span></div>' +
               '</div>' +
               '</div>' +
               searchBarHtml +
               '</div>' +
               '<div class="alert-actions-right" id="active-filters">' +
               '<div class="alert-actions-controls">' +
               '<div class="sort-controls">' +
               sortIndicatorHtml +
               '<div class="custom-dropdown-wrapper">' +
               '<button type="button" class="btn-dropdown btn-sort" id="sortDropdownBtn">' +
               '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
               '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>' +
               '</svg>' +
               '<span class="btn-text">Sort</span>' +
               '</button>' +
               '<div class="custom-dropdown-menu" id="sortDropdownMenu">' +
               '<div class="custom-dropdown-header">Sort by</div>' +
               sortItems +
               '</div>' +
               '</div>' +
               '</div>' +
               '<div class="custom-dropdown-wrapper">' +
               '<button type="button" class="' + filterBtnClass + '" id="filterDropdownBtn">' +
               '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
               '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>' +
               '</svg>' +
               '<span class="btn-text">Filters</span>' +
               filterBadge +
               '</button>' +
               '<div class="custom-dropdown-menu" id="filterDropdownMenu">' +
               '<div class="custom-dropdown-header">Filter by</div>' +
               filterItems +
               '</div>' +
               '</div>' +
               '</div>' +
               '</div>' +
               '</div>' +
               mobileSortIndicatorHtml +
               '<div class="alert-indicators">' +
               '<div class="filter-tags">' + tags + '</div>' +
               '</div>' +
               '</div>';
    },
    
    /**
     * Renders a single alert list item.
     */
    renderAlertItem(alert) {
        const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
        const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);
        
        // Cache spread data if triggered (for detail page)
        if (isSpreadAllItems && alert.is_triggered) {
            AlertsState.setSpreadData(alert.id, alert.triggered_data);
        }
        if (isSpikeAllItems && alert.is_triggered) {
            AlertsState.setSpikeData(alert.id, alert.triggered_data);
        }
        
        // Build triggered badge if needed
        let triggeredBadge = '';
        if (alert.is_triggered) {
            const triggeredText = this.buildTriggeredText(alert);
            triggeredBadge = '<span class="alert-triggered">' + triggeredText + '</span>';
        }

        // Build active/inactive status display
        const isActive = alert.is_active !== false; // Default to active if not specified
        const statusDisplay = isActive 
            ? '<span class="alert-status alert-status-active">Active</span>'
            : '<span class="alert-status alert-status-inactive">Inactive</span>';
        
        // Build sort info text based on current sort
        let sortInfoHtml = '';
        const currentSort = AlertsState.sorting.sortKey;
        if (currentSort === 'lastTriggered') {
            const ts = alert.last_triggered_at || alert.triggered_at || alert.triggered_time || alert.last_triggered_time;
            let timeText = 'Never';
            if (ts) {
                const date = new Date(ts);
                if (!isNaN(date.getTime())) {
                    timeText = date.toLocaleString();
                }
            }
            sortInfoHtml = '<div class="alert-sort-info">Last triggered: ' + timeText + '</div>';
        } else if (currentSort === 'createdDate') {
            let timeText = 'Unknown';
            if (alert.created_at) {
                const date = new Date(alert.created_at);
                if (!isNaN(date.getTime())) {
                    timeText = date.toLocaleString();
                }
            }
            sortInfoHtml = '<div class="alert-sort-info">Created: ' + timeText + '</div>';
        } else if (currentSort === 'alertType') {
            const typeText = alert.type ? alert.type.charAt(0).toUpperCase() + alert.type.slice(1) : 'Unknown';
            sortInfoHtml = '<div class="alert-sort-info">Type: ' + typeText + '</div>';
        } else if (currentSort === 'thresholdDistance') {
            const thresholdDistance = SortManager.getThresholdDistance(alert);
            let distText = 'N/A';
            if (typeof thresholdDistance === 'number' && !Number.isNaN(thresholdDistance)) {
                distText = thresholdDistance.toFixed(2) + '%';
            }
            sortInfoHtml = '<div class="alert-sort-info">Threshold distance: ' + distText + '</div>';
        }

        // Build icon HTML - use item image if available, otherwise placeholder
        let iconHtml;
        if (alert.icon) {
            // Cache the icon for this item
            if (alert.item_id) {
                AlertsState.iconCache[alert.item_id] = alert.icon;
            }
            const iconUrl = 'https://oldschool.runescape.wiki/images/' + encodeURIComponent(alert.icon.replace(/ /g, '_'));
            iconHtml = '<img class="alert-icon" src="' + iconUrl + '" alt="" loading="lazy">';
        } else if (alert.is_all_items) {
            // "All items" alerts get a stack icon
            iconHtml = '<span class="alert-icon-placeholder">📊</span>';
        } else {
            // Fallback bell for items without icons
            iconHtml = '<span class="alert-icon-placeholder">🔔</span>';
        }

        return '<li class="alert-item clickable-alert" data-alert-id="' + alert.id + '" data-alert-text="' + (alert.text || '').replace(/"/g, '&quot;') + '" onclick="navigateToAlertDetail(event, ' + alert.id + ')">' +
               '<input type="checkbox" class="alert-checkbox" onclick="event.stopPropagation()">' +
               iconHtml +
               '<div class="alert-content">' +
               '<span class="alert-text">' + alert.text + '</span>' +
               sortInfoHtml +
               '</div>' +
               triggeredBadge +
               statusDisplay +
               '</li>';
    },
    
    /**
     * Renders the complete alerts list.
     * When groups filter is active, displays alerts grouped by their group names.
     */
    renderAlertsList(alerts) {
        if (!alerts || alerts.length === 0) {
            return '<p class="no-alerts">No active alerts. Create one to get started!</p>';
        }
        
        // Apply active filters then sort
        const filteredAlerts = SortManager.applySort(FilterManager.applyFilters(alerts));
        
        if (filteredAlerts.length === 0) {
            return '<p class="no-alerts">No alerts match the current filters.</p>';
        }
        
        // Check if groups filter is active - if so, render grouped
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        if (selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups')) {
            return this.renderGroupedAlertsList(filteredAlerts, selectedGroups);
        }
        
        let html = '<ul class="alerts-list">';
        filteredAlerts.forEach(alert => {
            html += this.renderAlertItem(alert);
        });
        html += '</ul>';
        return html;
    },
    
    /**
     * Renders alerts grouped by their group names.
     * Groups are displayed in alphabetical order, each with a header.
     */
    renderGroupedAlertsList(alerts, selectedGroups) {
        // Sort selected groups alphabetically
        const sortedGroups = [...selectedGroups].sort((a, b) => a.localeCompare(b));
        
        // Group alerts by their groups
        const groupedAlerts = {};
        sortedGroups.forEach(group => {
            groupedAlerts[group] = [];
        });
        
        alerts.forEach(alert => {
            const alertGroups = alert.groups || [];
            sortedGroups.forEach(group => {
                if (alertGroups.includes(group)) {
                    groupedAlerts[group].push(alert);
                }
            });
        });
        
        let html = '';
        sortedGroups.forEach(group => {
            const groupAlerts = groupedAlerts[group];
            if (groupAlerts.length > 0) {
                const sortedGroupAlerts = SortManager.applySort(groupAlerts);
                html += '<div class="alert-group">';
                html += '<h3 class="alert-group-header">' + group + '</h3>';
                html += '<ul class="alerts-list">';
                sortedGroupAlerts.forEach(alert => {
                    html += this.renderAlertItem(alert);
                });
                html += '</ul>';
                html += '</div>';
            }
        });
        
        if (!html) {
            return '<p class="no-alerts">No alerts found in the selected groups.</p>';
        }
        
        return html;
    },
    
    /**
     * Renders the spread details modal content.
     */
    renderSpreadItemsList(items) {
        let html = '';
        items.forEach(item => {
            const lowPrice = item.low ? item.low.toLocaleString() : 'N/A';
            const highPrice = item.high ? item.high.toLocaleString() : 'N/A';
            
            html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Low: ' + lowPrice + ' | High: ' + highPrice + '</div>' +
                    '</div>' +
                    '<span class="spread-item-percentage">' + item.spread + '%</span>' +
                    '</li>';
        });
        return html;
    },

    /**
     * Renders spike items list for all-items spike alerts.
     */
    renderSpikeItemsList(items) {
        let html = '';
        items.forEach(item => {
            const baseline = item.baseline ? item.baseline.toLocaleString() : 'N/A';
            const current = item.current ? item.current.toLocaleString() : 'N/A';
            const percent = item.percent_change != null ? item.percent_change.toFixed(2) : 'N/A';
            const pctClass = (item.percent_change != null && item.percent_change < 0)
                ? 'spread-item-percentage negative-change'
                : 'spread-item-percentage';
            html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Baseline: ' + baseline + ' | Current: ' + current + '</div>' +
                    '</div>' +
                    '<span class="' + pctClass + '">' + percent + '%</span>' +
                    '</li>';
        });
        return html;
    },
    
    /**
     * Renders autocomplete suggestions.
     */
    renderSuggestions(items) {
        let html = '';
        items.forEach(item => {
            html += '<div class="suggestion-item" data-id="' + item.id + '" data-name="' + item.name + '">' + item.name + '</div>';
        });
        return html;
    },
    
    /**
     * Updates the entire My Alerts pane with fresh data.
     * Preserves status notifications and filter tags to prevent flashing.
     */
    updateMyAlertsPane(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;

        if (data && data.groups) {
            AlertsState.setAlertGroups(data.groups);
        }
        
        // Cache alerts data for instant filtering/sorting
        if (data && data.alerts) {
            AlertsState.setCachedAlerts(data.alerts);
        }
        
        // Check if any alert checkboxes are checked
        const hasCheckedAlerts = pane.querySelectorAll('.alert-checkbox:checked').length > 0;
        
        // If any checkboxes are checked, skip the update entirely to preserve selection
        if (hasCheckedAlerts) {
            return;
        }
        
        // Check if filter dropdown is currently open/focused
        const filterDropdown = pane.querySelector('.filter-dropdown');
        const isFilterDropdownOpen = filterDropdown && document.activeElement === filterDropdown;
        
        // Check if sort dropdown is currently open/focused
        const sortDropdown = pane.querySelector('.sort-dropdown');
        const isSortDropdownOpen = sortDropdown && document.activeElement === sortDropdown;
        
        // Check if actions dropdown is currently open/focused
        const actionsDropdown = pane.querySelector('.action-dropdown');
        const isActionsDropdownOpen = actionsDropdown && document.activeElement === actionsDropdown;
        
        // If there are active filters, a filter input is open, or any dropdown is open, do selective update
        const hasActiveFilters = AlertsState.activeFilters.size > 0;
        const hasFilterInput = pane.querySelector('.filter-input-container') !== null;
        
        if (hasActiveFilters || hasFilterInput || isFilterDropdownOpen || isSortDropdownOpen || isActionsDropdownOpen) {
            this.updateMyAlertsPaneSelective(data);
            return;
        }
        
        // Preserve any status notifications (e.g., "Alert created")
        const existingStatusNotifications = pane.querySelectorAll('.status-notification');
        let statusHtml = '';
        existingStatusNotifications.forEach(n => {
            const clone = n.cloneNode(true);
            clone.querySelectorAll('.notification-line[data-kind="triggered"]').forEach(l => l.remove());

            const check = clone.cloneNode(true);
            const btn = check.querySelector('.dismiss-btn');
            if (btn) btn.remove();

            const hasContent = check.textContent.trim().length > 0 || check.querySelector('.notification-line');
            if (hasContent) {
                statusHtml += clone.outerHTML;
            }
        });
        
        const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
        const actionsHtml = this.renderActionButtons(data.alerts && data.alerts.length > 0, '');
        
        let alertsHtml = '';
        if (data.alerts && data.alerts.length > 0) {
            alertsHtml = this.renderAlertsList(data.alerts);
        } else if (!data.triggered || data.triggered.length === 0) {
            alertsHtml = this.renderAlertsList([]);
        }
        
        pane.innerHTML = '<div id="triggered-notifications">' + statusHtml + notificationsHtml + '</div>' +
                        actionsHtml + alertsHtml;
        AlertActions.mergeTriggeredNotificationsIntoStatus();
    },
    
    /**
     * Selectively updates parts of the My Alerts pane without touching the action bar.
     * Used when filters are active to prevent filter tags from flashing.
     */
    updateMyAlertsPaneSelective(data) {
        const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
        if (!pane) return;

        if (data && data.groups) {
            AlertsState.setAlertGroups(data.groups);
        }
        
        // Update triggered notifications (preserve status notifications)
        const notificationsContainer = pane.querySelector('#triggered-notifications');
        if (notificationsContainer) {
            const existingStatusNotifications = notificationsContainer.querySelectorAll('.status-notification');
            let statusHtml = '';
            existingStatusNotifications.forEach(n => {
                const clone = n.cloneNode(true);
                clone.querySelectorAll('.notification-line[data-kind="triggered"]').forEach(l => l.remove());

                const check = clone.cloneNode(true);
                const btn = check.querySelector('.dismiss-btn');
                if (btn) btn.remove();

                const hasContent = check.textContent.trim().length > 0 || check.querySelector('.notification-line');
                if (hasContent) {
                    statusHtml += clone.outerHTML;
                }
            });
            const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
            notificationsContainer.innerHTML = statusHtml + notificationsHtml;
            AlertActions.mergeTriggeredNotificationsIntoStatus();
        }
        
        // Update alerts list only - find the container to replace
        const alertsList = pane.querySelector('.alerts-list');
        const alertGroup = pane.querySelector('.alert-group');
        const noAlertsMsg = pane.querySelector('.no-alerts');
        const loadingContainer = pane.querySelector('.loading-container');
        const alertsListContainer = pane.querySelector('#alerts-list-container');
        
        const filteredAlerts = FilterManager.applyFilters(data.alerts || []);
        const sortedAlerts = SortManager.applySort(filteredAlerts);
        
        // Check if groups filter is active
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');
        
        // Build the new HTML
        let newHtml = '';
        if (sortedAlerts.length === 0) {
            newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
        } else if (isGroupedView) {
            newHtml = this.renderGroupedAlertsList(sortedAlerts, selectedGroups);
        } else {
            newHtml = '<ul class="alerts-list">';
            sortedAlerts.forEach(alert => {
                newHtml += this.renderAlertItem(alert);
            });
            newHtml += '</ul>';
        }
        
        // Replace the existing content
        if (alertGroup) {
            // If we have grouped view, replace all groups
            const allGroups = pane.querySelectorAll('.alert-group');
            const firstGroup = allGroups[0];
            allGroups.forEach((g, i) => { if (i > 0) g.remove(); });
            if (firstGroup) {
                firstGroup.outerHTML = newHtml;
            }
        } else if (alertsList) {
            alertsList.outerHTML = newHtml;
        } else if (alertsListContainer) {
            // Replace the loading container with alerts
            alertsListContainer.outerHTML = newHtml;
        } else if (loadingContainer) {
            // Replace standalone loading container
            loadingContainer.outerHTML = newHtml;
        } else if (noAlertsMsg) {
            noAlertsMsg.outerHTML = newHtml;
        }
    }
};


// =============================================================================
// SORT MANAGEMENT
// =============================================================================
const SortManager = {
    options: {
        alphabetically: { id: 'alphabetically', label: 'Alphabetically', defaultOrder: 'asc' },
        lastTriggered: { id: 'lastTriggered', label: 'Last Triggered Time', defaultOrder: 'desc' },
        alertType: { id: 'alertType', label: 'Alert Type', defaultOrder: 'asc' },
        thresholdDistance: { id: 'thresholdDistance', label: 'Threshold Distance', defaultOrder: 'asc' },
        createdDate: { id: 'createdDate', label: 'Created Date', defaultOrder: 'desc' }
    },

    getSortValue(alert, sortKey) {
        switch (sortKey) {
            case 'alphabetically':
                return (alert.text || '').toLowerCase();
            case 'lastTriggered': {
                const ts = alert.last_triggered_at || alert.triggered_at || alert.triggered_time || alert.last_triggered_time;
                return this.parseDateValue(ts);
            }
            case 'alertType':
                return (alert.type || '').toString();
            case 'thresholdDistance':
                return this.getThresholdDistance(alert);
            case 'createdDate':
                return this.parseDateValue(alert.created_at);
            default:
                return null;
        }
    },

    parseDateValue(value) {
        if (!value) return null;
        const ts = Date.parse(value);
        return isNaN(ts) ? null : ts;
    },

    getThresholdDistance(alert) {
        const { alertTypes } = AlertsConfig;
        if ((alert.type === alertTypes.ABOVE || alert.type === alertTypes.BELOW) && alert.price && alert.current_price) {
            const target = Number(alert.price);
            const current = Number(alert.current_price);
            if (!target || !Number.isFinite(current)) return null;
            const percentDiff = ((current - target) / target) * 100;
            return Number.isFinite(percentDiff) ? percentDiff : null;
        }
        if (alert.type === alertTypes.SPREAD && alert.percentage != null) {
            if (alert.spread_percentage != null) {
                return Math.abs(alert.percentage - alert.spread_percentage);
            }
            if (alert.spread_current_percentage != null) {
                return Math.abs(alert.percentage - alert.spread_current_percentage);
            }
        }
        if (alert.type === alertTypes.SPIKE) {
            // Use spike triggered data when available
            if (alert.triggered_data) {
                try {
                    const data = JSON.parse(alert.triggered_data);
                    const baseline = Number(data?.baseline);
                    const current = Number(data?.current ?? alert.current_price);
                    if (Number.isFinite(baseline) && baseline !== 0 && Number.isFinite(current)) {
                        return ((current - baseline) / baseline) * 100;
                    }
                } catch (e) {
                    // ignore parse errors
                }
            }
            // Fallback to current price vs stored baseline in current_price if available (no baseline -> null)
            return null;
        }
        return null;
    },

    applySort(alerts) {
        const sorted = [...alerts];
        const { sortKey, sortOrder } = AlertsState.sorting || {};
        if (!sortKey) {
            return sorted.sort((a, b) => (a.text || '').localeCompare(b.text || ''));
        }

        const direction = sortOrder === 'asc' ? 1 : -1;

        sorted.sort((a, b) => {
            const aVal = this.getSortValue(a, sortKey);
            const bVal = this.getSortValue(b, sortKey);
            const aMissing = aVal === null || aVal === undefined || Number.isNaN(aVal);
            const bMissing = bVal === null || bVal === undefined || Number.isNaN(bVal);

            if (!aMissing || !bMissing) {
                if (aMissing) return 1;
                if (bMissing) return -1;
                if (aVal > bVal) return direction;
                if (aVal < bVal) return -direction;
            }

            return (a.text || '').localeCompare(b.text || '');
        });

        return sorted;
    },

    handleSortSelection(sortKey) {
        if (!sortKey) return;
        const defaultOrder = this.options[sortKey]?.defaultOrder || 'asc';
        
        // If same sort is already active, just toggle order
        if (AlertsState.sorting.sortKey === sortKey) {
            this.toggleSortOrder();
            return;
        }
        
        // Apply new sort with default order
        AlertsState.sorting.sortKey = sortKey;
        AlertsState.sorting.sortOrder = defaultOrder;
        AlertsState.sorting.pendingKey = null;
        this.updateSortIndicator();
        FilterManager.updateAlertsList();
    },

    toggleSortOrder() {
        if (!AlertsState.sorting.sortKey) return;
        AlertsState.sorting.sortOrder = AlertsState.sorting.sortOrder === 'asc' ? 'desc' : 'asc';
        this.updateSortIndicator();
        FilterManager.updateAlertsList();
    },

    updateSortIndicator() {
        const indicator = document.getElementById('sortIndicator');
        const valueEl = document.getElementById('sortIndicatorValue');
        const arrowEl = document.getElementById('sortIndicatorArrow');
        
        // Mobile sort indicator elements
        const mobileRow = document.getElementById('sortIndicatorMobileRow');
        const mobileIndicator = document.getElementById('sortIndicatorMobile');
        const mobileValueEl = document.getElementById('sortIndicatorValueMobile');
        const mobileArrowEl = document.getElementById('sortIndicatorArrowMobile');
        
        if (!indicator) return;
        
        if (AlertsState.sorting.sortKey) {
            const option = this.options[AlertsState.sorting.sortKey];
            const label = option ? option.label : 'Sort';
            const arrow = AlertsState.sorting.sortOrder === 'asc' ? '↑' : '↓';
            
            // Update desktop indicator
            if (valueEl) valueEl.textContent = label;
            if (arrowEl) arrowEl.textContent = arrow;
            indicator.classList.add('active');
            
            // Update mobile indicator
            if (mobileValueEl) mobileValueEl.textContent = label;
            if (mobileArrowEl) mobileArrowEl.textContent = arrow;
            if (mobileIndicator) mobileIndicator.classList.add('active');
        } else {
            indicator.classList.remove('active');
            if (mobileIndicator) mobileIndicator.classList.remove('active');
        }
        
        // Update dropdown active states
        syncSortDropdownState();
    },

    applySortOrder(order) {
        const sortKey = AlertsState.sorting.pendingKey || AlertsState.sorting.sortKey;
        if (!sortKey) return;
        AlertsState.sorting.sortKey = sortKey;
        AlertsState.sorting.sortOrder = order || this.options[sortKey]?.defaultOrder || 'asc';
        AlertsState.sorting.pendingKey = null;
        this.updateSortIndicator();
        FilterManager.updateAlertsList();
        AlertsRefresh.resumeAfterSort();
    },

    clearSort() {
        AlertsState.sorting = { sortKey: null, sortOrder: null, pendingKey: null };
        this.updateSortIndicator();
        FilterManager.updateAlertsList();
    },

    renderSortTag() {
        // No longer using sort tags - using sort indicator instead
        // Keep this method for compatibility but do nothing
    }
};


// =============================================================================
// FILTER MANAGEMENT
// =============================================================================
/**
 * Manages alert list filtering.
 * 
 * Why: Users need to filter alerts by various criteria (triggered status, etc.)
 * to quickly find relevant alerts.
 * 
 * How: Maintains a set of active filter IDs in AlertsState. When rendering,
 * alerts are filtered through all active filter test functions.
 */
const FilterManager = {
    /**
     * Adds a filter to the active filters set and updates the DOM.
     * For input-based filters, shows an input prompt first.
     */
    addFilter(filterId) {
        const filter = AlertsConfig.filters[filterId];
        if (!filter) return;
        if (filterId === 'myGroups' && AlertsState.activeFilters.has(filterId)) {
            this.showFilterModal(filterId);
            return;
        }
        if (AlertsState.activeFilters.has(filterId)) return;
        
        // If filter requires a modal, open it
        if (filter.requiresModal) {
            this.showFilterModal(filterId);
            return;
        }
        
        // If filter requires input, show input UI instead of adding directly
        if (filter.requiresInput) {
            this.showFilterInput(filterId);
            return;
        }
        
        this.activateFilter(filterId);
    },
    
    /**
     * Shows a modal for a modal-based filter.
     */
    showFilterModal(filterId) {
        const dropdown = document.querySelector('#active-filters .filter-dropdown');
        if (dropdown) dropdown.value = '';
        if (filterId === 'myGroups') {
            openGroupsFilterModal();
        } else if (filterId === 'priceRange') {
            openPriceFilterModal();
        }
    },
    
    /**
     * Shows the input UI for an input-based filter.
     */
    showFilterInput(filterId) {
        const filter = AlertsConfig.filters[filterId];
        const container = document.querySelector('#active-filters');
        const dropdown = container ? container.querySelector('.filter-dropdown') : null;
        if (!dropdown) return;
        
        // Create input UI
        const inputHtml = '<span class="filter-input-container" data-filter-id="' + filterId + '">' +
            '<input type="' + (filter.inputType || 'text') + '" class="filter-input" ' +
            'placeholder="' + (filter.inputPlaceholder || 'Enter value...') + '" ' +
            'onkeydown="handleFilterInputKeydown(event, \'' + filterId + '\')">' +
            '<button class="filter-input-confirm" onclick="confirmFilterInput(\'' + filterId + '\')">✓</button>' +
            '<button class="filter-input-cancel" onclick="cancelFilterInput(\'' + filterId + '\')">&times;</button>' +
            '</span>';
        
        dropdown.insertAdjacentHTML('beforebegin', inputHtml);
        
        // Focus the input
        const input = container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"] .filter-input');
        if (input) input.focus();
        
        // Reset dropdown
        dropdown.value = '';
    },
    
    /**
     * Confirms the input for an input-based filter and activates it.
     */
    confirmFilterInput(filterId) {
        const container = document.querySelector('#active-filters');
        const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
        const input = inputContainer ? inputContainer.querySelector('.filter-input') : null;
        
        if (!input || !input.value.trim()) {
            this.cancelFilterInput(filterId);
            return;
        }
        
        const value = input.value.trim();
        AlertsState.setFilterValue(filterId, value);
        
        // Remove input container
        inputContainer.remove();
        
        // Activate the filter with the value displayed
        this.activateFilter(filterId, value);
    },
    
    /**
     * Cancels the input for an input-based filter.
     */
    cancelFilterInput(filterId) {
        const container = document.querySelector('#active-filters');
        const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
        if (inputContainer) {
            inputContainer.remove();
        }
    },
    
    /**
     * Activates a filter and adds its tag to the DOM.
     * @param {string} filterId - The filter ID
     * @param {string} displayValue - Optional value to display in the tag
     */
    activateFilter(filterId, displayValue) {
        AlertsState.activeFilters.add(filterId);
        
        // Add filter tag to DOM
        const filter = AlertsConfig.filters[filterId];
        const container = document.querySelector('#active-filters');
        const dropdown = container ? container.querySelector('.filter-dropdown') : null;
        const tagContainer = document.querySelector('.alert-indicators .filter-tags');
        if (dropdown) {
            // Format the label based on whether it's a numeric value or not
            let label;
            if (displayValue) {
                const numValue = parseInt(displayValue);
                if (!isNaN(numValue) && filter.requiresInput) {
                    label = filter.label + ': ' + numValue.toLocaleString();
                } else {
                    label = filter.label + ': ' + displayValue;
                }
            } else {
                label = filter.label;
            }
            const tagHtml = '<span class="filter-tag" data-filter-id="' + filterId + '">' + label + 
                    '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                    '</span>';
            if (tagContainer) {
                tagContainer.insertAdjacentHTML('beforeend', tagHtml);
            } else {
                dropdown.insertAdjacentHTML('beforebegin', tagHtml);
            }
            
            // Remove the option from dropdown
            const option = dropdown.querySelector('option[value="' + filterId + '"]');
            if (option && filterId !== 'myGroups') option.remove();
        }
        
        // Only update the alerts list, not the entire pane
        this.updateAlertsList();
    },
    
    /**
     * Removes a filter from the active filters set.
     */
    removeFilter(filterId) {
        AlertsState.activeFilters.delete(filterId);
        AlertsState.filterValues[filterId] = null; // Clear any stored value
        
        const tagEl = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
        if (tagEl) tagEl.remove();
        
        // Re-add the option to dropdown
        const filter = AlertsConfig.filters[filterId];
        const dropdown = document.querySelector('#active-filters .filter-dropdown');
        if (dropdown && filter) {
            const existingOption = dropdown.querySelector('option[value="' + filterId + '"]');
            if (!existingOption) {
                const option = document.createElement('option');
                option.value = filterId;
                option.textContent = filter.label;
                dropdown.appendChild(option);
            }
        }
        
        // Only update the alerts list, not the entire pane
        this.updateAlertsList();
    },
    
    /**
     * Updates just the alerts list based on current filters.
     * Uses cached alerts data for instant response - no network request.
     */
    updateAlertsList() {
        const alerts = AlertsState.getCachedAlerts();
        
        const pane = document.querySelector('#my-alerts');
        if (!pane) return;

        const alertsList = pane.querySelector('.alerts-list');
        const alertGroup = pane.querySelector('.alert-group');
        const noAlertsMsg = pane.querySelector('.no-alerts');
        const filteredAlerts = this.applyFilters(alerts);
        const sortedAlerts = SortManager.applySort(filteredAlerts);
        const selectedGroups = AlertsState.getFilterValue('myGroups');
        const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');

        let newHtml = '';
        if (sortedAlerts.length === 0) {
            newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
        } else if (isGroupedView) {
            newHtml = AlertsUI.renderGroupedAlertsList(sortedAlerts, selectedGroups);
        } else {
            newHtml = '<ul class="alerts-list">';
            sortedAlerts.forEach(alert => {
                newHtml += AlertsUI.renderAlertItem(alert);
            });
            newHtml += '</ul>';
        }

        if (alertGroup) {
            const allGroups = pane.querySelectorAll('.alert-group');
            const firstGroup = allGroups[0];
            allGroups.forEach((g, i) => { if (i > 0) g.remove(); });
            if (firstGroup) {
                firstGroup.outerHTML = newHtml;
            }
        } else if (alertsList) {
            alertsList.outerHTML = newHtml;
        } else if (noAlertsMsg) {
            noAlertsMsg.outerHTML = newHtml;
        }
    },
    
    /**
     * Checks if a filter is currently active.
     */
    isActive(filterId) {
        return AlertsState.activeFilters.has(filterId);
    },
    
    /**
     * Applies all active filters to an array of alerts.
     * Returns only alerts that pass ALL active filter tests.
     */
    applyFilters(alerts) {
        let result = alerts;
        
        // Apply search filter first
        if (AlertsState.searchQuery && AlertsState.searchQuery.trim()) {
            const query = AlertsState.searchQuery.toLowerCase().trim();
            result = result.filter(alert => {
                const text = (alert.text || '').toLowerCase();
                return text.includes(query);
            });
        }
        
        // Apply active filters
        if (AlertsState.activeFilters.size === 0) {
            return result;
        }
        
        return result.filter(alert => {
            for (const filterId of AlertsState.activeFilters) {
                const filter = AlertsConfig.filters[filterId];
                if (!filter) continue;
                
                // Use testWithValue for input-based or modal-based filters
                if ((filter.requiresInput || filter.requiresModal) && filter.testWithValue) {
                    const value = AlertsState.getFilterValue(filterId);
                    if (!filter.testWithValue(alert, value)) {
                        return false;
                    }
                } else if (filter.test && !filter.test(alert)) {
                    return false;
                }
            }
            return true;
        });
    }
};


// =============================================================================
// FORM MANAGEMENT
// =============================================================================
/**
 * Manages form field visibility and state for create/edit forms.
 * 
 * Why: Different alert types require different fields. This manager handles
 * showing/hiding the appropriate fields based on user selections.
 * 
 * How: Uses configuration-driven approach to map alert types to visible fields.
 */
const FormManager = {
    /**
     * Updates form field visibility based on selected alert type.
     * 
     * @param {string} formType - 'create' for create form
     */
    handleAlertTypeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const alertType = document.querySelector(selectors.alertType).value;
        const groups = selectors.groups;
        
        // Get all form group elements
        const elements = {
            spreadScope: document.querySelector(groups.spreadScope),
            numberItems: document.querySelector(groups.numberItems),
            itemName: document.querySelector(groups.itemName),
            price: document.querySelector(groups.price),
            reference: document.querySelector(groups.reference),
            percentage: document.querySelector(groups.percentage),
            timeFrame: document.querySelector(groups.timeFrame),
            direction: document.querySelector(groups.direction),
            minPrice: document.querySelector(groups.minPrice),
            maxPrice: document.querySelector(groups.maxPrice),
            minConsecutiveMoves: document.querySelector(groups.minConsecutiveMoves),
            minMovePercentage: document.querySelector(groups.minMovePercentage),
            volatilityBuffer: document.querySelector(groups.volatilityBuffer),
            volatilityMultiplier: document.querySelector(groups.volatilityMultiplier),
            minVolume: document.querySelector(groups.minVolume),
            sustainedScope: document.querySelector(groups.sustainedScope),
            sustainedItems: document.querySelector(groups.sustainedItems),
            pressureStrength: document.querySelector(groups.pressureStrength),
            pressureSpread: document.querySelector(groups.pressureSpread)
        };
        
        // Helper to hide all sustained move fields
        const hideSustainedFields = () => {
            if (elements.minConsecutiveMoves) elements.minConsecutiveMoves.style.display = 'none';
            if (elements.minMovePercentage) elements.minMovePercentage.style.display = 'none';
            if (elements.volatilityBuffer) elements.volatilityBuffer.style.display = 'none';
            if (elements.volatilityMultiplier) elements.volatilityMultiplier.style.display = 'none';
            if (elements.minVolume) elements.minVolume.style.display = 'none';
            if (elements.sustainedScope) elements.sustainedScope.style.display = 'none';
            if (elements.sustainedItems) elements.sustainedItems.style.display = 'none';
            if (elements.pressureStrength) elements.pressureStrength.style.display = 'none';
            if (elements.pressureSpread) elements.pressureSpread.style.display = 'none';
        };
        
        if (alertType === AlertsConfig.alertTypes.SPREAD) {
            // Spread alerts: show spread-specific fields
            elements.spreadScope.style.display = 'block';
            if (elements.numberItems) elements.numberItems.style.display = 'none';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'none';
            elements.percentage.style.display = 'block';
            elements.timeFrame.style.display = 'none';
            elements.direction.style.display = 'none';
            hideSustainedFields();
            
            // Let scope change handler determine remaining visibility
            this.handleSpreadScopeChange(formType);
        } else if (alertType === AlertsConfig.alertTypes.SPIKE) {
            // Spike alerts: single item, show percentage + time frame, hide spread fields
            elements.spreadScope.style.display = 'none';
            if (elements.numberItems) elements.numberItems.style.display = 'block';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'block';
            elements.percentage.style.display = 'block';
            elements.timeFrame.style.display = 'block';
            elements.direction.style.display = 'block';
            hideSustainedFields();
            // Spike uses min/max only when all items selected; handled in handleSpikeScopeChange
            this.handleSpikeScopeChange(formType);
        } else if (alertType === AlertsConfig.alertTypes.SUSTAINED) {
            // Sustained Move alerts: scope selector + time frame + direction + sustained-specific fields
            elements.spreadScope.style.display = 'none';
            if (elements.numberItems) elements.numberItems.style.display = 'none';
            elements.itemName.style.display = 'none';
            elements.price.style.display = 'none';
            elements.reference.style.display = 'none';
            elements.percentage.style.display = 'none';
            elements.timeFrame.style.display = 'block';
            elements.direction.style.display = 'block';
            
            // Show sustained scope selector
            if (elements.sustainedScope) elements.sustainedScope.style.display = 'block';
            
            // Show sustained-specific fields
            if (elements.minConsecutiveMoves) elements.minConsecutiveMoves.style.display = 'block';
            if (elements.minMovePercentage) elements.minMovePercentage.style.display = 'block';
            if (elements.volatilityBuffer) elements.volatilityBuffer.style.display = 'block';
            if (elements.volatilityMultiplier) elements.volatilityMultiplier.style.display = 'block';
            if (elements.minVolume) elements.minVolume.style.display = 'block';
            
            // Show pressure filter fields
            if (elements.pressureStrength) elements.pressureStrength.style.display = 'block';
            if (elements.pressureSpread) elements.pressureSpread.style.display = 'block';
            
            // Let scope change handler determine item selector vs min/max price
            this.handleSustainedScopeChange(formType);
        } else {
            // Above/Below alerts: show threshold fields
            elements.spreadScope.style.display = 'none';
            if (elements.numberItems) elements.numberItems.style.display = 'none';
            elements.itemName.style.display = 'block';
            elements.price.style.display = 'block';
            elements.reference.style.display = 'block';
            elements.percentage.style.display = 'none';
            elements.timeFrame.style.display = 'none';
            elements.direction.style.display = 'none';
            elements.minPrice.style.display = 'none';
            elements.maxPrice.style.display = 'none';
            hideSustainedFields();
            
            // Reset is_all_items
            document.querySelector(selectors.isAllItems).value = 'false';
        }

        const directionInput = document.querySelector(selectors.direction);
        if (directionInput && elements.direction.style.display === 'none') {
            directionInput.value = 'both';
        }
    },
    
    /**
     * Updates form fields based on spread scope selection.
     * 
     * @param {string} formType - 'create' for create form
     */
    handleSpreadScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const spreadScope = document.querySelector(selectors.spreadScope).value;
        const groups = selectors.groups;
        
        const itemNameGroup = document.querySelector(groups.itemName);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        if (spreadScope === 'all') {
            itemNameGroup.style.display = 'none';
            minPriceGroup.style.display = 'block';
            maxPriceGroup.style.display = 'block';
            isAllItemsInput.value = 'true';
        } else {
            itemNameGroup.style.display = 'block';
            minPriceGroup.style.display = 'none';
            maxPriceGroup.style.display = 'none';
            isAllItemsInput.value = 'false';
        }
    },
    
    /**
     * Updates form fields based on spike number-of-items selection.
     */
    handleSpikeScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const numberItemsSelect = document.querySelector(selectors.numberItems);
        const groups = selectors.groups;
        const itemNameGroup = document.querySelector(groups.itemName);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        const selection = numberItemsSelect ? numberItemsSelect.value : 'one';
        const isAll = selection === 'all';
        if (itemNameGroup) itemNameGroup.style.display = isAll ? 'none' : 'block';
        if (minPriceGroup) minPriceGroup.style.display = isAll ? 'block' : 'none';
        if (maxPriceGroup) maxPriceGroup.style.display = isAll ? 'block' : 'none';
        if (isAllItemsInput) isAllItemsInput.value = isAll ? 'true' : 'false';
    },
    
    /**
     * Updates form fields based on sustained move scope selection.
     */
    handleSustainedScopeChange(formType) {
        const selectors = AlertsConfig.selectors[formType];
        const sustainedScopeSelect = document.querySelector(selectors.sustainedScope);
        const groups = selectors.groups;
        const sustainedItemsGroup = document.querySelector(groups.sustainedItems);
        const minPriceGroup = document.querySelector(groups.minPrice);
        const maxPriceGroup = document.querySelector(groups.maxPrice);
        const isAllItemsInput = document.querySelector(selectors.isAllItems);
        
        const selection = sustainedScopeSelect ? sustainedScopeSelect.value : 'specific';
        const isAll = selection === 'all';
        
        if (sustainedItemsGroup) sustainedItemsGroup.style.display = isAll ? 'none' : 'block';
        if (minPriceGroup) minPriceGroup.style.display = isAll ? 'block' : 'none';
        if (maxPriceGroup) maxPriceGroup.style.display = isAll ? 'block' : 'none';
        if (isAllItemsInput) isAllItemsInput.value = isAll ? 'true' : 'false';
    }
};


// =============================================================================
// MODAL MANAGEMENT
// =============================================================================
/**
 * Controls modal dialogs (spread details modal and spike details modal).
 * 
 * Why: Modals have common behavior that should be handled consistently.
 */
const ModalManager = {
    /**
     * Opens spread details modal with matching items.
     */
    showSpreadDetails(alertId) {
        const dataStr = AlertsState.getSpreadData(alertId);
        
        if (!dataStr) {
            console.error('No spread data found for alert', alertId);
            return;
        }
        
        const data = JSON.parse(dataStr);
        const list = document.querySelector(AlertsConfig.selectors.spreadItemsList);
        list.innerHTML = AlertsUI.renderSpreadItemsList(data);
        
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'flex';
    },
    
    /**
     * Closes the spread details modal.
     */
    closeSpreadModal() {
        document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'none';
    },

    /**
     * Opens spike details modal with matching items.
     */
    showSpikeDetails(alertId) {
        const dataStr = AlertsState.getSpikeData(alertId);
        
        if (!dataStr) {
            console.error('No spike data found for alert', alertId);
            return;
        }
        
        let data = [];
        try {
            data = JSON.parse(dataStr);
        } catch (e) {
            console.error('Failed to parse spike data', e);
            return;
        }
        const list = document.getElementById('spike-items-list');
        if (list) {
            list.innerHTML = AlertsUI.renderSpikeItemsList(data);
        }
        
        document.getElementById('spike-modal').style.display = 'flex';
    },

    /**
     * Closes the spike details modal.
     */
    closeSpikeModal() {
        const modal = document.getElementById('spike-modal');
        if (modal) modal.style.display = 'none';
    }
};


// =============================================================================
// ALERT ACTIONS
// =============================================================================
/**
 * Handles user actions on alerts (dismiss, delete, save).
 */
const AlertActions = {
    /**
     * Handles selection from the actions dropdown.
     */
    handleAction(action) {
        if (action === 'delete') {
            this.confirmDelete();
        } else if (action === 'group') {
            GroupManager.open();
        }
    },

    /**
     * Dismisses a triggered alert notification.
     */
    async dismiss(alertId) {
        // Animate out immediately for responsive feedback
        const banner = document.querySelector('.triggered-notification[data-alert-id="' + alertId + '"]');
        if (banner) {
            banner.classList.add('dismissing');
            setTimeout(() => banner.remove(), 300);
        }

        const line = document.querySelector('.status-notification .notification-line[data-kind="triggered"][data-alert-id="' + alertId + '"]');
        if (line) {
            const box = line.closest('.status-notification');
            line.remove();
            if (box) {
                const hasLines = box.querySelector('.notification-line');
                // If no lines remain (status or triggered), remove box.
                if (!hasLines) {
                    box.classList.add('dismissing');
                    setTimeout(() => box.remove(), 300);
                }
            }
        }

        await AlertsAPI.dismissAlert(alertId);
    },
    
    /**
     * Confirms deletion of selected alerts.
     * Opens the delete confirmation modal instead of browser confirm.
     */
    confirmDelete() {
        const selectedItems = [];
        const selectedIds = [];
        
        document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
            const alertItem = cb.closest('.alert-item');
            if (alertItem) {
                selectedItems.push(alertItem);
                selectedIds.push(alertItem.dataset.alertId);
            }
        });
        
        if (selectedIds.length === 0) {
            AlertActions.showErrorNotification('Please select at least one alert to delete.');
            return;
        }
        
        // Store selected items and IDs for later use
        this.pendingDeleteItems = selectedItems;
        this.pendingDeleteIds = selectedIds;
        
        // Update modal message
        const message = document.getElementById('delete-confirm-message');
        if (message) {
            const count = selectedIds.length;
            message.textContent = 'Are you sure you want to delete ' + count + ' selected alert' + (count > 1 ? 's' : '') + '?';
        }
        
        // Show modal
        document.getElementById('delete-confirm-modal').style.display = 'flex';
    },
    
    /**
     * Executes the delete after modal confirmation.
     */
    async executeDelete() {
        const selectedItems = this.pendingDeleteItems || [];
        const selectedIds = this.pendingDeleteIds || [];
        
        if (selectedIds.length === 0) {
            closeDeleteConfirmModal();
            return;
        }
        
        // Close modal first
        closeDeleteConfirmModal();
        
        // Animate items out
        selectedItems.forEach(item => {
            item.classList.add('deleting');
        });
        
        // Wait for animation to complete (300ms matches CSS transition)
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Call API to delete
        const success = await AlertsAPI.deleteAlerts(selectedIds);
        if (success) {
            this.clearSelections();
            // Show status notification
            this.showStatusNotification('Alert' + (selectedIds.length > 1 ? 's' : '') + ' deleted');
            await AlertsRefresh.refresh();
        } else {
            selectedItems.forEach(item => item.classList.remove('deleting'));
        }
        
        // Clear pending state
        this.pendingDeleteItems = null;
        this.pendingDeleteIds = null;
    },

    /**
     * Clears any selected checkboxes.
     */
    clearSelections() {
        document.querySelectorAll('.alert-checkbox').forEach(cb => cb.checked = false);
    },
    
    /**
     * Shows a status notification at the top of the alerts pane.
     * 
     * What: Creates and displays a dismissible status message
     * Why: Provides user feedback for actions like delete
     * How: Inserts notification HTML into triggered-notifications container
     */
    clearStatusNotifications() {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;

        container.querySelectorAll('.status-notification').forEach(box => {
            // Remove only status lines; keep triggered lines.
            box.querySelectorAll('.notification-line[data-kind="status"]').forEach(l => l.remove());

            // Remove legacy plain text (server messages) and <br> (treat as status).
            Array.from(box.childNodes).forEach(node => {
                if (node.nodeType === 3 && node.textContent.trim()) node.remove();
                if (node.nodeType === 1 && node.tagName === 'BR') node.remove();
            });

            const hasTriggered = box.querySelector('.notification-line[data-kind="triggered"]');
            if (!hasTriggered) {
                box.remove();
            }
        });
    },

    normalizeStatusNotifications() {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;

        const existingAll = container.querySelectorAll('.status-notification');
        if (existingAll.length === 0) return;

        const toStatusLine = (box, message) => {
            const btn = box.querySelector('.dismiss-btn');
            const line = document.createElement('div');
            line.className = 'notification-line';
            line.dataset.kind = 'status';
            const span = document.createElement('span');
            span.textContent = message;
            line.appendChild(span);
            if (btn) box.insertBefore(line, btn);
            else box.appendChild(line);
        };

        // Convert any legacy plain-text status messages into status lines.
        existingAll.forEach(box => {
            const plainText = Array.from(box.childNodes)
                .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn')))
                .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('notification-line')))
                .filter(node => node.nodeType === 3 || (node.nodeType === 1 && node.tagName === 'BR'))
                .map(node => (node.textContent || '').trim())
                .filter(Boolean)
                .join(' ');

            // Remove those legacy nodes.
            Array.from(box.childNodes).forEach(node => {
                const isBtn = node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn');
                const isLine = node.nodeType === 1 && node.classList && node.classList.contains('notification-line');
                if (isBtn || isLine) return;
                if (node.nodeType === 3 || (node.nodeType === 1 && node.tagName === 'BR')) {
                    node.remove();
                }
            });

            if (plainText) {
                toStatusLine(box, plainText);
            }
        });

        if (existingAll.length <= 1) return;

        const first = existingAll[0];
        const firstBtn = first.querySelector('.dismiss-btn');

        for (let i = 1; i < existingAll.length; i++) {
            const n = existingAll[i];
            // Move status lines into the first box.
            n.querySelectorAll('.notification-line[data-kind="status"]').forEach(line => {
                if (firstBtn) first.insertBefore(line.cloneNode(true), firstBtn);
                else first.appendChild(line.cloneNode(true));
            });
            n.remove();
        }
    },

    mergeTriggeredNotificationsIntoStatus() {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;

        this.normalizeStatusNotifications();

        const triggered = Array.from(container.querySelectorAll('.triggered-notification:not(.status-notification)'));
        if (triggered.length === 0) return;

        let statusBox = container.querySelector('.status-notification');
        if (!statusBox) {
            statusBox = document.createElement('div');
            statusBox.className = 'triggered-notification status-notification';

            const btn = document.createElement('button');
            btn.className = 'dismiss-btn';
            btn.innerHTML = '&times;';
            btn.setAttribute('onclick', 'dismissStatusNotification(this)');
            statusBox.appendChild(btn);

            container.insertBefore(statusBox, container.firstChild);
        }

        const globalBtn = statusBox.querySelector('.dismiss-btn');

        triggered.forEach(n => {
            const alertId = n.dataset.alertId;
            const span = n.querySelector('span');

            const line = document.createElement('div');
            line.className = 'notification-line';
            line.dataset.kind = 'triggered';
            if (alertId) line.dataset.alertId = alertId;

            if (span) {
                line.appendChild(span.cloneNode(true));
            } else {
                const msg = Array.from(n.childNodes)
                    .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn')))
                    .map(node => (node.textContent || '').trim())
                    .filter(Boolean)
                    .join(' ');
                const s = document.createElement('span');
                s.textContent = msg;
                line.appendChild(s);
            }


            if (globalBtn) statusBox.insertBefore(line, globalBtn);
            else statusBox.appendChild(line);

            n.remove();
        });
    },

    showStatusNotification(message) {
        const container = document.getElementById('triggered-notifications');
        if (!container) return;

        this.normalizeStatusNotifications();

        let statusBox = container.querySelector('.status-notification');
        if (!statusBox) {
            statusBox = document.createElement('div');
            statusBox.className = 'triggered-notification status-notification';

            const btn = document.createElement('button');
            btn.className = 'dismiss-btn';
            btn.innerHTML = '&times;';
            btn.setAttribute('onclick', 'dismissStatusNotification(this)');
            statusBox.appendChild(btn);

            container.insertBefore(statusBox, container.firstChild);
        }

        const globalBtn = statusBox.querySelector('.dismiss-btn');

        const line = document.createElement('div');
        line.className = 'notification-line';
        line.dataset.kind = 'status';
        const span = document.createElement('span');
        span.textContent = message;
        line.appendChild(span);

        if (globalBtn) statusBox.insertBefore(line, globalBtn);
        else statusBox.appendChild(line);

        // Keep triggered + status in one visible box.
        this.mergeTriggeredNotificationsIntoStatus();
    },
    
    /**
     * Shows an error notification above the actions area.
     * @param {string} message - The error message to display
     */
    showErrorNotification(message) {
        const actionsWrapper = document.querySelector('.alert-actions-wrapper');
        if (!actionsWrapper) return;
        
        // Pause refresh while error notification is shown
        AlertsRefresh.errorNotificationActive = true;
        
        // Find or create error container above actions
        let errorContainer = actionsWrapper.querySelector('.actions-error-container');
        if (!errorContainer) {
            errorContainer = document.createElement('div');
            errorContainer.className = 'actions-error-container';
            actionsWrapper.insertBefore(errorContainer, actionsWrapper.firstChild);
        }
        
        // Remove any existing error notifications
        errorContainer.querySelectorAll('.triggered-notification.error-notification').forEach(n => n.remove());
        
        // Create error notification
        const notification = document.createElement('div');
        notification.className = 'triggered-notification error-notification';
        notification.innerHTML = message + '<button class="dismiss-btn" type="button">&times;</button>';
        
        // Function to clear error state
        const clearErrorState = () => {
            AlertsRefresh.errorNotificationActive = false;
        };
        
        // Add click handler for dismiss button
        const dismissBtn = notification.querySelector('.dismiss-btn');
        if (dismissBtn) {
            dismissBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                notification.classList.add('dismissing');
                setTimeout(() => {
                    notification.remove();
                    clearErrorState();
                }, 300);
            });
        }
        
        errorContainer.appendChild(notification);
        
        // Auto-dismiss after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.add('dismissing');
                setTimeout(() => {
                    notification.remove();
                    clearErrorState();
                }, 300);
            }
        }, 5000);
    }
};


// =============================================================================
// GROUP MANAGEMENT
// =============================================================================
/**
 * Handles organizing alerts into groups.
 */
const GroupManager = {
    escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&#39;');
    },

    open() {
        const selectedIds = this.getSelectedAlertIds();
        if (selectedIds.length === 0) {
            AlertActions.showErrorNotification('Please select at least one alert first.');
            return;
        }

        this.renderExistingGroups();
        this.clearNewGroupInput();
        const modal = document.querySelector(AlertsConfig.selectors.groupModal);
        if (modal) {
            modal.style.display = 'flex';
        }
    },

    close() {
        const modal = document.querySelector(AlertsConfig.selectors.groupModal);
        if (modal) {
            modal.style.display = 'none';
        }
    },

    clearNewGroupInput() {
        const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
        if (input) input.value = '';
    },

    renderExistingGroups() {
        const list = document.querySelector(AlertsConfig.selectors.groupList);
        if (!list) return;

        const groups = AlertsState.getAlertGroups();
        if (!groups || groups.length === 0) {
            list.innerHTML = '<p class="no-alerts">No groups yet. Add a new one below.</p>';
            return;
        }

        list.innerHTML = '';
        groups.forEach(name => {
            const pill = document.createElement('span');
            pill.className = 'group-pill';
            pill.dataset.group = name;
            pill.textContent = name;
            pill.onclick = function() {
                this.classList.toggle('selected');
            };
            list.appendChild(pill);
        });
    },

    getSelectedAlertIds() {
        const ids = [];
        document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
            const item = cb.closest('.alert-item');
            if (item && item.dataset.alertId) {
                ids.push(item.dataset.alertId);
            }
        });
        return ids;
    },

    parseNewGroups() {
        const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
        if (!input || !input.value.trim()) return [];
        return input.value.split(',')
            .map(g => g.trim())
            .filter(g => g.length > 0);
    },

    getSelectedGroups() {
        const selected = [];
        document.querySelectorAll(AlertsConfig.selectors.groupList + ' .group-pill.selected')
            .forEach(pill => selected.push(pill.dataset.group));
        return selected;
    },

    async save() {
        const alertIds = this.getSelectedAlertIds();
        if (alertIds.length === 0) {
            AlertActions.showErrorNotification('Please select at least one alert first.');
            return;
        }

        const existingGroups = this.getSelectedGroups();
        const newGroups = this.parseNewGroups();

        if (existingGroups.length === 0 && newGroups.length === 0) {
            AlertActions.showErrorNotification('Please choose an existing group or add a new one.');
            return;
        }

        const success = await AlertsAPI.groupAlerts(alertIds, existingGroups, newGroups);
        if (success) {
            AlertActions.showStatusNotification('Alert' + (alertIds.length > 1 ? 's' : '') + ' organized into group(s)');
            this.close();
            AlertActions.clearSelections();
            await AlertsRefresh.refresh();
        }
    },

    async deleteSelectedGroups() {
        const selectedGroups = this.getSelectedGroups();
        if (selectedGroups.length === 0) {
            AlertActions.showErrorNotification('Please select at least one group to delete.');
            return;
        }

        const confirmed = window.confirm('Delete selected group' + (selectedGroups.length > 1 ? 's' : '') + '? This will remove them from all alerts.');
        if (!confirmed) return;

        const success = await AlertsAPI.deleteGroups(selectedGroups);
        if (success) {
            AlertActions.showStatusNotification('Group' + (selectedGroups.length > 1 ? 's' : '') + ' deleted');
            // Optimistically remove from local state to reflect immediately
            const remaining = AlertsState.getAlertGroups().filter(g => !selectedGroups.includes(g));
            AlertsState.setAlertGroups(remaining);
            await AlertsRefresh.refresh();
            this.renderExistingGroups();
        } else {
            AlertActions.showErrorNotification('Failed to delete selected group(s). Please try again.');
        }
    }
};


// =============================================================================
// AUTOCOMPLETE MANAGEMENT
// =============================================================================
/**
 * Manages item search autocomplete functionality.
 * 
 * Why: Both create and edit forms need autocomplete. This manager provides
 * reusable autocomplete logic for any item name input.
 */
const AutocompleteManager = {
    /**
     * Tracks the currently selected suggestion index for each dropdown.
     * Keys are dropdown element IDs, values are the selected index (-1 = none).
     */
    selectedIndex: {},
    
    /**
     * Sets up autocomplete for an input/dropdown pair with full keyboard support.
     * 
     * What: Enables item search with suggestions dropdown
     * Why: Users need to find items by name, and keyboard navigation improves UX
     * How: Listens for input changes to fetch suggestions, and keydown events
     *      for arrow key navigation, Enter to select, and Escape to close
     * 
     * @param {HTMLElement} input - The text input element
     * @param {HTMLElement} hiddenInput - Hidden input to store selected item ID
     * @param {HTMLElement} dropdown - The suggestions dropdown container
     */
    setup(input, hiddenInput, dropdown) {
        if (!input || !dropdown) return;
        
        const dropdownId = dropdown.id;
        this.selectedIndex[dropdownId] = -1;
        
        /**
         * Updates visual highlighting of the currently selected suggestion.
         * Adds 'selected' class to the active item and scrolls it into view.
         */
        const updateSelection = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                if (index === this.selectedIndex[dropdownId]) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        };
        
        /**
         * Selects the currently highlighted suggestion.
         * Sets the input value and hidden ID, then closes the dropdown.
         */
        const selectCurrentItem = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            const index = this.selectedIndex[dropdownId];
            
            if (index >= 0 && index < items.length) {
                const selectedItem = items[index];
                input.value = selectedItem.dataset.name;
                hiddenInput.value = selectedItem.dataset.id;
                dropdown.style.display = 'none';
                this.selectedIndex[dropdownId] = -1;
            }
        };
        
        /**
         * Resets the selection index when new suggestions are loaded.
         */
        const resetSelection = () => {
            this.selectedIndex[dropdownId] = -1;
        };
        
        // Handle input changes - fetch suggestions
        input.addEventListener('input', async () => {
            const query = input.value;
            
            if (query.length < AlertsConfig.timing.minSearchLength) {
                dropdown.style.display = 'none';
                resetSelection();
                return;
            }
            
            const items = await AlertsAPI.searchItems(query);
            
            if (items.length > 0) {
                dropdown.innerHTML = AlertsUI.renderSuggestions(items);
                dropdown.style.display = 'block';
                resetSelection();
            } else {
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle keyboard navigation
        input.addEventListener('keydown', (e) => {
            // Only handle keys when dropdown is visible
            if (dropdown.style.display === 'none') return;
            
            const items = dropdown.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            switch (e.key) {
                case 'ArrowDown':
                    // Move selection down, wrap to top if at bottom
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        (this.selectedIndex[dropdownId] + 1) % items.length;
                    updateSelection();
                    break;
                    
                case 'ArrowUp':
                    // Move selection up, wrap to bottom if at top
                    e.preventDefault();
                    this.selectedIndex[dropdownId] = 
                        this.selectedIndex[dropdownId] <= 0 
                            ? items.length - 1 
                            : this.selectedIndex[dropdownId] - 1;
                    updateSelection();
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Tab moves selection up like ArrowUp
                        this.selectedIndex[dropdownId] = 
                            this.selectedIndex[dropdownId] <= 0 
                                ? items.length - 1 
                                : this.selectedIndex[dropdownId] - 1;
                    } else {
                        // Tab moves selection down like ArrowDown
                        this.selectedIndex[dropdownId] = 
                            (this.selectedIndex[dropdownId] + 1) % items.length;
                    }
                    updateSelection();
                    break;
                    
                case 'Enter':
                    // Enter selects current item
                    if (this.selectedIndex[dropdownId] >= 0) {
                        e.preventDefault();
                        selectCurrentItem();
                    }
                    break;
                    
                case 'Escape':
                    // Escape closes dropdown without selecting
                    e.preventDefault();
                    dropdown.style.display = 'none';
                    resetSelection();
                    break;
            }
        });
        
        // Handle mouse click on suggestion
        dropdown.addEventListener('click', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                input.value = e.target.dataset.name;
                hiddenInput.value = e.target.dataset.id;
                dropdown.style.display = 'none';
                resetSelection();
            }
        });
        
        // Handle mouse hover to update selection
        dropdown.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (item === e.target) {
                        this.selectedIndex[dropdownId] = index;
                    }
                });
                updateSelection();
            }
        });
    },
    
    /**
     * Initializes autocomplete for both forms.
     */
    init() {
        // Create form autocomplete
        const createSelectors = AlertsConfig.selectors.create;
        this.setup(
            document.querySelector(createSelectors.itemName),
            document.querySelector(createSelectors.itemId),
            document.querySelector(createSelectors.suggestions)
        );
    }
};


// =============================================================================
// MULTI-ITEM SELECTOR
// =============================================================================
/**
 * Manages multi-item selection for sustained move alerts.
 * Allows adding multiple items via autocomplete with chip-style display.
 */
const MultiItemSelector = {
    selectedItems: [],  // Array of {id, name} objects
    selectedIndex: -1,
    
    /**
     * Initializes the multi-item selector for sustained move alerts.
     */
    init() {
        const input = document.querySelector(AlertsConfig.selectors.create.sustainedItemInput);
        const dropdown = document.querySelector(AlertsConfig.selectors.create.sustainedItemSuggestions);
        const hiddenInput = document.querySelector(AlertsConfig.selectors.create.sustainedItemIds);
        const container = document.querySelector(AlertsConfig.selectors.create.selectedItemsContainer);
        
        if (!input || !dropdown || !hiddenInput || !container) return;
        
        this.selectedItems = [];
        this.selectedIndex = -1;
        
        const updateHiddenInput = () => {
            hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
        };
        
        const updateSelection = () => {
            const items = dropdown.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                if (index === this.selectedIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        };
        
        const addItem = (id, name) => {
            // Check if already selected
            if (this.selectedItems.some(item => item.id === id)) {
                return;
            }
            
            this.selectedItems.push({ id, name });
            updateHiddenInput();
            this.renderChips(container);
            input.value = '';
            dropdown.style.display = 'none';
            this.selectedIndex = -1;
        };
        
        const removeItem = (id) => {
            this.selectedItems = this.selectedItems.filter(item => item.id !== id);
            updateHiddenInput();
            this.renderChips(container);
        };
        
        // Handle input changes - fetch suggestions
        input.addEventListener('input', async () => {
            const query = input.value;
            
            if (query.length < AlertsConfig.timing.minSearchLength) {
                dropdown.style.display = 'none';
                this.selectedIndex = -1;
                return;
            }
            
            const items = await AlertsAPI.searchItems(query);
            
            // Filter out already selected items
            const filteredItems = items.filter(item => 
                !this.selectedItems.some(selected => selected.id === item.id)
            );
            
            if (filteredItems.length > 0) {
                dropdown.innerHTML = AlertsUI.renderSuggestions(filteredItems);
                dropdown.style.display = 'block';
                this.selectedIndex = -1;
            } else {
                dropdown.style.display = 'none';
                this.selectedIndex = -1;
            }
        });
        
        // Handle keyboard navigation
        input.addEventListener('keydown', (e) => {
            if (dropdown.style.display === 'none') {
                // Backspace with empty input removes last chip
                if (e.key === 'Backspace' && input.value === '' && this.selectedItems.length > 0) {
                    const lastItem = this.selectedItems[this.selectedItems.length - 1];
                    removeItem(lastItem.id);
                }
                return;
            }
            
            const items = dropdown.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    this.selectedIndex = (this.selectedIndex + 1) % items.length;
                    updateSelection();
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    this.selectedIndex = this.selectedIndex <= 0 
                        ? items.length - 1 
                        : this.selectedIndex - 1;
                    updateSelection();
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Tab moves selection up
                        this.selectedIndex = this.selectedIndex <= 0 
                            ? items.length - 1 
                            : this.selectedIndex - 1;
                    } else {
                        // Tab moves selection down
                        this.selectedIndex = (this.selectedIndex + 1) % items.length;
                    }
                    updateSelection();
                    break;
                    
                case 'Enter':
                    if (this.selectedIndex >= 0) {
                        e.preventDefault();
                        const selectedItem = items[this.selectedIndex];
                        addItem(selectedItem.dataset.id, selectedItem.dataset.name);
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    break;
            }
        });
        
        // Handle mouse click on suggestion
        dropdown.addEventListener('click', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                addItem(e.target.dataset.id, e.target.dataset.name);
            }
        });
        
        // Handle mouse hover to update selection
        dropdown.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (item === e.target) {
                        this.selectedIndex = index;
                    }
                });
                updateSelection();
            }
        });
        
        // Handle chip removal via event delegation on container
        container.addEventListener('click', (e) => {
            if (e.target.classList.contains('chip-remove')) {
                const chip = e.target.closest('.selected-item-chip');
                if (chip) {
                    removeItem(chip.dataset.id);
                }
            }
        });
    },
    
    /**
     * Renders the selected item chips in the container.
     */
    renderChips(container) {
        container.innerHTML = this.selectedItems.map(item => 
            `<span class="selected-item-chip" data-id="${item.id}">
                ${item.name}
                <span class="chip-remove">×</span>
            </span>`
        ).join('');
    },
    
    /**
     * Clears all selected items.
     */
    clear() {
        this.selectedItems = [];
        const container = document.querySelector(AlertsConfig.selectors.create.selectedItemsContainer);
        const hiddenInput = document.querySelector(AlertsConfig.selectors.create.sustainedItemIds);
        if (container) container.innerHTML = '';
        if (hiddenInput) hiddenInput.value = '';
    },
    
    /**
     * Gets the selected item IDs.
     */
    getSelectedIds() {
        return this.selectedItems.map(item => item.id);
    }
};


// =============================================================================
// ALERTS REFRESH
// =============================================================================
/**
 * Handles periodic refresh of alerts data.
 * 
 * Why: Alerts can be triggered by the background script at any time.
 * Periodic refresh ensures the UI stays in sync.
 */
const AlertsRefresh = {
    intervalId: null,
    pausedForSort: false,
    errorNotificationActive: false,
    dropdownOpen: false,
    
    /**
     * Checks if any dropdown is currently open or search is active.
     */
    isDropdownOpen() {
        // Check the explicit dropdown open flag first
        if (this.dropdownOpen) {
            return true;
        }
        // Check if any dropdown menu is open
        if (document.querySelector('.custom-dropdown-menu.show') !== null) {
            return true;
        }
        // Check if search input is focused
        const searchInput = document.getElementById('alertSearchInput');
        if (searchInput && document.activeElement === searchInput) {
            return true;
        }
        // Check if error notification is active
        if (this.errorNotificationActive) {
            return true;
        }
        return false;
    },
    
    /**
     * Called immediately when a dropdown button is clicked to pause refresh.
     */
    onDropdownOpen() {
        this.dropdownOpen = true;
    },
    
    /**
     * Called when all dropdowns are closed to resume refresh.
     */
    onDropdownClose() {
        this.dropdownOpen = false;
    },
    
    /**
     * Fetches fresh data and updates the UI.
     * Skips refresh if a dropdown is open to prevent UI disruption.
     */
    async refresh() {
        // Don't refresh if any dropdown is open
        if (this.isDropdownOpen()) {
            return;
        }
        
        const data = await AlertsAPI.fetchAlerts();
        if (data) {
            AlertsUI.updateMyAlertsPane(data);
        }
    },
    
    /**
     * Starts the periodic refresh interval.
     */
    start() {
        if (this.intervalId) return;
        this.refresh();
        this.intervalId = setInterval(
            () => this.refresh(), 
            AlertsConfig.timing.refreshInterval
        );
    },
    
    /**
     * Temporarily pause refresh while user chooses sort order.
     */
    pauseForSort() {
        this.pausedForSort = true;
        this.stop();
    },
    
    /**
     * Resume refresh if it was paused for sort selection.
     */
    resumeAfterSort() {
        if (!this.pausedForSort) return;
        this.pausedForSort = false;
        this.start();
    },
    
    /**
     * Stops the periodic refresh.
     */
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }
};


// =============================================================================
// TAB NAVIGATION
// =============================================================================
/**
 * Manages tab switching between views.
 */
const TabManager = {
    /**
     * Switches to a specific tab.
     */
    switchTo(tabId) {
        const activeBtn = document.querySelector(AlertsConfig.selectors.tabButtons + '.active');
        const currentTab = activeBtn ? activeBtn.getAttribute('data-tab') : null;
        if (currentTab === 'my-alerts' && tabId !== 'my-alerts') {
            AlertActions.clearStatusNotifications();
        }

        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-tab') === tabId) {
                btn.classList.add('active');
            }
        });
        
        document.querySelectorAll(AlertsConfig.selectors.tabPanes).forEach(pane => {
            pane.style.display = 'none';
        });
        document.getElementById(tabId).style.display = 'block';

        if (tabId === 'my-alerts') {
            AlertActions.mergeTriggeredNotificationsIntoStatus();
        }
    },
    
    /**
     * Initializes tab click handlers.
     */
    init() {
        document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(button => {
            button.addEventListener('click', function() {
                const tabId = button.getAttribute('data-tab');
                TabManager.switchTo(tabId);
            });
        });
    }
};


// =============================================================================
// FORM VALIDATION
// =============================================================================
/**
 * Handles form validation and error display for the create alert form.
 */
const FormValidation = {
    /**
     * Shows an error notification in the triggered-notifications area.
     * @param {string} message - The error message to display
     */
    showError(message) {
        // Try to show in create-alert tab's notification area, or fall back to My Alerts tab
        let container = document.getElementById('create-alert');
        let notificationsContainer = container ? container.querySelector('.form-error-container') : null;
        
        // If no dedicated error container, create one at the top of the create alert form
        if (!notificationsContainer) {
            const form = document.querySelector('.create-alert-form');
            if (form) {
                notificationsContainer = document.createElement('div');
                notificationsContainer.className = 'form-error-container';
                form.insertBefore(notificationsContainer, form.firstChild);
            }
        }
        
        if (!notificationsContainer) return;
        
        // Remove any existing error notifications
        notificationsContainer.querySelectorAll('.triggered-notification.error-notification').forEach(n => n.remove());
        
        // Create error notification
        const notification = document.createElement('div');
        notification.className = 'triggered-notification error-notification';
        notification.innerHTML = message + '<button class="dismiss-btn" type="button">&times;</button>';
        
        // Add click handler for dismiss button
        const dismissBtn = notification.querySelector('.dismiss-btn');
        if (dismissBtn) {
            dismissBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                notification.classList.add('dismissing');
                setTimeout(() => notification.remove(), 300);
            });
        }
        
        notificationsContainer.appendChild(notification);
        
        // Auto-dismiss after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.add('dismissing');
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }
};


// =============================================================================
// EVENT MANAGEMENT
// =============================================================================
/**
 * Sets up all event listeners for the alerts system.
 */
const EventManager = {
    /**
     * Sets up modal event listeners.
     */
    setupModalEvents() {
        const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
        const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
        const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);
        
        // Close spread modal on backdrop click
        if (spreadModal) {
            spreadModal.addEventListener('click', function(e) {
                if (e.target.id === 'spread-modal') {
                    ModalManager.closeSpreadModal();
                }
            });
        }

        // Close spike modal on backdrop click
        if (spikeModal) {
            spikeModal.addEventListener('click', function(e) {
                if (e.target.id === 'spike-modal') {
                    ModalManager.closeSpikeModal();
                }
            });
        }

        // Close group modal on backdrop click
        if (groupModal) {
            groupModal.addEventListener('click', function(e) {
                if (e.target.id === 'group-modal') {
                    GroupManager.close();
                }
            });
        }
        
        // Close delete confirm modal on backdrop click
        const deleteModal = document.getElementById('delete-confirm-modal');
        if (deleteModal) {
            deleteModal.addEventListener('click', function(e) {
                if (e.target.id === 'delete-confirm-modal') {
                    closeDeleteConfirmModal();
                }
            });
        }
        
        // Close modals on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
                if (spreadModal && spreadModal.style.display === 'flex') {
                    ModalManager.closeSpreadModal();
                }
                const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);
                if (spikeModal && spikeModal.style.display === 'flex') {
                    ModalManager.closeSpikeModal();
                }
                const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
                if (groupModal && groupModal.style.display === 'flex') {
                    GroupManager.close();
                }
                const deleteModal = document.getElementById('delete-confirm-modal');
                if (deleteModal && deleteModal.style.display === 'flex') {
                    closeDeleteConfirmModal();
                }
            }
        });
    },
    
    /**
     * Sets up autocomplete dropdown close on outside click.
     */
    setupAutocompleteEvents() {
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.form-group')) {
                const createSuggestions = document.querySelector(AlertsConfig.selectors.create.suggestions);
                
                if (createSuggestions) createSuggestions.style.display = 'none';
            }
        });
    },
    
    /**
     * Sets up custom dropdown toggle and click outside behavior.
     * Uses event delegation to handle dynamically rendered dropdowns.
     */
    setupDropdownEvents() {
        // Toggle dropdown menus on button click (event delegation)
        document.addEventListener('click', function(e) {
            const btn = e.target.closest('.btn-dropdown');
            if (btn) {
                // IMMEDIATELY pause refresh before doing anything else
                AlertsRefresh.onDropdownOpen();
                
                e.stopPropagation();
                const wrapper = btn.closest('.custom-dropdown-wrapper');
                const menu = wrapper.querySelector('.custom-dropdown-menu');
                const isOpen = menu.classList.contains('show');
                
                // Close all other dropdowns
                document.querySelectorAll('.custom-dropdown-menu.show').forEach(m => {
                    m.classList.remove('show');
                });
                
                // Toggle this dropdown
                if (!isOpen) {
                    menu.classList.add('show');
                } else {
                    // Dropdown is being closed, resume refresh
                    AlertsRefresh.onDropdownClose();
                }
                return;
            }
            
            // Handle actions dropdown item clicks
            const actionItem = e.target.closest('#actionsDropdownMenu .custom-dropdown-item');
            if (actionItem) {
                const action = actionItem.dataset.action;
                AlertActions.handleAction(action);
                document.getElementById('actionsDropdownMenu')?.classList.remove('show');
                AlertsRefresh.onDropdownClose();
                return;
            }
            
            // Handle sort dropdown item clicks
            const sortItem = e.target.closest('#sortDropdownMenu .custom-dropdown-item');
            if (sortItem) {
                const sortKey = sortItem.dataset.sort;
                
                // Update active state visually
                document.querySelectorAll('#sortDropdownMenu .custom-dropdown-item').forEach(i => {
                    i.classList.remove('active');
                });
                sortItem.classList.add('active');
                
                handleSortSelection(sortKey);
                document.getElementById('sortDropdownMenu')?.classList.remove('show');
                AlertsRefresh.onDropdownClose();
                return;
            }
            
            // Handle sort indicator arrow click (toggle order)
            if (e.target.id === 'sortIndicatorArrow' || e.target.closest('#sortIndicatorArrow') ||
                e.target.id === 'sortIndicatorArrowMobile' || e.target.closest('#sortIndicatorArrowMobile')) {
                e.stopPropagation();
                SortManager.toggleSortOrder();
                return;
            }
            
            // Handle sort indicator clear click
            if (e.target.id === 'sortIndicatorClear' || e.target.closest('#sortIndicatorClear') ||
                e.target.id === 'sortIndicatorClearMobile' || e.target.closest('#sortIndicatorClearMobile')) {
                e.stopPropagation();
                clearSort();
                return;
            }
            
            // Handle filter dropdown item clicks
            const filterItem = e.target.closest('#filterDropdownMenu .custom-dropdown-item');
            if (filterItem) {
                const filterId = filterItem.dataset.filter;
                
                // Check if clicking the clear button
                if (e.target.classList.contains('filter-clear')) {
                    filterItem.classList.remove('active');
                    removeFilter(filterId);
                    updateFilterBadge();
                    document.getElementById('filterDropdownMenu')?.classList.remove('show');
                    return;
                }
                
                // Check if this filter requires a modal (don't toggle active state yet)
                const filter = AlertsConfig.filters[filterId];
                const requiresModal = filter && filter.requiresModal;
                
                // Toggle filter
                if (filterItem.classList.contains('active')) {
                    filterItem.classList.remove('active');
                    removeFilter(filterId);
                    updateFilterBadge();
                } else {
                    // Only mark as active immediately if it doesn't require a modal
                    if (!requiresModal) {
                        filterItem.classList.add('active');
                        updateFilterBadge();
                    }
                    addFilter(filterId);
                }
                document.getElementById('filterDropdownMenu')?.classList.remove('show');
                return;
            }
            
            // Close dropdowns on outside click
            if (!e.target.closest('.custom-dropdown-wrapper')) {
                document.querySelectorAll('.custom-dropdown-menu.show').forEach(m => {
                    m.classList.remove('show');
                });
            }
        });
    },
    
    /**
     * Sets up search input event handlers using event delegation.
     */
    setupSearchEvents() {
        // Use event delegation so events work after DOM re-render
        document.addEventListener('input', function(e) {
            if (e.target.id === 'alertSearchInput') {
                AlertsState.searchQuery = e.target.value;
                const searchWrapper = e.target.closest('.alert-search-wrapper');
                if (searchWrapper) {
                    searchWrapper.classList.toggle('has-value', e.target.value.length > 0);
                }
                FilterManager.updateAlertsList();
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.target.id === 'alertSearchInput') {
                if (e.key === 'Escape') {
                    e.target.value = '';
                    AlertsState.searchQuery = '';
                    const searchWrapper = e.target.closest('.alert-search-wrapper');
                    if (searchWrapper) {
                        searchWrapper.classList.remove('has-value');
                    }
                    FilterManager.updateAlertsList();
                    e.target.blur();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            }
        });
        
        document.addEventListener('click', function(e) {
            if (e.target.id === 'alertSearchClear' || e.target.closest('#alertSearchClear')) {
                const searchInput = document.getElementById('alertSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                    AlertsState.searchQuery = '';
                    const searchWrapper = searchInput.closest('.alert-search-wrapper');
                    if (searchWrapper) {
                        searchWrapper.classList.remove('has-value');
                    }
                    FilterManager.updateAlertsList();
                }
            }
        });
    },
    
    /**
     * Initializes all event listeners.
     */
    init() {
        this.setupModalEvents();
        this.setupAutocompleteEvents();
        this.setupDropdownEvents();
        this.setupSearchEvents();
        this.setupFormValidation();
    },
    
    /**
     * Sets up form validation for the create alert form.
     */
    setupFormValidation() {
        const form = document.querySelector('.create-alert-form');
        if (!form) return;
        
        // Prevent Enter from submitting unless the Create Alert button is focused
        form.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const submitBtn = form.querySelector('button[type="submit"]');
                if (document.activeElement !== submitBtn) {
                    e.preventDefault();
                }
            }
        });
        
        // Validate on submit
        form.addEventListener('submit', function(e) {
            const alertType = document.getElementById('alert-type').value;
            const errors = [];
            
            // Check item name for types that need it
            const itemNameGroup = document.getElementById('item-name-group');
            const itemNameVisible = itemNameGroup && itemNameGroup.style.display !== 'none';
            
            if (itemNameVisible) {
                const itemName = document.getElementById('item-name').value.trim();
                const itemId = document.getElementById('item-id').value.trim();
                
                if (!itemName) {
                    errors.push('Item name is required');
                } else if (!itemId) {
                    errors.push('Please select a valid item from the suggestions');
                }
            }
            
            // Check price for above/below types
            if (alertType === 'above' || alertType === 'below') {
                const price = document.getElementById('price').value;
                if (!price || price <= 0) {
                    errors.push('Price threshold is required');
                }
            }
            
            // Check percentage for spread/spike types
            if (alertType === 'spread' || alertType === 'spike') {
                const percentage = document.getElementById('percentage').value;
                if (!percentage || percentage <= 0) {
                    errors.push('Percentage is required');
                }
            }
            
            // Check time frame for spike type
            if (alertType === 'spike') {
                const timeFrame = document.getElementById('time-frame').value;
                if (!timeFrame || timeFrame <= 0) {
                    errors.push('Time frame is required');
                }
            }
            
            // Check sustained move specific fields
            if (alertType === 'sustained') {
                const timeFrame = document.getElementById('time-frame').value;
                if (!timeFrame || timeFrame <= 0) {
                    errors.push('Time frame is required');
                }
                const minMoves = document.getElementById('min-consecutive-moves').value;
                if (!minMoves || minMoves < 2) {
                    errors.push('Minimum consecutive moves must be at least 2');
                }
                const minMovePercent = document.getElementById('min-move-percentage').value;
                if (!minMovePercent || minMovePercent <= 0) {
                    errors.push('Minimum move percentage is required');
                }
                const volBuffer = document.getElementById('volatility-buffer-size').value;
                if (!volBuffer || volBuffer < 5) {
                    errors.push('Volatility buffer size must be at least 5');
                }
                const volMultiplier = document.getElementById('volatility-multiplier').value;
                if (!volMultiplier || volMultiplier <= 0) {
                    errors.push('Volatility multiplier is required');
                }
                
                // Check items - either all items or at least one specific item
                const sustainedScope = document.getElementById('sustained-scope').value;
                if (sustainedScope === 'specific') {
                    const selectedItemIds = document.getElementById('sustained-item-ids').value;
                    if (!selectedItemIds || selectedItemIds.trim() === '') {
                        errors.push('Please select at least one item');
                    }
                }
            }
            
            if (errors.length > 0) {
                e.preventDefault();
                FormValidation.showError(errors[0]);
            }
        });
    }
};


// =============================================================================
// GLOBAL FUNCTION EXPORTS
// =============================================================================
/**
 * These functions are exposed globally for use in onclick handlers in HTML.
 */

// Form handlers
function handleAlertTypeChange() {
    FormManager.handleAlertTypeChange('create');
}

function handleSpreadScopeChange() {
    FormManager.handleSpreadScopeChange('create');
}

function handleSpikeScopeChange() {
    FormManager.handleSpikeScopeChange('create');
}

function handleSustainedScopeChange() {
    FormManager.handleSustainedScopeChange('create');
}

// Modal handlers
function closeSpreadModal() {
    ModalManager.closeSpreadModal();
}

function showSpreadDetails(alertId) {
    ModalManager.showSpreadDetails(alertId);
}

function closeSpikeModal() {
    ModalManager.closeSpikeModal();
}

function showSpikeDetails(alertId) {
    ModalManager.showSpikeDetails(alertId);
}

// Navigate to alert detail page
function navigateToAlertDetail(event, alertId) {
    // Don't navigate if clicking on checkbox
    if (event.target.classList.contains('alert-checkbox')) {
        return;
    }
    window.location.href = '/alerts/' + alertId + '/';
}

// Alert action handlers
function dismissAlert(alertId) {
    AlertActions.dismiss(alertId);
}

function dismissStatusNotification(button) {
    const notification = button.closest('.triggered-notification');
    if (!notification) return;

    // For error notifications, just dismiss immediately
    if (notification.classList.contains('error-notification')) {
        notification.classList.add('dismissing');
        setTimeout(() => notification.remove(), 300);
        return;
    }

    if (notification.classList.contains('status-notification')) {
        // Dismiss all triggered alerts referenced in this box.
        const alertIds = new Set();
        notification.querySelectorAll('.notification-line[data-kind="triggered"][data-alert-id]').forEach(l => {
            alertIds.add(l.dataset.alertId);
        });
        // Also handle any unmerged triggered banners that may still be in the container.
        const container = notification.parentElement;
        if (container) {
            container.querySelectorAll('.triggered-notification[data-alert-id]:not(.status-notification)').forEach(n => {
                alertIds.add(n.dataset.alertId);
            });
        }
        alertIds.forEach(id => AlertActions.dismiss(id));
    }

    notification.classList.add('dismissing');
    setTimeout(() => notification.remove(), 300);
}

function addFilter(filterId) {
    if (filterId) {
        FilterManager.addFilter(filterId);
        updateFilterBadge();
        syncFilterDropdownState();
    }
}

function removeFilter(filterId) {
    // Animate the tag out first
    const tag = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
    if (tag) {
        tag.classList.add('removing');
        setTimeout(() => {
            FilterManager.removeFilter(filterId);
            updateFilterBadge();
            syncFilterDropdownState();
        }, 300);
    } else {
        FilterManager.removeFilter(filterId);
        updateFilterBadge();
        syncFilterDropdownState();
    }
}

function updateFilterBadge() {
    const badge = document.getElementById('filterBadge');
    const btn = document.getElementById('filterDropdownBtn');
    const activeCount = AlertsState.activeFilters.size;
    
    if (badge) {
        if (activeCount > 0) {
            badge.textContent = activeCount;
            badge.style.display = 'inline';
            if (btn) btn.classList.add('has-active');
        } else {
            badge.style.display = 'none';
            if (btn) btn.classList.remove('has-active');
        }
    }
}

function syncFilterDropdownState() {
    document.querySelectorAll('#filterDropdownMenu .custom-dropdown-item').forEach(item => {
        const filterId = item.dataset.filter;
        if (AlertsState.activeFilters.has(filterId)) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

function confirmFilterInput(filterId) {
    FilterManager.confirmFilterInput(filterId);
}

function cancelFilterInput(filterId) {
    FilterManager.cancelFilterInput(filterId);
}

function handleFilterInputKeydown(event, filterId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        confirmFilterInput(filterId);
    } else if (event.key === 'Escape') {
        event.preventDefault();
        cancelFilterInput(filterId);
    }
}

// Sort handlers
function handleSortSelection(sortKey) {
    SortManager.handleSortSelection(sortKey);
    syncSortDropdownState();
}

function applySortOrder(order) {
    SortManager.applySortOrder(order);
    syncSortDropdownState();
}

function clearSort() {
    SortManager.clearSort();
    syncSortDropdownState();
}

function syncSortDropdownState() {
    const currentSortKey = AlertsState.sorting.sortKey;
    document.querySelectorAll('#sortDropdownMenu .custom-dropdown-item').forEach(item => {
        if (item.dataset.sort === currentSortKey) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

// Groups filter modal functions
function openGroupsFilterModal() {
    const modal = document.getElementById('groups-filter-modal');
    const listContainer = document.getElementById('groups-filter-list');
    const noGroupsMsg = document.getElementById('no-groups-message');
    
    const groups = AlertsState.getAlertGroups();
    const selectedGroups = AlertsState.getFilterValue('myGroups') || [];
    
    if (groups.length === 0) {
        listContainer.style.display = 'none';
        noGroupsMsg.style.display = 'block';
    } else {
        listContainer.style.display = 'block';
        noGroupsMsg.style.display = 'none';
        
        listContainer.innerHTML = '';
        groups.forEach(group => {
            const pill = document.createElement('span');
            pill.className = 'group-pill' + (selectedGroups.includes(group) ? ' selected' : '');
            pill.textContent = group;
            pill.dataset.group = group;
            pill.addEventListener('click', function() {
                this.classList.toggle('selected');
            });
            listContainer.appendChild(pill);
        });
    }
    
    modal.style.display = 'flex';
}

function closeGroupsFilterModal() {
    const modal = document.getElementById('groups-filter-modal');
    modal.style.display = 'none';
}

function applyGroupsFilter() {
    const pills = document.querySelectorAll('#groups-filter-list .group-pill.selected');
    const selectedGroups = Array.from(pills).map(pill => pill.dataset.group);
    const sortedSelectedGroups = selectedGroups.slice().sort((a, b) => a.localeCompare(b));
    
    if (sortedSelectedGroups.length === 0) {
        // If no groups selected, remove the filter if it exists
        if (AlertsState.activeFilters.has('myGroups')) {
            FilterManager.removeFilter('myGroups');
        }
        closeGroupsFilterModal();
        syncFilterDropdownState();
        updateFilterBadge();
        return;
    }
    
    AlertsState.setFilterValue('myGroups', sortedSelectedGroups);
    
    // If filter not already active, activate it
    if (!AlertsState.activeFilters.has('myGroups')) {
        const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
        FilterManager.activateFilter('myGroups', displayValue);
    } else {
        // Update the filter tag label
        const tag = document.querySelector('.filter-tag[data-filter-id="myGroups"]');
        if (tag) {
            const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
            tag.innerHTML = 'My Groups: ' + displayValue + 
                '<button class="filter-tag-remove" onclick="removeFilter(\'myGroups\')">&times;</button>';
        }
        FilterManager.updateAlertsList();
    }
    
    closeGroupsFilterModal();
    syncFilterDropdownState();
    updateFilterBadge();
}

function openPriceFilterModal() {
    const modal = document.getElementById('price-filter-modal');
    const minInput = document.getElementById('price-filter-min');
    const maxInput = document.getElementById('price-filter-max');
    if (!modal) return;
    
    // Load existing values if filter is active
    const existingValue = AlertsState.getFilterValue('priceRange');
    if (existingValue) {
        if (minInput) minInput.value = existingValue.min || '';
        if (maxInput) maxInput.value = existingValue.max || '';
    } else {
        if (minInput) minInput.value = '';
        if (maxInput) maxInput.value = '';
    }
    
    modal.style.display = 'flex';
    setTimeout(() => minInput && minInput.focus(), 0);
}

function closePriceFilterModal() {
    const modal = document.getElementById('price-filter-modal');
    if (modal) modal.style.display = 'none';
}

function clearPriceFilter() {
    const minInput = document.getElementById('price-filter-min');
    const maxInput = document.getElementById('price-filter-max');
    if (minInput) minInput.value = '';
    if (maxInput) maxInput.value = '';
    
    // Remove the filter
    removeFilter('priceRange');
    closePriceFilterModal();
}

function applyPriceFilter() {
    const minInput = document.getElementById('price-filter-min');
    const maxInput = document.getElementById('price-filter-max');
    if (!minInput || !maxInput) return;
    
    const minValue = minInput.value.trim();
    const maxValue = maxInput.value.trim();
    
    // If both are empty, clear the filter
    if (!minValue && !maxValue) {
        removeFilter('priceRange');
        closePriceFilterModal();
        return;
    }
    
    const filterValue = {
        min: minValue || null,
        max: maxValue || null
    };
    
    AlertsState.setFilterValue('priceRange', filterValue);
    FilterManager.activateFilter('priceRange', filterValue);
    
    // Update the filter tag to show the range
    const tag = document.querySelector('.filter-tag[data-filter-id="priceRange"]');
    if (tag) {
        let displayText = 'Price: ';
        if (minValue && maxValue) {
            displayText += minValue + ' - ' + maxValue;
        } else if (minValue) {
            displayText += '≥ ' + minValue;
        } else if (maxValue) {
            displayText += '≤ ' + maxValue;
        }
        tag.innerHTML = displayText + 
            '<button class="filter-tag-remove" onclick="removeFilter(\'priceRange\')">&times;</button>';
    }
    
    closePriceFilterModal();
    syncFilterDropdownState();
    updateFilterBadge();
}

function closeDeleteConfirmModal() {
    const modal = document.getElementById('delete-confirm-modal');
    if (modal) modal.style.display = 'none';
}

function executeDelete() {
    AlertActions.executeDelete();
}

function confirmDelete() {
    AlertActions.confirmDelete();
}


// =============================================================================
// INITIALIZATION
// =============================================================================
/**
 * Initialize the alerts system when the script loads.
 */
(function init() {
    TabManager.init();
    AutocompleteManager.init();
    MultiItemSelector.init();
    EventManager.init();
    DropdownSizer.init();
    AlertsRefresh.start();
    
    // If the page is restored from the back/forward cache, clear transient status notifications.
    window.addEventListener('pageshow', function(e) {
        if (e.persisted) {
            AlertActions.clearStatusNotifications();
        }
    });

    // Ensure only one status notification box (merge server-side messages if any).
    AlertActions.normalizeStatusNotifications();
    AlertActions.mergeTriggeredNotificationsIntoStatus();

    // Check for deleted parameter and show notification
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('deleted') === '1') {
        AlertActions.showStatusNotification('Alert deleted');
        // Remove the parameter from URL without reload
        const newUrl = window.location.pathname;
        window.history.replaceState({}, document.title, newUrl);
    }
})();
</script>

<!-- Alert Help Modal -->
<div class="alert-help-modal-overlay" id="alertHelpModal">
    <div class="alert-help-modal">
        <div class="alert-help-modal-header">
            <h2>
                <svg viewBox="0 0 20 20" fill="currentColor" width="24" height="24">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                </svg>
                Understanding Alert Types
            </h2>
            <button class="alert-help-modal-close" onclick="closeAlertHelpModal()">&times;</button>
        </div>
        <div class="alert-help-modal-body">
            <div class="alert-help-tabs">
                <button class="alert-help-tab active" data-help-tab="above">Above</button>
                <button class="alert-help-tab" data-help-tab="below">Below</button>
                <button class="alert-help-tab" data-help-tab="spread">Spread</button>
                <button class="alert-help-tab" data-help-tab="spike">Spike</button>
                <button class="alert-help-tab" data-help-tab="sustained">Sustained</button>
            </div>
            <div class="alert-help-content">
                <!-- Above Threshold -->
                <div class="alert-help-section active" data-help-section="above">
                    <h3>
                        Above Threshold Alert
                        <span class="alert-type-badge above">Price Increase</span>
                    </h3>
                    <p class="subtitle">Get notified when an item's price rises above a specific value. Perfect for knowing when to sell items you're holding.</p>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>
                            How It Works
                        </h4>
                        <p>This alert monitors the Grand Exchange price of your chosen item. When the price exceeds your set threshold, you'll receive a notification. You can choose to monitor either the <strong>high price</strong> (instant buy price) or <strong>low price</strong> (instant sell price).</p>
                        <ul>
                            <li><strong>High Price:</strong> The price at which you can instantly buy an item (usually higher)</li>
                            <li><strong>Low Price:</strong> The price at which you can instantly sell an item (usually lower)</li>
                        </ul>
                    </div>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>You bought an item and want to sell when it reaches a target profit</li>
                            <li>You're waiting for an item to become valuable enough to sell</li>
                            <li>Tracking items that might spike in price due to game updates</li>
                        </ul>
                    </div>
                    
                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"/></svg>
                            Example Scenario
                        </h4>
                        <p>You bought a Dragon Warhammer for 32M and want to sell when it hits 35M. Set an Above Threshold alert for 35,000,000 gp on the high price. When someone buys one for 35M+, you'll be notified!</p>
                    </div>
                    
                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Reference Price</div>
                                <div class="value">High Price</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Threshold</div>
                                <div class="value">5-10% above current price</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Below Threshold -->
                <div class="alert-help-section" data-help-section="below">
                    <h3>
                        Below Threshold Alert
                        <span class="alert-type-badge below">Price Decrease</span>
                    </h3>
                    <p class="subtitle">Get notified when an item's price drops below a specific value. Ideal for finding buying opportunities and bargains.</p>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>
                            How It Works
                        </h4>
                        <p>This alert watches for price drops. When the item's price falls below your threshold, you'll be notified immediately. This is perfect for catching deals when items crash or finding good entry points.</p>
                        <ul>
                            <li><strong>High Price:</strong> Monitor when buy offers drop (good for bulk buying)</li>
                            <li><strong>Low Price:</strong> Monitor when sell offers drop (catch panic sellers)</li>
                        </ul>
                    </div>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>You want to buy an expensive item when it dips in price</li>
                            <li>Tracking items that might crash due to game changes or dupes</li>
                            <li>Finding entry points for long-term flipping investments</li>
                        </ul>
                    </div>
                    
                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"/></svg>
                            Example Scenario
                        </h4>
                        <p>You want to buy a Twisted Bow but it's currently 1.5B. Set a Below Threshold alert for 1,400,000,000 gp on the low price. If panic sellers dump it below 1.4B, you'll know instantly!</p>
                    </div>
                    
                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Reference Price</div>
                                <div class="value">Low Price</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Threshold</div>
                                <div class="value">5-15% below current price</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Spread Alert -->
                <div class="alert-help-section" data-help-section="spread">
                    <h3>
                        Spread Alert
                        <span class="alert-type-badge spread">Flip Margin</span>
                    </h3>
                    <p class="subtitle">Get notified when the buy/sell margin (spread) exceeds a percentage. Essential for finding profitable flipping opportunities.</p>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>
                            How It Works
                        </h4>
                        <p>The <strong>spread</strong> is the percentage difference between the high price (what buyers pay) and the low price (what sellers receive). A higher spread means more potential profit per flip.</p>
                        <p style="margin-top: 12px;"><strong>Formula:</strong> Spread % = ((High Price - Low Price) / Low Price) × 100</p>
                        <ul>
                            <li><strong>All Items:</strong> Scan the entire GE for items with high spreads</li>
                            <li><strong>Specific Item:</strong> Monitor one item's spread for flipping</li>
                        </ul>
                    </div>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Finding items worth flipping across the entire GE</li>
                            <li>Monitoring your favorite flip items for optimal margins</li>
                            <li>Setting up "All Items" alerts to discover new opportunities</li>
                        </ul>
                    </div>
                    
                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"/></svg>
                            Example Scenario
                        </h4>
                        <p>Set an "All Items" spread alert for 5% with a minimum price of 1,000,000 gp. You'll be notified whenever any item worth 1M+ has a 5%+ margin - perfect for finding high-value flips!</p>
                    </div>
                    
                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Spread Percentage</div>
                                <div class="value">3-5% for high-value items</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Minimum Price</div>
                                <div class="value">500,000 - 1,000,000 gp</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Maximum Price</div>
                                <div class="value">Based on your cash stack</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Spike Alert -->
                <div class="alert-help-section" data-help-section="spike">
                    <h3>
                        Spike Alert
                        <span class="alert-type-badge spike">Rapid Change</span>
                    </h3>
                    <p class="subtitle">Get notified when an item's price changes rapidly within a time window. Catch sudden market movements as they happen.</p>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>
                            How It Works
                        </h4>
                        <p>Spike alerts track price changes over a rolling time window. If the price moves by your specified percentage within that time, you'll be notified. This catches sudden jumps or crashes.</p>
                        <ul>
                            <li><strong>Time Frame:</strong> How far back to compare (e.g., 30 minutes, 1 hour)</li>
                            <li><strong>Percentage:</strong> The minimum change to trigger (e.g., 5% up or down)</li>
                            <li><strong>Direction:</strong> Up only, Down only, or Both directions</li>
                        </ul>
                    </div>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Catching items that spike after game updates or news</li>
                            <li>Detecting crash opportunities to buy low</li>
                            <li>Monitoring volatile items for trading opportunities</li>
                            <li>Setting "All Items" to find any item spiking in the market</li>
                        </ul>
                    </div>
                    
                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"/></svg>
                            Example Scenario
                        </h4>
                        <p>Set an "All Items" spike alert for 10% within 60 minutes, direction "Up", with minimum price 100,000 gp. When any item worth 100k+ jumps 10% in an hour, you'll be the first to know!</p>
                    </div>
                    
                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Percentage Change</div>
                                <div class="value">5-10%</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Time Frame</div>
                                <div class="value">30-60 minutes</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Direction</div>
                                <div class="value">Both (to catch all movements)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Minimum Price</div>
                                <div class="value">100,000+ gp</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sustained Move Alert -->
                <div class="alert-help-section" data-help-section="sustained">
                    <h3>
                        Sustained Move Alert
                        <span class="alert-type-badge sustained">Trend Detection</span>
                    </h3>
                    <p class="subtitle">Get notified when an item shows consistent price movement in one direction. Detect emerging trends before they become obvious.</p>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>
                            How It Works
                        </h4>
                        <p>Unlike spike alerts that catch sudden moves, sustained move alerts detect <strong>consistent trends</strong>. They look for multiple consecutive price movements in the same direction, filtering out noise to find real trends.</p>
                        <ul>
                            <li><strong>Consecutive Moves:</strong> How many price updates must move the same direction</li>
                            <li><strong>Move Percentage:</strong> Minimum size of each individual move</li>
                            <li><strong>Direction:</strong> Upward trend, Downward trend, or Both</li>
                            <li><strong>Volatility Filter:</strong> Ignores normal market fluctuations</li>
                        </ul>
                    </div>
                    
                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Detecting items being manipulated or merched</li>
                            <li>Finding items trending up before a big spike</li>
                            <li>Catching items in decline before they crash further</li>
                            <li>Identifying genuine market trends vs random noise</li>
                        </ul>
                    </div>
                    
                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"/></svg>
                            Example Scenario
                        </h4>
                        <p>Set a sustained move alert for "All Items" with 5 consecutive moves, 0.5% minimum move, direction "Up". When any item moves up 5 times in a row, each by at least 0.5%, you'll catch the trend early!</p>
                    </div>
                    
                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Consecutive Moves</div>
                                <div class="value">4-6 moves</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Min Move %</div>
                                <div class="value">0.3-0.5%</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Direction</div>
                                <div class="value">Both (catch all trends)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Min Volume</div>
                                <div class="value">100+ (filters low-trade items)</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function openAlertHelpModal() {
    const modal = document.getElementById('alertHelpModal');
    modal.classList.add('open');
    document.body.style.overflow = 'hidden';
    
    // Switch to the currently selected alert type
    const alertType = document.getElementById('alert-type').value;
    switchHelpTab(alertType);
}

function closeAlertHelpModal() {
    const modal = document.getElementById('alertHelpModal');
    modal.classList.remove('open');
    document.body.style.overflow = '';
}

function switchHelpTab(tabName) {
    // Update tabs
    document.querySelectorAll('.alert-help-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.helpTab === tabName);
    });
    
    // Update sections
    document.querySelectorAll('.alert-help-section').forEach(section => {
        section.classList.toggle('active', section.dataset.helpSection === tabName);
    });
}

// Tab click handlers
document.querySelectorAll('.alert-help-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        switchHelpTab(tab.dataset.helpTab);
    });
});

// Close on overlay click
document.getElementById('alertHelpModal').addEventListener('click', (e) => {
    if (e.target.classList.contains('alert-help-modal-overlay')) {
        closeAlertHelpModal();
    }
});

// Close on Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeAlertHelpModal();
    }
});
</script>

{% endblock %}
