{% extends 'base.html' %}
{% load static %}

{% block title %}Alerts - GE Tools{% endblock %}

{% block extra_css %}
<!-- Group selector styles (shared with alert_detail.html) -->
<link rel="stylesheet" href="{% static 'css/group-selector.css' %}">
{% endblock %}

{% block content %}
<div class="page-header">
    <div class="page-header-icon">
        <svg fill="currentColor" viewBox="0 0 20 20">
            <path
                d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z" />
        </svg>
    </div>
    <div class="page-header-text">
        <h1>Alerts</h1>
        <p>Set up price alerts and get notified when items hit your targets. Click on individual alerts to get more
            details.</p>
    </div>
</div>

<div class="alert-tabs">
    <button class="tab-btn active" data-tab="my-alerts">My Alerts</button>
    <button class="tab-btn" data-tab="create-alert">Create Alert</button>
</div>

<div class="tab-content">
    <div id="my-alerts" class="tab-pane active">
        <div id="triggered-notifications">
            {% for message in messages %}
            <div class="triggered-notification status-notification">
                {{ message }}
                <button class="dismiss-btn" onclick="dismissStatusNotification(this)">&times;</button>
            </div>
            {% endfor %}
        </div>
        <div class="alert-actions-wrapper">
            <div class="alert-actions">
                <div class="alert-actions-left">
                    <div class="custom-dropdown-wrapper">
                        <button type="button" class="btn-dropdown btn-actions" id="actionsDropdownBtn">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            <span class="btn-text">Actions</span>
                        </button>
                        <div class="custom-dropdown-menu" id="actionsDropdownMenu">
                            <div class="custom-dropdown-header">Actions</div>
                            <div class="custom-dropdown-item" data-action="delete">
                                <span>Delete</span>
                            </div>
                            <div class="custom-dropdown-item" data-action="group">
                                <span>Add to Group</span>
                            </div>
                        </div>
                    </div>
                    <div class="alert-search-wrapper">
                        <svg class="alert-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        <input type="text" class="alert-search-input" id="alertSearchInput"
                            placeholder="Search alerts..." autocomplete="off">
                        <button type="button" class="alert-search-clear" id="alertSearchClear"
                            title="Clear search">Ã—</button>
                    </div>
                </div>
                <div class="alert-actions-right" id="active-filters">
                    <div class="alert-actions-controls">
                        <div class="sort-controls">
                            <div class="sort-indicator-wrapper" id="sortIndicatorWrapper">
                                <div class="sort-indicator" id="sortIndicator">
                                    <span class="sort-indicator-label">Sorted by:</span>
                                    <span class="sort-indicator-value" id="sortIndicatorValue"></span>
                                    <span class="sort-indicator-arrow" id="sortIndicatorArrow"
                                        title="Toggle sort order">â†“</span>
                                    <span class="sort-indicator-clear" id="sortIndicatorClear"
                                        title="Clear sort">Ã—</span>
                                </div>
                            </div>
                            <div class="custom-dropdown-wrapper">
                                <button type="button" class="btn-dropdown btn-sort" id="sortDropdownBtn">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12" />
                                    </svg>
                                    <span class="btn-text">Sort</span>
                                </button>
                                <div class="custom-dropdown-menu" id="sortDropdownMenu">
                                    <div class="custom-dropdown-header">Sort by</div>
                                    <div class="custom-dropdown-item" data-sort="alphabetically">
                                        <span>Alphabetically</span>
                                        <span class="sort-check">âœ“</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="lastTriggered">
                                        <span>Last Triggered Time</span>
                                        <span class="sort-check">âœ“</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="alertType">
                                        <span>Alert Type</span>
                                        <span class="sort-check">âœ“</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="thresholdDistance">
                                        <span>Threshold Distance</span>
                                        <span class="sort-check">âœ“</span>
                                    </div>
                                    <div class="custom-dropdown-item" data-sort="createdDate">
                                        <span>Created Date</span>
                                        <span class="sort-check">âœ“</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="custom-dropdown-wrapper">
                            <button type="button" class="btn-dropdown btn-filter" id="filterDropdownBtn">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
                                </svg>
                                <span class="btn-text">Filters</span>
                                <span class="filter-badge" id="filterBadge" style="display: none;">0</span>
                            </button>
                            <div class="custom-dropdown-menu" id="filterDropdownMenu">
                                <div class="custom-dropdown-header">Filter by</div>
                                <div class="custom-dropdown-item" data-filter="triggered">
                                    <span>Triggered</span>
                                    <span class="filter-check">âœ“</span>
                                    <span class="filter-clear" title="Clear filter">Ã—</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="notTriggered">
                                    <span>Not Triggered</span>
                                    <span class="filter-check">âœ“</span>
                                    <span class="filter-clear" title="Clear filter">Ã—</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="priceRange">
                                    <span>Price</span>
                                    <span class="filter-check">âœ“</span>
                                    <span class="filter-clear" title="Clear filter">Ã—</span>
                                </div>
                                <div class="custom-dropdown-item" data-filter="myGroups">
                                    <span>My Groups</span>
                                    <span class="filter-check">âœ“</span>
                                    <span class="filter-clear" title="Clear filter">Ã—</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Mobile sort indicator row (shown on smaller screens) -->
            <div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">
                <div class="sort-indicator" id="sortIndicatorMobile">
                    <span class="sort-indicator-label">Sorted by:</span>
                    <span class="sort-indicator-value" id="sortIndicatorValueMobile"></span>
                    <span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">â†“</span>
                    <span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">Ã—</span>
                </div>
            </div>
            <div class="alert-indicators">
                <div class="filter-tags"></div>
                <div class="sort-tag-holder"></div>
            </div>
        </div>
        <div id="alerts-list-container">
            <div class="loading-container">
                <div class="spinner-border" role="status" style="width: 48px; height: 48px; color: var(--primary);"></div>
                <span class="loading-text">Loading</span>
            </div>
        </div>
    </div>
    <div id="create-alert" class="tab-pane" style="display: none;">
        <form method="POST" action="{% url 'create_alert' %}" class="create-alert-form">
            {% csrf_token %}

            <div class="form-group">
                <label for="alert-type">Alert Type</label>
                <!-- What: Dropdown to select the type of alert to create
                     Why: Different alert types have different configuration options and behaviors
                     How: Default is "threshold" as it's the most commonly used alert type -->
                <select name="type" id="alert-type" required onchange="handleAlertTypeChange()" tabindex="1">
                    <option value="spread">Spread</option>
                    <option value="spike">Spike</option>
                    <option value="sustained">Sustained Move</option>
                    <option value="threshold" selected>Threshold</option>
                </select>
                <button type="button" class="alert-help-btn" onclick="openAlertHelpModal()" tabindex="2">
                    <svg viewBox="0 0 20 20" fill="currentColor" width="16" height="16">
                        <path fill-rule="evenodd"
                            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z"
                            clip-rule="evenodd" />
                    </svg>
                    How do alerts work?
                </button>
            </div>

            <div class="form-group">
                <label for="alert-name-type">Alert Name</label>
                <select name="alert_name_type" id="alert-name-type" onchange="handleAlertNameTypeChange()" tabindex="3">
                    <option value="default" selected>Default name</option>
                    <option value="custom">Custom</option>
                </select>
                <small class="form-hint">Choose a name for your alert</small>
            </div>

            <div class="form-group" id="custom-name-group" style="display: none;">
                <label for="alert-custom-name">Custom Name</label>
                <input type="text" name="alert_name" id="alert-custom-name" maxlength="255"
                    placeholder="Enter alert name..." tabindex="4">
                <small class="form-hint">Enter a custom name for this alert</small>
            </div>

            <!-- Group Selection -->
            <!-- What: Dropdown to select which group to assign to the new alert -->
            <!-- Why: Users can organize alerts into groups for easier management -->
            <!-- How: Dropdown populated from user's groups with "+" button to create new -->
            <div class="form-group">
                <label for="alert-group">Group</label>
                <div class="group-selector-wrapper">
                    <select name="group_id" id="alert-group" tabindex="5">
                        <option value="">No Group</option>
                    </select>
                    <button type="button" class="btn-add-group" onclick="openNewGroupModal()" title="Create new group" tabindex="6">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 4v16m8-8H4"/>
                        </svg>
                    </button>
                </div>
                <small class="form-hint">Group your alerts. Click + to create a new group</small>
            </div>

            <!-- Spike-specific Apply To selector -->
            <!-- What: Dropdown to choose scope for spike alerts (all items or specific items) -->
            <!-- Why: Users may want to monitor spike on all items or a curated list of specific items -->
            <!-- How: Changes form visibility and sets appropriate hidden fields -->
            <!-- Note: "Specific Item(s)" handles both single and multiple items - no need for separate single item option -->
            <div class="form-group" id="spike-scope-group" style="display: none;">
                <label for="spike-scope">Apply To</label>
                <select name="spike_scope" id="spike-scope" onchange="handleSpikeScopeChange()" tabindex="7">
                    <option value="multiple" selected>Specific Item(s)</option>
                    <option value="all">All Items</option>
                </select>

                <small class="form-hint">Choose to track specific items or all items at once</small>
            </div>

            <!-- Multi-item selector for spike alerts (shown when "Specific Item(s)" selected) -->
            <!-- What: Allows users to select multiple specific items to monitor for spike threshold -->
            <!-- Why: Users may want to monitor spike on a curated list of items instead of all or just one -->
            <!-- How: Uses box-style input with dropdown arrow - matching spread multi-item selector -->
            <div class="form-group" id="spike-items-group" style="display: none;">
                <div class="label-with-notification">
                    <label for="spike-item-input">Items</label>
                    <!-- Small notification shown when items are added or not found -->
                    <span id="spike-item-notification" class="item-notification"></span>
                </div>
                <div class="multi-item-selector">
                    <div class="multi-item-selector-box">
                        <!-- Search input for adding new items -->
                        <input type="text" id="spike-item-input" placeholder="Search for item to add..." autocomplete="off" tabindex="8">
                        <!-- Dropdown toggle button with chevron arrow -->
                        <button type="button" class="multi-item-dropdown-toggle" id="spike-multi-item-toggle" title="Show selected items" tabindex="9">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <!-- Hidden input for form submission - stores comma-separated item IDs -->
                        <input type="hidden" name="spike_item_ids" id="spike-item-ids" value="">
                        <!-- Autocomplete suggestions dropdown (shown when typing) -->
                        <div id="spike-item-suggestions" class="multi-item-suggestions-dropdown"></div>
                        <!-- Selected items dropdown (shown when clicking arrow) -->
                        <div id="spike-selected-items-dropdown" class="multi-item-selected-dropdown">
                            <div class="selected-items-list" id="spike-selected-items-list">
                                <!-- Items will be populated here dynamically -->
                            </div>
                            <div class="no-items-message" id="spike-no-items-message">No items selected</div>
                        </div>
                    </div>
                </div>
                <small class="form-hint">Add one or more items to monitor for spike threshold</small>
            </div>

            <!-- Spread-specific fields -->
            <!-- What: Dropdown to choose scope for spread alerts (all items or specific items) -->
            <!-- Why: Users may want to monitor spread on all items or a curated list of specific items -->
            <!-- How: Changes form visibility based on selection; "Specific Item(s)" handles both single and multiple items -->
            <div class="form-group" id="spread-scope-group" style="display: none;">
                <label for="spread-scope">Apply To</label>
                <select name="spread_scope" id="spread-scope" onchange="handleSpreadScopeChange()" tabindex="7">
                    <option value="multiple" selected>Specific Item(s)</option>
                    <option value="all">All Items</option>
                </select>

                <small class="form-hint">Choose to track specific items or all items at once</small>
            </div>

            <!-- Multi-item selector for spread alerts (shown when "Specific Item(s)" selected) -->
            <!-- What: Allows users to select multiple specific items to monitor for spread threshold -->
            <!-- Why: Users may want to monitor spread on a curated list of items instead of all or just one -->
            <!-- How: Uses box-style input with dropdown arrow - matching alert_detail.html styling -->
            <div class="form-group" id="spread-items-group" style="display: none;">
                <div class="label-with-notification">
                    <label for="spread-item-input">Items</label>
                    <!-- Small notification shown when items are added or not found -->
                    <span id="spread-item-notification" class="item-notification"></span>
                </div>
                <div class="multi-item-selector">
                    <div class="multi-item-selector-box">
                        <!-- Search input for adding new items -->
                        <input type="text" id="spread-item-input" placeholder="Search for item to add..." autocomplete="off" tabindex="8">
                        <!-- Dropdown toggle button with chevron arrow -->
                        <button type="button" class="multi-item-dropdown-toggle" id="spread-multi-item-toggle" title="Show selected items" tabindex="9">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <!-- Hidden input for form submission - stores comma-separated item IDs -->
                        <input type="hidden" name="spread_item_ids" id="spread-item-ids" value="">
                        <!-- Autocomplete suggestions dropdown (shown when typing) -->
                        <div id="spread-item-suggestions" class="multi-item-suggestions-dropdown"></div>
                        <!-- Selected items dropdown (shown when clicking arrow) -->
                        <div id="spread-selected-items-dropdown" class="multi-item-selected-dropdown">
                            <div class="selected-items-list" id="spread-selected-items-list">
                                <!-- Items will be populated here dynamically -->
                            </div>
                            <div class="no-items-message" id="spread-no-items-message">No items selected</div>
                        </div>
                    </div>
                </div>
                <small class="form-hint">Add one or more items to monitor for spread threshold</small>
            </div>

            <!-- Item Name -->
            <!-- What: Input field for selecting a single item to track (used by Above/Below Threshold alerts) -->
            <!-- Why: Some alert types need a specific item rather than multiple items or all items -->
            <!-- How: Uses autocomplete to help users find items by name -->
            <div class="form-group" id="item-name-group">
                <label for="item-name">Item Name</label>
                <input type="text" name="item_name" id="item-name" autocomplete="off" tabindex="8">
                <input type="hidden" name="item_id" id="item-id">
                <input type="hidden" name="is_all_items" id="is-all-items" value="false">
                <div id="item-suggestions" class="suggestions-dropdown"></div>
                <small class="form-hint">Item name you wish to track</small>
            </div>

            <!-- Price Threshold -->
            <!-- What: Input field for target price (used by Above/Below Threshold alerts) -->
            <!-- Why: Users need to specify the price that triggers the alert -->
            <div class="form-group" id="price-group">
                <label for="price">Price Threshold</label>
                <input type="number" name="price" id="price" tabindex="9">
                <small class="form-hint">Target price</small>
            </div>

            <!-- Reference Price -->
            <!-- What: Dropdown to choose which price to use for comparison (high, low, or average) -->
            <!-- Why: Different strategies monitor different price points -->
            <!-- Note: Used by Spike and Sustained alerts - Threshold has its own separate dropdown -->
            <div class="form-group" id="reference-group">
                <label for="reference">Reference Price</label>
                <select name="reference" id="reference" tabindex="16">
                    <option value="high">High (Instant Buy)</option>
                    <option value="low">Low (Instant Sell)</option>
                    <option value="average" selected>Average</option>
                </select>
                <small class="form-hint">Which price to monitor for alert calculations</small>
            </div>

            <!-- Percentage field (shown for spread or spike) -->
            <div class="form-group" id="percentage-group" style="display: none;">
                <label for="percentage">Percentage (%)</label>
                <input type="number" name="percentage" id="percentage" step="0.001" min="0.001" tabindex="11">
                <small class="form-hint">Target percentage your alert must hit</small>
            </div>

            <!-- Time frame field (shown for spike only) -->
            <div class="form-group" id="time-frame-group" style="display: none;">
                <label for="time-frame">Time Frame (minutes)</label>
                <input type="number" name="time_frame" id="time-frame" min="1" step="1" placeholder="e.g. 10" tabindex="17">
                <small class="form-hint">Time frame your alert must trigger within.</small>
            </div>

            <!-- Direction field (shown for spike only) -->
            <div class="form-group" id="direction-group" style="display: none;">
                <label for="direction">Direction</label>
                <select name="direction" id="direction" tabindex="10">
                    <option value="both" selected>Both</option>
                    <option value="up">Up</option>
                    <option value="down">Down</option>
                </select>

                <small class="form-hint">Direction your alert will track</small>
            </div>

            <!-- Sustained Move scope selector -->
            <div class="form-group" id="sustained-scope-group" style="display: none;">
                <label for="sustained-scope">Apply To</label>
                <select name="sustained_scope" id="sustained-scope" onchange="handleSustainedScopeChange()" tabindex="7">
                    <option value="specific" selected>Specific Item(s)</option>
                    <option value="all">All Items</option>
                </select>
                <small class="form-hint">Choose to track a single item or all items</small>
            </div>

            <!-- Multi-item selector for sustained move -->
            <!-- What: Allows users to select multiple specific items to monitor for sustained price moves -->
            <!-- Why: Users may want to monitor sustained moves on a curated list of items -->
            <!-- How: Uses box-style input with dropdown arrow - matching alert_detail.html styling -->
            <div class="form-group" id="sustained-items-group" style="display: none;">
                <div class="label-with-notification">
                    <label for="sustained-item-input">Items</label>
                    <!-- Small notification shown when items are added or not found -->
                    <span id="sustained-item-notification" class="item-notification"></span>
                </div>
                <div class="multi-item-selector">
                    <div class="multi-item-selector-box">
                        <!-- Search input for adding new items -->
                        <input type="text" id="sustained-item-input" placeholder="Search for item to add..." autocomplete="off" tabindex="8">
                        <!-- Dropdown toggle button with chevron arrow -->
                        <button type="button" class="multi-item-dropdown-toggle" id="sustained-multi-item-toggle" title="Show selected items" tabindex="9">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <!-- Hidden input for form submission - stores comma-separated item IDs -->
                        <input type="hidden" name="sustained_item_ids" id="sustained-item-ids" value="">
                        <!-- Autocomplete suggestions dropdown (shown when typing) -->
                        <div id="sustained-item-suggestions" class="multi-item-suggestions-dropdown"></div>
                        <!-- Selected items dropdown (shown when clicking arrow) -->
                        <div id="sustained-selected-items-dropdown" class="multi-item-selected-dropdown">
                            <div class="selected-items-list" id="sustained-selected-items-list">
                                <!-- Items will be populated here dynamically -->
                            </div>
                            <div class="no-items-message" id="sustained-no-items-message">No items selected</div>
                        </div>
                    </div>
                </div>
                <small class="form-hint">Add one or more items to monitor</small>
            </div>

            <!-- Min/Max price fields -->
            <!-- What: Input fields for filtering which items to monitor based on their price -->
            <!-- Why: Users may only want to track items within a certain price range (e.g., high-value items only) -->
            <!-- How: These filters apply when "All Items" is selected, narrowing down the monitored items -->
            <div class="form-group" id="min-price-group" style="display: none;">
                <label for="minimum-price">Minimum Price</label>
                <input type="number" name="minimum_price" id="minimum-price" min="0" tabindex="15">
                <small class="form-hint">The minimum price of an item to track</small>
            </div>
            <div class="form-group" id="max-price-group" style="display: none;">
                <label for="maximum-price">Maximum Price</label>
                <input type="number" name="maximum_price" id="maximum-price" min="0" tabindex="14">
                <small class="form-hint">The maximum price of an item to track</small>
            </div>

            <!-- Sustained Move specific fields -->
            <!-- What: Configuration inputs for Sustained Move alerts -->
            <!-- Why: Users need to define what constitutes a "sustained" price movement -->
            <div class="form-group" id="min-consecutive-moves-group" style="display: none;">
                <label for="min-consecutive-moves">Min Consecutive Moves</label>
                <input type="number" name="min_consecutive_moves" id="min-consecutive-moves" min="2" step="1"
                    placeholder="e.g. 5" tabindex="12">
                <small class="form-hint">Number of price changes in same direction</small>
            </div>
            <div class="form-group" id="min-move-percentage-group" style="display: none;">
                <label for="min-move-percentage">Min Move %</label>
                <input type="number" name="min_move_percentage" id="min-move-percentage" min="0.01" step="0.01"
                    placeholder="e.g. 0.5" tabindex="13">
                <small class="form-hint">Min % change to count as move</small>
            </div>
            <div class="form-group" id="min-volume-group" style="display: none;">
                <label for="min-volume">Min Volume</label>
                <input type="number" name="min_volume" id="min-volume" min="0" step="1" placeholder="e.g. 10000" tabindex="15">
                <small class="form-hint">Min trading volume</small>
            </div>
            <div class="form-group" id="volatility-buffer-group" style="display: none;">
                <label for="volatility-buffer-size">Volatility Buffer (N)</label>
                <input type="number" name="volatility_buffer_size" id="volatility-buffer-size" min="5" step="1"
                    placeholder="e.g. 20" tabindex="18">
                <small class="form-hint">Rolling buffer size for avg volatility</small>
            </div>
            <div class="form-group" id="volatility-multiplier-group" style="display: none;">
                <label for="volatility-multiplier">Volatility Multiplier (K)</label>
                <input type="number" name="volatility_multiplier" id="volatility-multiplier" min="0.1" step="0.1"
                    placeholder="e.g. 1.5" tabindex="19">
                <small class="form-hint">Streak must move â‰¥ K Ã— avg volatility</small>
            </div>

            <!-- Market Pressure Filter (sustained only) -->
            <!-- What: Filters for market pressure conditions on sustained move alerts -->
            <!-- Why: Users may want to only trigger alerts when there's buying/selling pressure -->
            <div class="form-group" id="pressure-strength-group" style="display: none;">
                <label for="min-pressure-strength">Market Pressure</label>
                <select name="min_pressure_strength" id="min-pressure-strength" tabindex="11">
                    <option value="">No Pressure Filter</option>
                    <option value="weak">Weak+ (any time delta)</option>
                    <option value="moderate">Moderate+ (&lt;5min)</option>
                    <option value="strong">Strong (&lt;1min)</option>
                </select>
                <small class="form-hint">BUY=up, SELL=down direction match</small>
            </div>
            <div class="form-group" id="pressure-spread-group" style="display: none;">
                <label for="min-pressure-spread">Min Spread % for Pressure</label>
                <input type="number" name="min_pressure_spread_pct" id="min-pressure-spread" min="0.01" step="0.01"
                    placeholder="e.g. 0.2" tabindex="14">
                <small class="form-hint">Minimum high-low spread % to confirm pressure</small>
            </div>

            <!-- =========================================================================
                 THRESHOLD ALERT SPECIFIC FIELDS
                 What: Form fields for creating Threshold alerts
                 Why: Threshold alerts need unique configuration options (items tracked, threshold type, etc.)
                 How: These fields are shown/hidden via JavaScript when "Threshold" alert type is selected
                 ========================================================================= -->
            
            <!-- Threshold: Items Tracked selector -->
            <!-- What: Dropdown to choose between tracking all items or specific items -->
            <!-- Why: Users may want to monitor threshold on all items or a curated list -->
            <!-- How: Shows/hides the specific items selector based on selection -->
            <!-- Note: "Specific Item(s)" is the default for consistency with other alert types -->
            <div class="form-group" id="threshold-items-tracked-group" style="display: none;">
                <label for="threshold-items-tracked">Apply To</label>
                <select name="threshold_items_tracked" id="threshold-items-tracked" onchange="handleThresholdItemsTrackedChange()" tabindex="7">
                    <option value="specific" selected>Specific Item(s)</option>
                    <option value="all">All Items</option>
                </select>
                <small class="form-hint">Choose to track specific items or all items at once</small>
            </div>

            <!-- Threshold: Multi-item selector (shown when "Specific Item(s)" is selected) -->
            <!-- What: Allows users to select multiple specific items to monitor for threshold -->
            <!-- Why: Users may want to monitor threshold on a curated list of items -->
            <!-- How: Uses box-style input with dropdown arrow - matching spread alert styling -->
            <div class="form-group" id="threshold-items-group" style="display: none;">
                <div class="label-with-notification">
                    <label for="threshold-item-input">Item(s)</label>
                    <!-- Small notification shown when items are added or not found -->
                    <span id="threshold-item-notification" class="item-notification"></span>
                </div>
                <div class="multi-item-selector">
                    <div class="multi-item-selector-box">
                        <!-- Search input for adding new items -->
                        <input type="text" id="threshold-item-input" placeholder="Search for item to add..." autocomplete="off" tabindex="8">
                        <!-- Dropdown toggle button with chevron arrow -->
                        <button type="button" class="multi-item-dropdown-toggle" id="threshold-multi-item-toggle" title="Show selected items" tabindex="9">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <!-- Hidden input for form submission - stores comma-separated item IDs -->
                        <input type="hidden" name="threshold_item_ids" id="threshold-item-ids" value="">
                        <!-- Autocomplete suggestions dropdown (shown when typing) -->
                        <div id="threshold-item-suggestions" class="multi-item-suggestions-dropdown"></div>
                        <!-- Selected items dropdown (shown when clicking arrow) -->
                        <div id="threshold-selected-items-dropdown" class="multi-item-selected-dropdown">
                            <div class="selected-items-list" id="threshold-selected-items-list">
                                <!-- Items will be populated here dynamically -->
                            </div>
                            <div class="no-items-message" id="threshold-no-items-message">No items selected</div>
                        </div>
                    </div>
                </div>
                <small class="form-hint">Add one or more items to monitor for threshold</small>
            </div>

            <!-- Threshold: Direction selector -->
            <!-- What: Dropdown to choose whether to alert on price going up or down -->
            <!-- Why: Users may only care about price increases (for selling) or decreases (for buying) -->
            <div class="form-group" id="threshold-direction-group" style="display: none;">
                <label for="threshold-direction">Above or Below</label>
                <select name="threshold_direction" id="threshold-direction" tabindex="10">
                    <option value="up" selected>Above</option>
                    <option value="down">Below</option>
                </select>
                <small class="form-hint">Alert when price hits percentage threshold above or below its current value (or above/below a specified value) </small>
            </div>

            <!-- Threshold: Threshold Type selector -->
            <!-- What: Dropdown to choose between percentage-based or value-based threshold -->
            <!-- Why: Users may want "10% increase" or "1000gp increase" depending on their strategy -->
            <!-- How: Auto-selects percentage when All Items or multiple specific items selected -->
            <div class="form-group" id="threshold-type-group" style="display: none;">
                <label for="threshold-type">
                    Threshold Type
                    <!-- Locked indicator: Shows when threshold type is forced to percentage -->
                    <!-- What: Visual indicator (ðŸš«) that the dropdown is locked -->
                    <!-- Why: Users need to understand why they can't change the threshold type -->
                    <!-- How: Icon appears when dropdown is disabled; clicking shows explanatory tooltip -->
                    <span id="threshold-type-locked-indicator" class="locked-indicator" style="display: none;" title="Click for more info">ðŸš«</span>
                </label>
                <select name="threshold_type" id="threshold-type" tabindex="11">
                    <option value="percentage" selected>Percentage</option>
                    <option value="value">Value (GP)</option>
                </select>
                <!-- Tooltip that appears when user clicks the locked indicator -->
                <!-- What: Explanation popup for why threshold type is locked -->
                <!-- Why: Provides context so users understand the restriction -->
                <!-- How: Shown/hidden via JavaScript when indicator is clicked -->
                <div id="threshold-type-locked-tooltip" class="locked-tooltip" style="display: none;">
                    <span class="locked-tooltip-close">&times;</span>
                    <p>Value-based thresholds can only be used when monitoring a <strong>single item</strong>.</p>
                    <p>When monitoring multiple items or all items, percentage-based thresholds must be used because each item has a different price.</p>
                </div>
                <small class="form-hint">How to measure the threshold (percentage only for multiple items)</small>
            </div>

            <!-- Threshold: Threshold value input -->
            <!-- What: Numeric input for the threshold amount -->
            <!-- Why: Users need to specify how much change should trigger the alert -->
            <!-- How: Value is interpreted as percentage or GP based on threshold_type selection -->
            <div class="form-group" id="threshold-value-group" style="display: none;">
                <label for="threshold-value">Threshold</label>
                <input type="number" name="threshold_value" id="threshold-value" step="0.01" min="0.01" placeholder="e.g. 5" tabindex="13">
                <small class="form-hint" id="threshold-value-hint">The percentage or value change that triggers the alert (use numbers between 0-100)</small>
            </div>

            <!-- Threshold: Reference Price selector -->
            <!-- What: Dropdown to choose which price to monitor (high, low, or average) -->
            <!-- Why: Different strategies use different reference prices -->
            <!-- How: Determines which current price is compared against the threshold -->
            <div class="form-group" id="threshold-reference-group" style="display: none;">
                <label for="threshold-reference">Reference Price</label>
                <select name="threshold_reference" id="threshold-reference" tabindex="12">
                    <option value="high">High (Instant Buy)</option>
                    <option value="low">Low (Instant Sell)</option>
                    <option value="average" selected>Average</option>
                </select>
                <small class="form-hint">Which price to monitor for threshold changes</small>
            </div>

            <!-- =====================================================================================
                 NOTIFICATION OPTIONS (ALWAYS LAST)

                 What: These are the two â€œdelivery channelâ€ toggles for an alert.
                 Why: You requested these appear LAST for Threshold/Sustained/Spike/Spread (and visually this
                      is also the most natural place for them for other alert types).
                 How: We give the container divs stable IDs so CSS can:
                      1) force them to the end of the form (via flexbox order)
                      2) render them on ONE LINE (by removing the old 100%-width rule)
                 ===================================================================================== -->
            <div class="form-check d-flex align-items-center" style="padding-right: 4em; margin-top:35px !important" id="show-notification-group">
                    <input style = "transform: scale(1.35); margin-top: 0;" type="checkbox" class="form-check-input me-2" name="show_notification" id="show-notification" checked tabindex="90">
                <label class="form-check-label">
                    <span>Show Alert Notification?</span>
                </label>
            </div>

            <div class="form-check d-flex align-items-center" style="padding-right: 4em; margin-top:35px !important" id="sms-notification-group">
                <input style = "transform: scale(1.35); margin-top: 0;" type="checkbox" class="form-check-input me-2" name="email_notification" id="email-notification" tabindex="91">
                <label class="form-check-label">
                  
                    <span>Receive SMS Notification?</span>
                </label>
            </div>

            <button type="submit" class="btn-create-alert" tabindex="100">Create Alert</button>
        </form>
    </div>
</div>

<!-- Spread Details Modal -->
<div id="spread-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spread Alert Details</h2>
            <button class="modal-close" onclick="closeSpreadModal()">&times;</button>
        </div>
        <div id="spread-modal-body">
            <ul id="spread-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpreadModal()">Close</button>
        </div>
    </div>
</div>

<!-- Spike Details Modal -->
<div id="spike-modal" class="modal" style="display: none;">
    <div class="modal-content modal-content-large">
        <div class="modal-header">
            <h2>Spike Alert Details</h2>
            <button class="modal-close" onclick="closeSpikeModal()">&times;</button>
        </div>
        <div id="spike-modal-body">
            <ul id="spike-items-list"></ul>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-cancel" onclick="closeSpikeModal()">Close</button>
        </div>
    </div>
</div>

<!-- Group Alerts Modal -->
<div id="group-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Organize Alerts</h2>
            <button class="modal-close" onclick="GroupManager.close()">&times;</button>
        </div>
        <div class="form-group">
            <label>Existing Groups</label>
            <div id="group-list" class="group-list"></div>
        </div>
        <div class="form-group">
            <label for="new-group-input">Add New Groups</label>
            <input type="text" id="new-group-input" placeholder="Comma-separated, e.g. Bossing, Supplies">
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="GroupManager.save()">Save</button>
            <button type="button" class="btn-delete-group" onclick="GroupManager.deleteSelectedGroups()">Delete
                Group(s)</button>
            <button type="button" class="btn-cancel" onclick="GroupManager.close()">Cancel</button>
        </div>
    </div>
</div>

<!-- Groups Filter Modal -->
<div id="groups-filter-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Filter by Groups</h2>
            <button class="modal-close" onclick="closeGroupsFilterModal()">&times;</button>
        </div>
        <div class="form-group">
            <label>Select Groups to Display</label>
            <div id="groups-filter-list" class="group-list pill-padding"></div>
            <p id="no-groups-message" class="no-alerts" style="display: none;">No groups available. Create groups by
                organizing your alerts first.</p>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-save" onclick="applyGroupsFilter()">Apply Filter</button>
            <button type="button" class="btn-cancel" onclick="closeGroupsFilterModal()">Cancel</button>
        </div>
    </div>
</div>

<!-- Price Filter Modal -->
<div id="price-filter-modal" class="modal filter-modal-styled" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Filter by Price</h2>
            <button class="modal-close" onclick="closePriceFilterModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="filter-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </div>
            <p class="filter-description">Show alerts with current price in a specific range.</p>
            <div class="form-group">
                <label for="price-filter-min">Minimum Price</label>
                <input type="number" id="price-filter-min" placeholder="No minimum">
            </div>
            <div class="form-group">
                <label for="price-filter-max">Maximum Price</label>
                <input type="number" id="price-filter-max" placeholder="No maximum">
            </div>
        </div>
        <div class="modal-buttons">
            <button type="button" class="btn-clear" onclick="clearPriceFilter()">Clear</button>
            <button type="button" class="btn-save" onclick="applyPriceFilter()">Apply Filter</button>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-confirm-modal" class="modal delete-confirm-modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Confirm Delete</h2>
            <button class="modal-close" onclick="closeDeleteConfirmModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="delete-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            </div>
            <p id="delete-confirm-message">Are you sure you want to delete the selected alerts?</p>
            <p class="delete-warning">This action cannot be undone.</p>
        </div>
        <div class="modal-footer">
            <button type="button" class="btn-cancel" onclick="closeDeleteConfirmModal()">Cancel</button>
            <button type="button" class="btn-confirm-delete" onclick="executeDelete()">Delete</button>
        </div>
    </div>
</div>
<style>
    :root {
        /* Neutrals */
        --bg: #F8F9FA;
        --surface: #FFFFFF;
        --surface-2: #F5F6F8;
        --border: #E5E7EB;
        --text: #374151;
        --text-muted: #6B7280;
        --muted: #6B7280;
        /* Brand - muted */
        --primary: #6366F1;
        --primary-hover: #5558E3;
        /* Semantics - muted */
        --success: #22C55E;
        --success-muted: #4ADE80;
        --danger: #EF4444;
        --danger-muted: #F87171;
        --warning: #F59E0B;
        --info: #3B82F6;
        /* Hover */
        --hover-orange: #F97316;
        --hover-orange-light: #FDBA74;
    }

    /* Alert Help Button */
    .alert-help-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
        padding: 8px 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .alert-help-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .alert-help-btn svg {
        flex-shrink: 0;
    }

    /* Alert Help Modal */
    .alert-help-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        animation: fadeIn 0.2s ease;
    }

    .alert-help-modal-overlay.open {
        display: flex;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
    }

    .alert-help-modal {
        background: white;
        border-radius: 16px;
        max-width: 800px;
        width: 100%;
        max-height: 85vh;
        overflow: hidden;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .alert-help-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .alert-help-modal-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .alert-help-modal-close {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        font-size: 24px;
        line-height: 1;
    }

    .alert-help-modal-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }

    .alert-help-modal-body {
        padding: 0;
        overflow-y: auto;
        max-height: calc(85vh - 80px);
    }

    .alert-help-tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
        background: var(--surface-2);
        overflow-x: auto;
    }

    .alert-help-tab {
        padding: 14px 20px;
        background: none;
        border: none;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        border-bottom: 3px solid transparent;
        margin-bottom: -1px;
    }

    .alert-help-tab:hover {
        color: var(--text);
        background: rgba(0, 0, 0, 0.03);
    }

    .alert-help-tab.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        background: white;
    }

    .alert-help-content {
        padding: 24px;
    }

    .alert-help-section {
        display: none;
    }

    .alert-help-section.active {
        display: block;
    }

    .alert-help-section h3 {
        font-size: 22px;
        font-weight: 600;
        color: var(--text);
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .alert-help-section h3 .alert-type-badge {
        font-size: 12px;
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: 500;
    }

    .alert-type-badge.above {
        background: #DCFCE7;
        color: #166534;
    }

    .alert-type-badge.below {
        background: #FEE2E2;
        color: #991B1B;
    }

    .alert-type-badge.spread {
        background: #E0E7FF;
        color: #3730A3;
    }

    .alert-type-badge.spike {
        background: #FEF3C7;
        color: #92400E;
    }

    .alert-type-badge.sustained {
        background: #F3E8FF;
        color: #6B21A8;
    }

    /* Threshold alert badge - uses a teal/cyan color scheme to distinguish from other alert types */
    .alert-type-badge.threshold {
        background: #CCFBF1;
        color: #0F766E;
    }

    .alert-help-section .subtitle {
        font-size: 15px;
        color: var(--text-muted);
        margin-bottom: 20px;
        line-height: 1.6;
    }

    .alert-help-card {
        background: var(--surface-2);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .alert-help-card h4 {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
        margin: 0 0 12px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .alert-help-card h4 svg {
        color: var(--primary);
    }

    .alert-help-card p {
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.7;
        margin: 0;
    }

    .alert-help-card ul {
        margin: 12px 0 0 0;
        padding-left: 20px;
    }

    .alert-help-card li {
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.8;
    }

    .alert-help-card li strong {
        color: var(--text);
    }

    .recommended-values {
        background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        border: 1px solid #86efac;
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px;
    }

    .recommended-values h4 {
        font-size: 15px;
        font-weight: 600;
        color: #166534;
        margin: 0 0 12px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .recommended-values .value-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
    }

    .recommended-value {
        background: white;
        border-radius: 8px;
        padding: 12px 16px;
        border: 1px solid #bbf7d0;
    }

    .recommended-value .label {
        font-size: 12px;
        color: #166534;
        font-weight: 500;
        margin-bottom: 4px;
    }

    .recommended-value .value {
        font-size: 16px;
        font-weight: 600;
        color: #14532d;
    }

    .example-scenario {
        background: #fffbeb;
        border: 1px solid #fde68a;
        border-radius: 12px;
        padding: 20px;
        margin-top: 16px;
    }

    .example-scenario h4 {
        font-size: 14px;
        font-weight: 600;
        color: #92400e;
        margin: 0 0 10px 0;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .example-scenario p {
        font-size: 14px;
        color: #78350f;
        line-height: 1.7;
        margin: 0;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 30px;
    }

    .page-header-icon {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
    }

    .page-header-icon svg {
        width: 24px;
        height: 24px;
        color: white;
    }

    .page-header-text h1 {
        font-size: 1.75rem;
        font-weight: 700;
        color: var(--text);
        margin: 0 0 2px 0;
        letter-spacing: -0.02em;
    }

    .page-header-text p {
        color: var(--muted);
        margin: 0;
        font-size: 0.95rem;
    }

    /* Tabs styling */
    .alert-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 24px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 0;
    }

    .tab-btn {
        padding: 12px 24px;
        border: none;
        background: transparent;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        color: var(--muted);
        border-bottom: 3px solid transparent;
        margin-bottom: -1px;
        transition: all 0.2s ease;
        border-radius: 8px 8px 0 0;
    }

    .tab-btn:hover {
        color: var(--text);
        background: var(--surface-2);
    }

    .tab-btn.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        background: transparent;
    }

    .tab-content {
        padding: 0;
    }

    /* Alert items */
    .alerts-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .alert-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        margin-bottom: 10px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-left: 4px solid var(--primary);
        border-radius: 10px;
        transition: all 0.2s ease;
        max-height: 200px;
        overflow: hidden;
    }

    .alert-item:hover {
        transform: translateX(4px);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        border-left-color: var(--primary-hover);
    }

    .alert-item.deleting {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }

    .alert-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
    }

    .alert-text {
        font-size: 0.95rem;
        color: var(--text);
    }

    .alert-sort-info {
        font-size: 0.8rem;
        color: var(--muted);
        font-style: italic;
    }

    .alert-status {
        font-weight: 600;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        letter-spacing: 0.3px;
        flex-shrink: 0;
        margin-right: 8px;
    }

    .alert-status-active {
        color: #16A34A;
        background: #DCFCE7;
    }

    .alert-status-inactive {
        color: #6B7280;
        background: #F3F4F6;
    }

    .alert-triggered {
        font-weight: 600;
        color: #7C3AED;
        background: #EDE9FE;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        letter-spacing: 0.3px;
        flex-shrink: 0;
    }

    .alert-icon {
        width: 32px;
        height: 32px;
        object-fit: contain;
        flex-shrink: 0;
    }

    .alert-icon-placeholder {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        flex-shrink: 0;
    }

    .alert-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
        margin-right: 4px;
    }

    .no-alerts {
        color: var(--muted);
        font-style: italic;
        padding: 40px 20px;
        text-align: center;
        background: var(--surface);
        border: 1px dashed var(--border);
        border-radius: 12px;
    }

    /* Loading Indicator */
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        gap: 16px;
    }

    .loading-spinner {
        width: 48px;
        height: 48px;
        border: 4px solid var(--border);
        border-top: 4px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .loading-text {
        font-size: 1rem;
        font-weight: 500;
        color: var(--muted);
    }

    /* Alert groups */
    .alert-group {
        margin-bottom: 25px;
    }

    .alert-group-header {
        font-size: 1rem;
        font-weight: 600;
        color: var(--primary);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 2px solid var(--hover-orange);
    }

    /* Actions wrapper */
    .alert-actions-wrapper {
        margin-bottom: 4px;
    }

    .alert-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: nowrap;
    }

    .alert-actions-left {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-shrink: 0;
    }

    /* Search Bar */
    .alert-search-wrapper {
        position: relative;
        display: flex;
        align-items: center;
    }

    .alert-search-icon {
        position: absolute;
        left: 10px;
        width: 16px;
        height: 16px;
        color: var(--text-muted);
        pointer-events: none;
    }

    .alert-search-input {
        padding: 8px 32px 8px 32px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 14px;
        width: 300px;
        transition: all 0.15s;
    }

    .alert-search-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .alert-search-input::placeholder {
        color: var(--text-muted);
    }

    .alert-search-clear {
        position: absolute;
        right: 8px;
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        font-size: 16px;
        padding: 2px 6px;
        border-radius: 4px;
        display: none;
    }

    .alert-search-clear:hover {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
    }

    .alert-search-wrapper.has-value .alert-search-clear {
        display: block;
    }

    .alert-actions-right {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .alert-actions-controls {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* Custom Dropdowns */
    .custom-dropdown-wrapper {
        position: relative;
    }

    .btn-dropdown {
        padding: 8px 14px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
    }

    .btn-dropdown:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }

    .btn-dropdown.has-active {
        background: rgba(99, 102, 241, 0.1);
        border-color: var(--primary);
        color: var(--primary);
    }

    .btn-dropdown svg {
        width: 16px;
        height: 16px;
    }

    .filter-badge {
        background: var(--primary);
        color: white;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 4px;
    }

    .custom-dropdown-menu {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 6px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        min-width: 180px;
        z-index: 1000;
        display: none;
        padding: 6px;
    }

    /* Right-align sort and filter dropdowns on desktop */
    #sortDropdownMenu,
    #filterDropdownMenu {
        left: auto;
        right: 0;
    }

    .custom-dropdown-menu.show {
        display: block;
    }

    .custom-dropdown-header {
        padding: 8px 10px 6px;
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 6px;
    }

    .custom-dropdown-item {
        padding: 10px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.15s;
        border-radius: 6px;
        margin: 2px 0;
        background: var(--surface-2);
        border: 1px solid transparent;
    }

    .custom-dropdown-item:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.3);
    }

    .custom-dropdown-item.active {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
        color: var(--primary);
    }

    .custom-dropdown-item.active:hover {
        background: rgba(99, 102, 241, 0.25);
    }

    .custom-dropdown-item .filter-check,
    .custom-dropdown-item .sort-check {
        color: var(--primary);
        display: none;
        font-weight: 600;
    }

    .custom-dropdown-item.active .sort-check {
        display: inline;
    }

    .custom-dropdown-item .filter-clear {
        display: none;
        color: var(--danger);
        font-size: 18px;
        font-weight: 600;
        line-height: 1;
        padding: 0 2px;
        border-radius: 4px;
        transition: all 0.15s;
    }

    .custom-dropdown-item.active .filter-clear {
        display: inline;
    }

    .custom-dropdown-item .filter-clear:hover {
        background: rgba(239, 68, 68, 0.15);
    }

    /* Sort controls */
    .sort-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    /* Sort indicator - styled like flips page */
    .sort-indicator-wrapper {
        position: relative;
    }

    .sort-indicator {


        margin-top: 7px;
        display: none;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 13px;
        color: var(--text);
        transition: all 0.3s ease;
    }

    .sort-indicator.active {
        display: inline-flex;
    }

    .sort-indicator-label {
        color: var(--text-muted);
    }

    .sort-indicator-value {
        font-weight: 500;
        color: var(--primary);
    }

    .sort-indicator-arrow {
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
        transition: all 0.15s;
        font-size: 14px;
        user-select: none;
        background: var(--surface-2);
        border: 1px solid var(--border);
        margin-left: 4px;
    }

    .sort-indicator-arrow:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.4);
    }

    .sort-indicator-clear {
        cursor: pointer;
        color: var(--danger);
        font-size: 16px;
        font-weight: 600;
        line-height: 1;
        padding: 0 4px;
        border-radius: 4px;
        transition: all 0.15s;
        margin-left: 4px;
    }

    .sort-indicator-clear:hover {
        background: rgba(239, 68, 68, 0.15);
    }

    /* Mobile sort indicator row - hidden by default, shown at smaller breakpoints */
    .sort-indicator-mobile-row {
        display: none;
    }

    .sort-indicator-mobile-row .sort-indicator {
        display: none;
    }

    .sort-indicator-mobile-row .sort-indicator.active {
        display: inline-flex;
    }

    /* Filter and sort tags */
    .alert-indicators {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        flex-wrap: wrap-reverse;
        gap: 8px;
        margin-top: 4px;
    }

    .filter-tags {
        display: contents;
    }

    .sort-tag-holder {
        display: contents;
    }

    .filter-tag {
        display: inline-flex;
        align-items: center;
        background: var(--primary);
        color: white;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        animation: filterTagIn 0.3s ease forwards;
        max-width: 200px;
        overflow: hidden;
    }

    .filter-tag.removing {
        animation: filterTagOut 0.3s ease forwards;
    }

    @keyframes filterTagIn {
        from {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
        }

        to {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 12px;
        }
    }

    @keyframes filterTagOut {
        from {
            opacity: 1;
            transform: scale(1);
            max-width: 200px;
            padding: 6px 12px;
        }

        to {
            opacity: 0;
            transform: scale(0.8);
            max-width: 0;
            padding: 0;
        }
    }

    .filter-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 6px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.8;
        padding: 0;
    }

    .filter-tag-remove:hover {
        opacity: 1;
    }

    .sort-tag {
        background: var(--hover-orange);
        color: white;
        padding: 6px 12px;
        border-radius: 20px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
        font-size: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .sort-tag-remove {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        margin-left: 4px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.85;
        padding: 0;
    }

    .sort-tag-remove:hover {
        opacity: 1;
    }

    /* Delete Confirmation Modal */
    .delete-confirm-modal .modal-content {
        max-width: 400px;
        border-radius: 12px;
        overflow: hidden;
    }

    .delete-confirm-modal .modal-header {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        color: white;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .delete-confirm-modal .modal-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
    }

    .delete-confirm-modal .modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        opacity: 0.8;
        line-height: 1;
    }

    .delete-confirm-modal .modal-close:hover {
        opacity: 1;
    }

    .delete-confirm-modal .modal-body {
        padding: 24px;
        text-align: center;
    }

    .delete-confirm-modal .delete-icon {
        width: 64px;
        height: 64px;
        background: #FEE2E2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
    }

    .delete-confirm-modal .delete-icon svg {
        width: 32px;
        height: 32px;
        color: #DC2626;
    }

    .sort-indicator {
        margin-top: 0px;
    }

    .delete-confirm-modal .modal-body p {
        color: var(--text);
        margin: 0 0 8px 0;
    }

    .delete-confirm-modal .delete-warning {
        color: var(--muted);
        font-size: 13px;
        margin-top: 8px;
    }

    .delete-confirm-modal .modal-footer {
        padding: 16px 24px;
        display: flex;
        justify-content: center;
        gap: 12px;
        border-top: 1px solid var(--border);
    }

    .delete-confirm-modal .btn-cancel {
        background: var(--surface-2);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 10px 24px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
    }

    .delete-confirm-modal .btn-cancel:hover {
        background: var(--surface);
        border-color: var(--muted);
    }

    .delete-confirm-modal .btn-confirm-delete {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        border: none;
        color: white;
        padding: 10px 24px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
    }

    .delete-confirm-modal .btn-confirm-delete:hover {
        background: linear-gradient(135deg, #B91C1C 0%, #991B1B 100%);
        transform: translateY(-1px);
    }

    /* Success notifications */
    .triggered-notification {
        background: linear-gradient(135deg, #22C55E 0%, #16A34A 100%);
        color: white;
        padding: 14px 40px 14px 16px;
        border-radius: 10px;
        margin-bottom: 12px;
        position: relative;
        font-weight: 500;
        transition: all 0.3s ease;
        max-height: 100px;
        overflow: hidden;
    }

    /* Hide non-status triggered notifications until JS validates them */
    .triggered-notification[data-alert-id]:not(.status-notification):not(.validated) {
        display: none;
    }

    .triggered-notification.dismissing {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }

    .triggered-notification .dismiss-btn {
        position: absolute;
        top: 50%;
        right: 12px;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        opacity: 0.8;
    }

    .triggered-notification .dismiss-btn:hover {
        opacity: 1;
    }

    /* Error notification variant (red) */
    .triggered-notification.error-notification {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
    }

    /* Create alert form */
    .create-alert-form {
        max-width: 100%;
        background: var(--surface);
        padding: 24px;
        border-radius: 12px;
        border: 1px solid var(--border);
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: flex-start;
    }

    .create-alert-form>.form-group {
        width: 250px;
        flex-shrink: 0;
        margin-bottom: 0;
    }

    /* =====================================================================================
       CREATE ALERT FORM: NOTIFICATION OPTIONS LAYOUT

       What: Controls how the two notification checkbox rows are laid out.
       Why: Previously these two checkboxes were forced to stack because they were set to 100% width.
            You requested they render on one line (side-by-side) and still live at the bottom.
       How:
         - Remove the forced full-width sizing so each checkbox group behaves like a normal 250px form-group.
         - The â€œalways lastâ€ behavior is enforced separately via the flexbox `order` rules below.
       ===================================================================================== */
    .create-alert-form>.checkbox-group {
        width: 250px;
        flex-basis: 250px;
    }

    .create-alert-form>button {
        width: 100%;
        flex-basis: 100%;
        margin-top: 8px;
        order: 1000; /* Keep the submit button AFTER the checkbox options. */
    }

    /* =====================================================================================
       CREATE ALERT FORM: FIELD ORDER STANDARDIZATION (Threshold / Sustained / Spike / Spread)

       What: Standardizes the visible field order for the alert types you called out.
       Why: The create form is a single shared template where JS shows/hides many different fields.
            Moving large HTML blocks around is fragile and hard to maintain; flexbox ordering lets us
            enforce a consistent UX while keeping backend field names/IDs and JS selectors unchanged.
       How:
         - The form container is `display: flex`.
         - Each direct child `.form-group` is a flex item.
         - We assign explicit `order` values to the *field containers* (divs with IDs like
           `#spike-scope-group`, `#min-price-group`, etc.).
         - Hidden fields (display:none) naturally disappear from the layout, so the â€œvisible orderâ€
           becomes the standardized order automatically.

       Requested UX sequence for Threshold/Sustained/Spike/Spread:
         1) Alert Name (and Custom Name if enabled)  [these already appear before Group in the template]
         2) Group
         3) Apply To
         4) If â€œSpecific Itemsâ€, the item selector immediately after
         5) Remaining visible inputs alphabetical by label (Direction, Maximum Price, Minimum Price, ...)
         6) Notification options last (Show Alert Notification? + Receive SMS Notification)
       ===================================================================================== */

    /* --- Apply To (scope) selectors --- */
    .create-alert-form > #spike-scope-group { order: 50; }
    .create-alert-form > #spread-scope-group { order: 51; }
    .create-alert-form > #sustained-scope-group { order: 52; }
    .create-alert-form > #threshold-items-tracked-group { order: 53; }

    /* --- Item selectors (must appear immediately after Apply To when relevant) --- */
    .create-alert-form > #spike-items-group { order: 60; }
    .create-alert-form > #spread-items-group { order: 61; }
    .create-alert-form > #sustained-items-group { order: 62; }
    .create-alert-form > #threshold-items-group { order: 63; }
    .create-alert-form > #item-name-group { order: 64; }

    /* --- Alphabetical remainder (by visible label text) --- */
    .create-alert-form > #direction-group { order: 70; }
    .create-alert-form > #threshold-direction-group { order: 71; }

    .create-alert-form > #pressure-strength-group { order: 80; }  /* Market Pressure */

    .create-alert-form > #max-price-group { order: 81; }          /* Maximum Price */

    .create-alert-form > #min-consecutive-moves-group { order: 82; }
    .create-alert-form > #min-move-percentage-group { order: 83; }
    .create-alert-form > #pressure-spread-group { order: 84; }
    .create-alert-form > #min-volume-group { order: 85; }

    .create-alert-form > #min-price-group { order: 86; }          /* Minimum Price */

    .create-alert-form > #percentage-group { order: 90; }
    .create-alert-form > #price-group { order: 91; }

    .create-alert-form > #reference-group { order: 95; }
    .create-alert-form > #threshold-reference-group { order: 96; }

    .create-alert-form > #threshold-value-group { order: 100; }
    .create-alert-form > #threshold-type-group { order: 72; }  /* Immediately after Direction (71) */

    .create-alert-form > #time-frame-group { order: 110; }

    .create-alert-form > #volatility-buffer-group { order: 120; }
    .create-alert-form > #volatility-multiplier-group { order: 121; }

    /* --- Notification options (must be last, but still before the submit button) --- */
    .create-alert-form > #show-notification-group { order: 900; }
    .create-alert-form > #sms-notification-group { order: 901; }

    @media (max-width: 600px) {
        .create-alert-form>.form-group {
            width: 100%;
        }

        /* =====================================================================================
           MOBILE: KEEP NOTIFICATION CHECKBOXES SIDE-BY-SIDE

           What: Overrides the mobile "full width" rule specifically for the two checkbox rows.
           Why: The requirement is to render "Show Alert Notification" + "Receive SMS Notification" on
                ONE line rather than stacked.
           How: Use 50% width (minus half the flex gap) so two items fit in a single row.
           ===================================================================================== */
        .create-alert-form>.checkbox-group {
            width: calc(50% - 8px);
            flex-basis: calc(50% - 8px);
        }
    }

    .form-error-container {
        margin-bottom: 16px;
    }

    .actions-error-container {
        margin-bottom: 12px;
    }

    .form-group {
        margin-bottom: 18px;
        position: relative;
    }

    .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: var(--text);
        font-size: 14px;
    }

    .form-group input,
    .form-group select {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 15px;
        color: var(--text);
        background: var(--surface);
        transition: all 0.15s;
    }

    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }

    .form-group input::placeholder {
        color: var(--muted);
    }

    .form-hint {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-top: 4px;
        line-height: 1.4;
    }

    /* =========================================================================
       LOCKED FIELD INDICATOR STYLES
       What: Styles for the locked indicator icon and tooltip
       Why: Provides visual feedback when a dropdown is locked and explains why
       How: Icon appears inline with label; tooltip appears on click
       ========================================================================= */
    
    /* Locked indicator icon - appears next to label when field is locked */
    /* What: A no-entry symbol (ðŸš«) that indicates the field cannot be changed */
    /* Why: Users need visual feedback that the field is intentionally locked */
    /* How: Displayed inline with the label, with hover effect to indicate clickability */
    .locked-indicator {
        margin-left: 8px;
        cursor: pointer;
        font-size: 14px;
        opacity: 0.8;
        transition: opacity 0.15s, transform 0.15s;
        display: inline-block;
        vertical-align: middle;
    }
    
    /* Hover state for locked indicator - makes it clear it's clickable */
    .locked-indicator:hover {
        opacity: 1;
        transform: scale(1.15);
    }
    
    /* Tooltip container - explains why the field is locked */
    /* What: A popup box with explanation text */
    /* Why: Users need to understand why they can't change the threshold type */
    /* How: Positioned 15px below the locked indicator icon, styled as an info box */
    .locked-tooltip {
        position: absolute;
        top: 30px;  /* Position 15px below the label line (label ~15px + 15px gap) */
        left: 0;
        right: 0;
        padding: 12px 16px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 100;
        font-size: 13px;
        line-height: 1.5;
        color: var(--text);
    }
    
    /* Tooltip paragraph spacing */
    .locked-tooltip p {
        margin: 0 0 8px 0;
    }
    
    /* Remove bottom margin from last paragraph */
    .locked-tooltip p:last-of-type {
        margin-bottom: 0;
    }
    
    /* Close button for the tooltip */
    /* What: X button in top-right corner to dismiss the tooltip */
    /* Why: Users need a way to close the tooltip after reading */
    /* How: Positioned absolutely, styled as a subtle close button */
    .locked-tooltip-close {
        position: absolute;
        top: 8px;
        right: 12px;
        cursor: pointer;
        font-size: 18px;
        color: var(--muted);
        line-height: 1;
        transition: color 0.15s;
    }
    
    .locked-tooltip-close:hover {
        color: var(--text);
    }
    
    /* Disabled/locked select styling */
    /* What: Red background for disabled dropdown to indicate it's locked */
    /* Why: Provides strong visual feedback that the field cannot be changed */
    /* How: Targets disabled select elements with a light red background */
    select:disabled {
        background-color: rgba(239, 68, 68, 0.15);  /* Light red background */
        border-color: rgba(239, 68, 68, 0.4);       /* Red-tinted border */
        cursor: not-allowed;
    }

    /* =========================================================================
       MULTI-ITEM SELECTOR STYLES
       What: Styles for the multi-item selector box with dropdown arrow and selected items
       Why: Matches the styling used in alert_detail.html for visual consistency
       How: Uses a box-style input with dropdown toggle, showing selected items in a dropdown list
       ========================================================================= */
    
    /* Main multi-item selector container - holds the input box and dropdown */
    .multi-item-selector {
        position: relative;
    }
    
    /* The selector box containing search input and dropdown toggle arrow */
    /* What: Container that looks like a single input field with a dropdown arrow */
    /* Why: Provides a consistent look with native select elements and alert_detail.html */
    .multi-item-selector-box {
        position: relative;
        display: flex;
        align-items: stretch;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--surface);
        overflow: visible;
        transition: all 0.15s;
    }
    
    /* Focus state for the selector box - highlights when user is interacting */
    .multi-item-selector-box:focus-within {
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    
    /* Search input inside the box - takes up most of the width */
    /* What: Text input where users type to search for items to add */
    /* Why: Allows free-text search with autocomplete suggestions */
    .multi-item-selector-box input[type="text"] {
        flex: 1;
        border: none;
        outline: none;
        padding: 10px 14px;
        font-size: 15px;
        color: var(--text);
        background: transparent;
        border-radius: 8px 0 0 8px;
        min-width: 0;
    }
    
    .multi-item-selector-box input[type="text"]::placeholder {
        color: #9ca3af;
    }
    
    /* Dropdown toggle button with chevron arrow */
    /* What: Button on the right side of the input that reveals selected items */
    /* Why: Shows users there's a dropdown and provides access to view/manage selected items */
    .multi-item-dropdown-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        border: none;
        border-left: 1px solid var(--border);
        background: #f9fafb;
        cursor: pointer;
        transition: background-color 0.15s ease;
        border-radius: 0 8px 8px 0;
    }
    
    .multi-item-dropdown-toggle:hover {
        background: #f3f4f6;
    }
    
    /* Active state when dropdown is open - green background to indicate active */
    .multi-item-dropdown-toggle.active {
        background: #a7f3d0;
    }
    
    .multi-item-dropdown-toggle svg {
        width: 20px;
        height: 20px;
        color: #6b7280;
        transition: transform 0.2s ease;
    }
    
    /* Rotate arrow and change color when dropdown is open */
    .multi-item-dropdown-toggle.active svg {
        transform: rotate(180deg);
        color: #047857;
    }
    
    /* Autocomplete suggestions dropdown - appears below input when typing */
    /* What: Shows matching items as user types in the search input */
    /* Why: Enables quick item selection via autocomplete */
    .multi-item-suggestions-dropdown {
        display: none;
        position: absolute;
        top: calc(100% + 5px);  /* 5px gap between dropdown and input box */
        left: 0;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;  /* Full border radius since there's a gap */
        max-height: 200px;
        overflow-y: auto;
        z-index: 1001;  /* Above selected items dropdown */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .multi-item-suggestions-dropdown .suggestion-item {
        padding: 10px 14px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        align-items: center;
        font-size: 14px;
        transition: background 0.15s;
    }
    
    /* What: Highlight styling for autocomplete suggestion items */
    /* Why: User needs visual feedback when hovering/selecting items */
    /* How: Light green background with explicit black text for readability */
    .multi-item-suggestions-dropdown .suggestion-item:hover,
    .multi-item-suggestions-dropdown .suggestion-item.selected {
        background: #f0fdf4;
        color: #000000;  /* Ensure text stays black and readable on green background */
    }
    
    .multi-item-suggestions-dropdown .suggestion-item:last-child {
        border-bottom: none;
    }
    
    /* Selected items dropdown - shows when clicking the dropdown arrow */
    /* What: Displays all currently selected items in a list format */
    /* Why: Allows users to see and manage (remove) selected items */
    .multi-item-selected-dropdown {
        display: none;
        position: absolute;
        top: calc(100% + 5px);  /* 5px gap between dropdown and search box */
        left: 0;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;  /* Full border radius since there's a gap */
        max-height: 150px;  /* Restricted height to prevent overflow */
        overflow-y: auto;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .multi-item-selected-dropdown.show {
        display: block;
    }
    
    /* Individual selected item row - displays item name with remove button */
    /* What: A row containing the item name and a red X button to remove it */
    /* Why: Provides clear visual feedback of selected items and easy removal */
    .selected-item-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .selected-item-row:last-child {
        border-bottom: none;
    }
    
    .selected-item-row .item-name {
        flex: 1;
        font-size: 0.95rem;
        color: var(--text);
    }
    
    /* Red X remove button - styled to match alert_detail.html */
    /* What: A prominent red X button to remove an item from the selection */
    /* Why: Provides clear, accessible way to remove items with visual feedback */
    .selected-item-row .remove-item-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border: none;
        background: transparent;
        cursor: pointer;
        color: #ef4444;  /* Red color for visibility */
        font-size: 1.4rem;
        font-weight: bold;
        line-height: 1;
        padding: 0;
        transition: color 0.15s ease, transform 0.15s ease;
    }
    
    .selected-item-row .remove-item-btn:hover {
        color: #dc2626;  /* Darker red on hover */
        transform: scale(1.1);  /* Slight scale up on hover */
    }
    
    /* No items message - shown when no items are selected */
    /* What: Placeholder text displayed in the dropdown when empty */
    /* Why: Provides feedback that no items have been selected yet */
    .no-items-message {
        display: none;
        padding: 16px 14px;
        text-align: center;
        color: #9ca3af;
        font-style: italic;
    }
    
    .no-items-message.show {
        display: block;
    }
    
    /* =========================================================================
       ITEM NOTIFICATION STYLES
       What: Small inline notifications for item add/remove feedback
       Why: Provides immediate visual feedback without disruptive popups
       ========================================================================= */
    
    /* Container for label + notification - displays label and notification inline */
    .label-with-notification {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 5px;  /* 5px margin between notification row and input box */
    }
    
    /* Small inline notification shown next to "Items" label */
    .item-notification {
        font-size: 0.8rem;
        padding: 3px 8px;
        border-radius: 4px;
        opacity: 0;
        transition: opacity 0.3s ease;
        white-space: nowrap;
    }
    
    .item-notification.show {
        opacity: 1;
    }
    
    /* Success notification (green) - item added successfully */
    .item-notification.success {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #a7f3d0;
    }
    
    /* Error notification (red) - item not found */
    .item-notification.error {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #fecaca;
    }

    .checkbox-group {
        display: flex;
        align-items: center;
    }

    .checkbox-label {
        padding-top: 35px !important;
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        font-weight: 500;
        color: var(--text);
    }

    .checkbox-label input[type="checkbox"] {

        padding-top: 35px !important;
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
    }

    .btn-create-alert {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        border: none;
        padding: 12px 28px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.15s;
    }

    .btn-create-alert:hover {
        background: linear-gradient(135deg, #0e8377 0%, #2dd36f 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
    }

    /* Suggestions dropdown */
    .suggestions-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .suggestion-item {
        padding: 10px 14px;
        cursor: pointer;
        transition: background 0.15s;
        font-size: 14px;
    }

    .suggestion-item:hover,
    .suggestion-item.selected {
        background: var(--primary);
        color: white;
    }

    .clickable-alert {
        cursor: pointer;
    }

    .clickable-alert:hover {
        background: rgba(99, 102, 241, 0.08);
    }

    /* Modals */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal-content {
        background: var(--surface);
        padding: 0;
        border-radius: 12px;
        width: 100%;
        max-width: 450px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        overflow: hidden;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        color: white;
    }

    .modal-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: white;
        line-height: 1;
        opacity: 0.8;
    }

    .modal-close:hover {
        opacity: 1;
    }

    .modal-content .form-group {
        padding: 0 20px;
        margin-top: 20px;
    }

    .modal-buttons {
        display: flex;
        gap: 10px;
        padding: 20px;
    }

    .btn-save {
        flex: 1;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .btn-save:hover {
        background: var(--surface-2);
        border-color: var(--primary);
        color: var(--primary);
    }

    .btn-cancel {
        flex: 1;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .btn-cancel:hover {
        background: var(--surface-2);
        border-color: var(--muted);
    }

    .btn-delete-group {
        flex: 1;
        background: var(--surface);
        color: #DC2626;
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .btn-delete-group:hover {
        background: rgba(220, 38, 38, 0.1);
        border-color: #DC2626;
    }

    .btn-clear {
        flex: 0 0 auto;
        background: var(--surface-2);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .btn-clear:hover {
        background: var(--surface);
        border-color: var(--muted);
    }

    /* Styled filter modal */
    .filter-modal-styled .modal-content {
        max-width: 380px;
    }

    .filter-modal-styled .modal-body {
        padding: 20px;
        text-align: center;
    }

    .filter-modal-styled .filter-icon {
        width: 56px;
        height: 56px;
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
    }

    .filter-modal-styled .filter-icon svg {
        width: 28px;
        height: 28px;
        color: white;
    }

    .filter-modal-styled .filter-description {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 20px;
    }

    .filter-modal-styled .form-group {
        text-align: left;
        padding: 0;
        margin-bottom: 16px;
    }

    .filter-modal-styled .form-group:last-of-type {
        margin-bottom: 0;
    }

    .filter-modal-styled .form-group label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 6px;
    }

    .filter-modal-styled .form-group input {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 14px;
        color: var(--text);
        background: var(--surface);
        transition: border-color 0.15s, box-shadow 0.15s;
        box-sizing: border-box;
    }

    .filter-modal-styled .form-group input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .filter-modal-styled .form-group input::placeholder {
        color: var(--muted);
    }

    .modal-content-large {
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
    }

    /* Group pills */
    .group-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 10px 0;
    }

    .group-list.pill-padding {
        gap: 12px;
        padding: 12px 0;
    }

    .group-checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        padding-top: 35px !important;
        /* padding: 8px 14px; */
        border: 1px solid var(--border);
        border-radius: 20px;
        background: var(--surface);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s;
    }

    .group-checkbox-label:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }

    .group-checkbox-label input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: var(--primary);
    }

    .group-checkbox-label input[type="checkbox"]:checked+span {
        font-weight: 600;
        color: var(--primary);
    }

    .group-pill {
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        border: 1px solid var(--border);
        border-radius: 20px;
        background: var(--surface);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s;
        user-select: none;
    }

    .group-pill:hover {
        background: var(--surface-2);
        border-color: var(--muted);
    }

    .group-pill.selected {
        background: var(--hover-orange);
        border-color: var(--hover-orange);
        color: white;
    }

    .group-pill.selected:hover {
        background: #EA580C;
        border-color: #EA580C;
    }

    /* Action buttons */
    .action-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.15s;
    }

    .edit-btn {
        background: var(--primary);
        color: white;
    }

    .edit-btn:hover {
        background: var(--primary-hover);
    }

    .delete-btn {
        background: var(--danger);
        color: white;
    }

    .delete-btn:hover {
        background: #DC2626;
    }

    .confirm-delete-btn {
        background: var(--danger);
        color: white;
    }

    .confirm-delete-btn:hover {
        background: #DC2626;
    }

    .cancel-btn {
        background: var(--muted);
        color: white;
    }

    .cancel-btn:hover {
        background: #4B5563;
    }

    /* Spread items list */
    #spread-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #spread-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    #spread-items-list li:last-child {
        border-bottom: none;
    }

    #spike-items-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #spike-items-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    #spike-items-list li:last-child {
        border-bottom: none;
    }

    .spread-item-name {
        font-weight: 600;
        color: #333;
    }

    .spread-item-details {
        color: #666;
        font-size: 0.9rem;
    }

    .spread-item-percentage {
        font-weight: 700;
        color: #28a745;
        font-size: 1.1rem;
    }

    .spread-item-percentage.negative-change {
        color: #dc3545;
    }

    /* Medium screen - sort indicator on separate row */
    @media (max-width: 1250px) {
        .alert-actions-wrapper {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .sort-indicator {
            margin-top: 7px;
        }

        .alert-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            width: 100%;
        }

        /* Hide sort indicator from its normal position */
        .sort-controls .sort-indicator-wrapper {
            display: none;
        }

        /* Show sort indicator in mobile row, aligned right */
        .sort-indicator-mobile-row {
            display: block;
            text-align: right;
            margin-bottom: -2px;
        }

        /* When sort indicator is not active, collapse the row */
        .sort-indicator-mobile-row:not(:has(.sort-indicator.active)) {
            display: none;
        }

        .sort-indicator-mobile-row .sort-indicator.active {
            display: inline-flex;
        }
    }

    /* Tablet/Mobile Responsive Styles */
    @media (max-width: 950px) {

        .alert-actions {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 10px;
            width: 100%;
        }

        /* Row 1: Search takes full width (spans all 3 columns) */
        .alert-actions-left {
            grid-column: 1 / -1;
            grid-row: 1;
            display: contents;
        }

        .alert-actions-left .alert-search-wrapper {
            grid-column: 1 / -1;
            grid-row: 1;
            width: 100%;
        }

        /* Actions dropdown - first item in row 2 */
        .alert-actions-left .custom-dropdown-wrapper {
            grid-column: 1;
            grid-row: 2;
            min-width: 0;
        }

        /* Row 2: Sort and Filters */
        .alert-actions-right {
            display: contents;
        }

        .alert-actions-controls {
            display: contents;
        }

        .sort-controls {
            display: contents;
        }

        /* Sort dropdown - second item in row 2 */
        .sort-controls .custom-dropdown-wrapper {
            grid-column: 2;
            grid-row: 2;
            min-width: 0;
        }

        /* Filter dropdown - third item in row 2 */
        .alert-actions-controls>.custom-dropdown-wrapper {
            grid-column: 3;
            grid-row: 2;
            min-width: 0;
        }

        .btn-dropdown {
            width: 100%;
            justify-content: center;
            min-width: 0;
            overflow: hidden;
        }

        /* Hide button icons on mobile, show only text */
        .btn-dropdown svg {
            display: none;
        }

        .alert-search-input {
            width: 100%;
        }

        /* Reset dropdown alignment */
        .custom-dropdown-menu,
        #sortDropdownMenu {
            width: 100%;
            left: 0;
            right: 0;
        }

        /* Filter dropdown right-aligned */
        #filterDropdownMenu {
            width: auto;
            min-width: 180px;
            left: auto;
            right: 0;
        }

        .sort-indicator-wrapper {
            display: none;
        }

        /* Hide item icon on small screens */
        .alert-icon,
        .alert-icon-placeholder {
            display: none;
        }

        .alert-threshold-label {
            display: none;
        }
    }

</style>

<!-- =============================================================================
     NEW GROUP MODAL
     What: Modal dialog for creating a new alert group while creating an alert
     Why: Users need a way to create groups inline without leaving the page
     How: Overlay with input field, Create/Cancel buttons, adds to AlertsState.alertGroups
============================================================================= -->
<div id="new-group-modal" class="new-group-modal-overlay">
    <div class="new-group-modal-content">
        <div class="new-group-modal-header">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
            </svg>
            <h3>Create New Group</h3>
        </div>
        <div class="new-group-modal-body">
            <label for="new-group-name-input">Group Name</label>
            <input type="text" id="new-group-name-input" placeholder="Enter group name..." maxlength="100" autocomplete="off">
            <p class="form-hint">Choose a descriptive name for your alert group</p>
        </div>
        <div class="new-group-modal-footer">
            <button type="button" class="new-group-modal-btn cancel" onclick="closeNewGroupModal()">Cancel</button>
            <button type="button" class="new-group-modal-btn create" id="create-group-btn" onclick="createNewGroup()">Create Group</button>
        </div>
    </div>
</div>

<script>
    /**
     * =============================================================================
     * OSRS ALERTS MANAGEMENT SYSTEM
     * =============================================================================
     * 
     * This module handles all client-side functionality for the alerts system:
     * - Creating and editing alerts (above/below threshold, spread alerts)
     * - Displaying triggered alerts with real-time updates
     * - Managing alert lifecycle (dismiss, delete)
     * - Item search autocomplete functionality
     * - Modal management for spread details and editing
     * 
     * Architecture:
     * - AlertsConfig: Central configuration object for settings and selectors
     * - AlertsState: Manages application state (filters, cached data, etc.)
     * - AlertsAPI: Handles all server communication
     * - AlertsUI: Manages DOM updates and rendering
     * - FormManager: Handles form field visibility and validation
     * - ModalManager: Controls modal dialogs
     * - AutocompleteManager: Handles item search suggestions
     * - EventManager: Sets up all event listeners
     * 
     * =============================================================================
     */

    // =============================================================================
    // CONFIGURATION
    // =============================================================================
    /**
     * Central configuration object containing all settings, selectors, and constants.
     * 
     * Why: Centralizing configuration makes it easy to modify settings without
     * searching through code. It also makes the codebase more maintainable.
     * 
     * How: All DOM selectors, API endpoints, and timing settings are defined here
     * and referenced throughout the application.
     */
    const AlertsConfig = {
        // API endpoints for server communication
        endpoints: {
            alerts: '/api/alerts/',
            dismiss: '/api/alerts/dismiss/',
            delete: '/api/alerts/delete/',
            update: '/api/alerts/update/',
            group: '/api/alerts/group/',
            deleteGroups: '/api/alerts/groups/delete/',
            itemSearch: '/api/items/'
        },

        // Timing settings (in milliseconds)
        timing: {
            refreshInterval: 5000,      // How often to poll for alert updates
            minSearchLength: 2          // Minimum characters before searching
        },

        // Available filters for the alerts list
        // Simple filters have just a test function
        // Input filters have requiresInput: true and testWithValue function
        filters: {
            triggered: {
                id: 'triggered',
                label: 'Triggered',
                test: alert => alert.is_triggered
            },
            notTriggered: {
                id: 'notTriggered',
                label: 'Not Triggered',
                test: alert => !alert.is_triggered
            },
            priceRange: {
                id: 'priceRange',
                label: 'Price',
                shortLabel: 'Price',
                requiresModal: true,
                testWithValue: (alert, value) => {
                    if (!value) return true;
                    const {min, max} = value;
                    const minPrice = min != null && min !== '' ? parseInt(min) : null;
                    const maxPrice = max != null && max !== '' ? parseInt(max) : null;

                    // Get the current price for the alert
                    let currentPrice = null;

                    // For above/below alerts, use the current price
                    if (alert.type === 'above' || alert.type === 'below') {
                        currentPrice = alert.current_price;
                    }
                    // For spread alerts with all items, use average of min/max (This is just for filtering)
                    else if (alert.type === 'spread' && alert.is_all_items) {
                        const minP = alert.minimum_price || 0;
                        const maxP = alert.maximum_price || 0;
                        currentPrice = (minP + maxP) / 2;
                    }
                    // For spread alerts with single item, use average of low/high
                    else if (alert.type === 'spread' && !alert.is_all_items) {
                        const low = alert.spread_low || 0;
                        const high = alert.spread_high || 0;
                        currentPrice = (low + high) / 2;
                    }
                    // For spike alerts, use current price
                    else if (alert.type === 'spike') {
                        currentPrice = alert.current_price;
                    }
                    // Default fallback
                    else {
                        currentPrice = alert.current_price || alert.price || 0;
                    }

                    if (currentPrice == null) return true;

                    // Check min bound (inclusive)
                    if (minPrice != null && !isNaN(minPrice) && currentPrice < minPrice) {
                        return false;
                    }

                    // Check max bound (inclusive)
                    if (maxPrice != null && !isNaN(maxPrice) && currentPrice > maxPrice) {
                        return false;
                    }

                    return true;
                }
            },
            myGroups: {
                id: 'myGroups',
                label: 'My Groups',
                requiresModal: true,
                testWithValue: (alert, selectedGroups) => {
                    if (!selectedGroups || selectedGroups.length === 0) return true;
                    // Check if alert belongs to any of the selected groups
                    const alertGroups = alert.groups || [];
                    return selectedGroups.some(group => alertGroups.includes(group));
                }
            }
        },

        // DOM element selectors for the create form
        selectors: {
            create: {
                alertType: '#alert-type',
                spreadScope: '#spread-scope',
                sustainedScope: '#sustained-scope',
                itemName: '#item-name',
                itemId: '#item-id',
                isAllItems: '#is-all-items',
                numberItems: '#number-of-items',
                direction: '#direction',
                emailNotification: '#email-notification',
                suggestions: '#item-suggestions',
                sustainedItemInput: '#sustained-item-input',
                sustainedItemIds: '#sustained-item-ids',
                sustainedItemSuggestions: '#sustained-item-suggestions',
                // Sustained move multi-item selector elements (new dropdown-style)
                sustainedSelectedItemsDropdown: '#sustained-selected-items-dropdown',
                sustainedSelectedItemsList: '#sustained-selected-items-list',
                sustainedNoItemsMessage: '#sustained-no-items-message',
                sustainedMultiItemToggle: '#sustained-multi-item-toggle',
                sustainedItemNotification: '#sustained-item-notification',
                // Spread multi-item selector elements
                spreadItemInput: '#spread-item-input',
                spreadItemIds: '#spread-item-ids',
                spreadItemSuggestions: '#spread-item-suggestions',
                // Spread multi-item selector elements (new dropdown-style)
                spreadSelectedItemsDropdown: '#spread-selected-items-dropdown',
                spreadSelectedItemsList: '#spread-selected-items-list',
                spreadNoItemsMessage: '#spread-no-items-message',
                spreadMultiItemToggle: '#spread-multi-item-toggle',
                spreadItemNotification: '#spread-item-notification',
                // Spike multi-item selector elements
                // What: DOM selectors for spike alert's multi-item selection UI
                // Why: Enables the multi-item picker functionality for spike alerts
                spikeScope: '#spike-scope',
                spikeItemInput: '#spike-item-input',
                spikeItemIds: '#spike-item-ids',
                spikeItemSuggestions: '#spike-item-suggestions',
                spikeSelectedItemsDropdown: '#spike-selected-items-dropdown',
                spikeSelectedItemsList: '#spike-selected-items-list',
                spikeNoItemsMessage: '#spike-no-items-message',
                spikeMultiItemToggle: '#spike-multi-item-toggle',
                spikeItemNotification: '#spike-item-notification',
                // Threshold alert multi-item selector elements
                // What: DOM selectors for threshold alert's item selection UI
                // Why: Enables the multi-item picker functionality for threshold alerts
                thresholdItemsTracked: '#threshold-items-tracked',
                thresholdItemInput: '#threshold-item-input',
                thresholdItemIds: '#threshold-item-ids',
                thresholdItemSuggestions: '#threshold-item-suggestions',
                thresholdSelectedItemsDropdown: '#threshold-selected-items-dropdown',
                thresholdSelectedItemsList: '#threshold-selected-items-list',
                thresholdNoItemsMessage: '#threshold-no-items-message',
                thresholdMultiItemToggle: '#threshold-multi-item-toggle',
                thresholdItemNotification: '#threshold-item-notification',
                thresholdType: '#threshold-type',
                thresholdDirection: '#threshold-direction',
                thresholdValue: '#threshold-value',
                thresholdReference: '#threshold-reference',
                alertGroup: '#alert-group',
                groups: {
                    spreadScope: '#spread-scope-group',
                    spreadItems: '#spread-items-group',  // New group for spread multi-item selector
                    spikeScope: '#spike-scope-group',    // Spike scope selector group
                    spikeItems: '#spike-items-group',    // Spike multi-item selector group
                    sustainedScope: '#sustained-scope-group',
                    sustainedItems: '#sustained-items-group',
                    itemName: '#item-name-group',
                    price: '#price-group',
                    reference: '#reference-group',
                    percentage: '#percentage-group',
                    timeFrame: '#time-frame-group',
                    direction: '#direction-group',
                    minPrice: '#min-price-group',
                    maxPrice: '#max-price-group',
                    minConsecutiveMoves: '#min-consecutive-moves-group',
                    minMovePercentage: '#min-move-percentage-group',
                    volatilityBuffer: '#volatility-buffer-group',
                    volatilityMultiplier: '#volatility-multiplier-group',
                    minVolume: '#min-volume-group',
                    pressureStrength: '#pressure-strength-group',
                    pressureSpread: '#pressure-spread-group',
                    // Threshold alert form groups
                    // What: DOM selectors for threshold alert form field containers
                    // Why: Controls visibility of threshold-specific form fields
                    thresholdItemsTracked: '#threshold-items-tracked-group',
                    thresholdItems: '#threshold-items-group',
                    thresholdType: '#threshold-type-group',
                    thresholdDirection: '#threshold-direction-group',
                    thresholdValue: '#threshold-value-group',
                    thresholdReference: '#threshold-reference-group'
                }
            },
            // Other UI elements
            myAlertsPane: '#my-alerts',
            spreadModal: '#spread-modal',
            spreadItemsList: '#spread-items-list',
            spikeModal: '#spike-modal',
            spikeItemsList: '#spike-items-list',
            groupModal: '#group-modal',
            groupList: '#group-list',
            newGroupInput: '#new-group-input',
            tabButtons: '.tab-btn',
            tabPanes: '.tab-pane'
        },

        // Alert type constants for comparison
        alertTypes: {
            ABOVE: 'above',
            BELOW: 'below',
            SPREAD: 'spread',
            SPIKE: 'spike',
            SUSTAINED: 'sustained',
            THRESHOLD: 'threshold'
        },

        // CSRF token for Django POST requests
        csrfToken: '{{ csrf_token }}'
    };

    // =============================================================================
    // DROPDOWN SIZING (compact label, expandable options)
    // =============================================================================
    const DropdownSizer = {
        _canvas: null,

        measureText(text, select) {
            if (!this._canvas) this._canvas = document.createElement('canvas');
            const ctx = this._canvas.getContext('2d');
            const style = window.getComputedStyle(select);
            ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
            return ctx.measureText(text || '').width;
        },

        applySizing(select) {
            if (!select) return;
            const padding =
                parseFloat(window.getComputedStyle(select).paddingLeft || 0) +
                parseFloat(window.getComputedStyle(select).paddingRight || 0);
            const arrowSpace = 24; // room for native dropdown arrow

            const calcWidth = text => this.measureText(text, select) + padding + arrowSpace;
            const getExpandedWidth = () => {
                let max = 0;
                Array.from(select.options).forEach(opt => {max = Math.max(max, calcWidth(opt.text));});
                return max || calcWidth(select.options[0]?.text || '');
            };

            const updateCompactWidth = () => {
                const selectedText = select.options[select.selectedIndex]?.text || select.options[0]?.text || '';
                select.dataset.compactWidth = calcWidth(selectedText);
            };

            const applyCompact = () => {
                const width = select.dataset.compactWidth || calcWidth(select.options[0]?.text || '');
                select.style.minWidth = `${width}px`;
            };

            const expandedWidth = getExpandedWidth();
            select.dataset.expandedWidth = expandedWidth;
            updateCompactWidth();
            applyCompact();

            const expand = () => {select.style.minWidth = `${select.dataset.expandedWidth}px`;};
            const collapse = () => {applyCompact();};

            select.addEventListener('focus', expand);
            select.addEventListener('mousedown', expand);
            select.addEventListener('blur', collapse);
            select.addEventListener('change', () => {
                updateCompactWidth();
                collapse();
            });
        },

        init() {
            this.applySizing(document.querySelector('.action-dropdown'));
            this.applySizing(document.querySelector('.sort-dropdown'));
            this.applySizing(document.querySelector('.filter-dropdown'));
        }
    };


    // =============================================================================
    // STATE MANAGEMENT
    // =============================================================================
    /**
     * Application state manager.
     * 
     * Why: Centralizing state prevents scattered variables and makes it easier
     * to track and debug the application's current status.
     * 
     * How: All mutable state is stored in this object and accessed/modified
     * through consistent patterns.
     */
    const AlertsState = {
        spreadDataCache: {},            // Cache for spread alert data (keyed by alert ID)
        spikeDataCache: {},             // Cache for spike all-items data
        activeFilters: new Set(),       // Currently active filter IDs
        filterValues: {},               // Values for input-based filters (keyed by filter ID)
        alertGroups: [],                // Known alert groups
        cachedAlerts: [],               // Cached alerts data for instant filtering/sorting
        searchQuery: '',                // Current search query
        iconCache: {},                  // Cache for item icons (keyed by item_id)
        previousTriggeredItems: {},     // Track previously seen triggered items per alert (keyed by alert ID)
        dismissedNotifications: null,   // Set of dismissed alert notification IDs (persisted to localStorage)
        sorting: {                      // Current sorting state
            sortKey: null,
            sortOrder: null,
            pendingKey: null
        },

        /**
         * Gets the set of dismissed notification alert IDs.
         * Loads from localStorage if not in memory.
         */
        getDismissedNotifications() {
            if (this.dismissedNotifications !== null) {
                return this.dismissedNotifications;
            }
            // Load from localStorage
            try {
                const stored = localStorage.getItem('dismissedAlertNotifications');
                if (stored) {
                    this.dismissedNotifications = new Set(JSON.parse(stored));
                    return this.dismissedNotifications;
                }
            } catch (e) {
                console.error('Error loading dismissed notifications from localStorage:', e);
            }
            this.dismissedNotifications = new Set();
            return this.dismissedNotifications;
        },

        /**
         * Marks a notification as dismissed.
         * Persists to localStorage.
         */
        dismissNotification(alertId) {
            const dismissed = this.getDismissedNotifications();
            dismissed.add(String(alertId));
            try {
                localStorage.setItem('dismissedAlertNotifications', JSON.stringify([...dismissed]));
            } catch (e) {
                console.error('Error saving dismissed notifications to localStorage:', e);
            }
        },

        /**
         * Checks if a notification has been dismissed.
         */
        isNotificationDismissed(alertId) {
            return this.getDismissedNotifications().has(String(alertId));
        },

        /**
         * Clears a dismissed notification (e.g., when alert is re-triggered with new data).
         */
        clearDismissedNotification(alertId) {
            const dismissed = this.getDismissedNotifications();
            dismissed.delete(String(alertId));
            try {
                localStorage.setItem('dismissedAlertNotifications', JSON.stringify([...dismissed]));
            } catch (e) {
                console.error('Error saving dismissed notifications to localStorage:', e);
            }
        },

        /**
         * Active notifications cache - stores notification data that should be shown.
         * This persists notifications even if they're no longer in the API response.
         */
        activeNotificationsCache: null,

        /**
         * Gets all active notifications from localStorage.
         */
        getActiveNotifications() {
            if (this.activeNotificationsCache !== null) {
                return this.activeNotificationsCache;
            }
            try {
                const stored = localStorage.getItem('activeAlertNotifications');
                if (stored) {
                    this.activeNotificationsCache = JSON.parse(stored);
                    return this.activeNotificationsCache;
                }
            } catch (e) {
                console.error('Error loading active notifications from localStorage:', e);
            }
            this.activeNotificationsCache = {};
            return this.activeNotificationsCache;
        },

        /**
         * Adds or updates an active notification.
         */
        setActiveNotification(alertId, notificationData) {
            const active = this.getActiveNotifications();
            active[String(alertId)] = notificationData;
            try {
                localStorage.setItem('activeAlertNotifications', JSON.stringify(active));
            } catch (e) {
                console.error('Error saving active notifications to localStorage:', e);
            }
        },

        /**
         * Removes an active notification (when dismissed).
         */
        removeActiveNotification(alertId) {
            const active = this.getActiveNotifications();
            delete active[String(alertId)];
            try {
                localStorage.setItem('activeAlertNotifications', JSON.stringify(active));
            } catch (e) {
                console.error('Error saving active notifications to localStorage:', e);
            }
        },

        /**
         * Gets a specific active notification.
         */
        getActiveNotification(alertId) {
            return this.getActiveNotifications()[String(alertId)] || null;
        },

        /**
         * Stores spread data for a specific alert in the cache.
         * This allows the spread details modal to access the data later.
         */
        setSpreadData(alertId, data) {
            this.spreadDataCache[alertId] = data;
        },

        /**
         * Retrieves cached spread data for an alert.
         * Returns null if no data exists for the given ID.
         */
        getSpreadData(alertId) {
            return this.spreadDataCache[alertId] || null;
        },

        setSpikeData(alertId, data) {
            this.spikeDataCache[alertId] = data;
        },

        getSpikeData(alertId) {
            return this.spikeDataCache[alertId] || null;
        },

        /**
         * Updates known alert groups from alert data payload.
         */
        setAlertGroups(groups) {
            this.alertGroups = Array.isArray(groups) ? groups : [];
            // Update the create form group dropdown
            this.updateGroupDropdown();
        },

        /**
         * Updates the group dropdown in the create alert form.
         */
        updateGroupDropdown() {
            const dropdown = document.querySelector(AlertsConfig.selectors.create.alertGroup);
            if (!dropdown) return;

            const currentValue = dropdown.value;
            dropdown.innerHTML = '<option value="">No Group</option>';

            this.alertGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                dropdown.appendChild(option);
            });

            // Restore selection if still valid
            if (currentValue && this.alertGroups.includes(currentValue)) {
                dropdown.value = currentValue;
            }
        },

        /**
         * Returns known alert groups.
         */
        getAlertGroups() {
            return this.alertGroups || [];
        },

        /**
         * Caches the alerts array for instant filtering/sorting.
         */
        setCachedAlerts(alerts) {
            this.cachedAlerts = Array.isArray(alerts) ? alerts : [];
        },

        /**
         * Returns the cached alerts array.
         */
        getCachedAlerts() {
            return this.cachedAlerts || [];
        },

        /**
         * Sets a value for an input-based filter.
         */
        setFilterValue(filterId, value) {
            this.filterValues[filterId] = value;
        },

        /**
         * Gets the value for an input-based filter.
         */
        getFilterValue(filterId) {
            return this.filterValues[filterId] || null;
        },

        /**
         * Gets the set of previously triggered item IDs for an alert.
         * Loads from localStorage if not in memory.
         */
        getPreviousTriggeredItems(alertId) {
            // Check memory first
            if (this.previousTriggeredItems[alertId]) {
                return this.previousTriggeredItems[alertId];
            }
            // Load from localStorage
            try {
                const stored = localStorage.getItem('alertTriggeredItems_' + alertId);
                if (stored) {
                    const arr = JSON.parse(stored);
                    this.previousTriggeredItems[alertId] = new Set(arr);
                    return this.previousTriggeredItems[alertId];
                }
            } catch (e) {
                console.error('Error loading triggered items from localStorage:', e);
            }
            return new Set();
        },

        /**
         * Updates the set of triggered item IDs for an alert.
         * Persists to localStorage.
         */
        setPreviousTriggeredItems(alertId, itemIds) {
            const idSet = new Set(itemIds);
            this.previousTriggeredItems[alertId] = idSet;
            // Persist to localStorage
            try {
                localStorage.setItem('alertTriggeredItems_' + alertId, JSON.stringify([...idSet]));
            } catch (e) {
                console.error('Error saving triggered items to localStorage:', e);
            }
        },

        /**
         * Computes newly triggered items by comparing current vs previous.
         * Returns { newItems: [...], allItems: [...], newCount: number }
         * Handles both spread (item_id) and spike (id) data structures.
         */
        computeNewTriggeredItems(alertId, currentData) {
            if (!currentData) return {newItems: [], allItems: [], newCount: 0};

            let items = [];
            try {
                items = typeof currentData === 'string' ? JSON.parse(currentData) : currentData;
                if (!Array.isArray(items)) items = [];
            } catch (e) {
                return {newItems: [], allItems: [], newCount: 0};
            }

            const previousSet = this.getPreviousTriggeredItems(alertId);
            // Handle both spread (item_id) and spike (id) data structures
            const currentItemIds = items.map(item => String(item.item_id || item.id));

            // On first load (no previous data in memory or localStorage), initialize tracking
            if (previousSet.size === 0 && currentItemIds.length > 0) {
                // First time seeing this alert - store items but report 0 new
                this.setPreviousTriggeredItems(alertId, currentItemIds);
                return {newItems: [], allItems: items, newCount: 0, isInitialLoad: true};
            }

            // Find new items (in current but not in previous)
            const newItems = items.filter(item => {
                const itemId = String(item.item_id || item.id);
                return !previousSet.has(itemId);
            });

            // Update tracked items
            this.setPreviousTriggeredItems(alertId, currentItemIds);

            return {newItems, allItems: items, newCount: newItems.length};
        }
    };


    // =============================================================================
    // API COMMUNICATION
    // =============================================================================
    /**
     * Handles all server communication.
     * 
     * Why: Centralizing API calls makes it easier to handle errors consistently,
     * modify endpoints, and add features like request caching or retries.
     * 
     * How: Each method corresponds to a specific API action and returns a Promise.
     */
    const AlertsAPI = {
        /**
         * Fetches current alerts data from the server.
         * Returns both active alerts and triggered notifications.
         */
        async fetchAlerts() {
            try {
                const response = await fetch(AlertsConfig.endpoints.alerts);
                return await response.json();
            } catch (error) {
                console.error('Error fetching alerts:', error);
                return null;
            }
        },

        /**
         * Dismisses a triggered alert notification.
         * The alert remains in the system but the notification banner is hidden.
         */
        async dismissAlert(alertId) {
            try {
                await fetch(AlertsConfig.endpoints.dismiss, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': AlertsConfig.csrfToken
                    },
                    body: JSON.stringify({alert_id: alertId})
                });
                return true;
            } catch (error) {
                console.error('Error dismissing alert:', error);
                return false;
            }
        },

        /**
         * Deletes multiple alerts by their IDs.
         */
        async deleteAlerts(alertIds) {
            try {
                await fetch(AlertsConfig.endpoints.delete, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': AlertsConfig.csrfToken
                    },
                    body: JSON.stringify({alert_ids: alertIds})
                });
                return true;
            } catch (error) {
                console.error('Error deleting alerts:', error);
                return false;
            }
        },

        /**
         * Adds alerts to groups (creates groups if needed).
         */
        async groupAlerts(alertIds, groups, newGroups) {
            try {
                await fetch(AlertsConfig.endpoints.group, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': AlertsConfig.csrfToken
                    },
                    body: JSON.stringify({
                        alert_ids: alertIds,
                        groups: groups,
                        new_groups: newGroups
                    })
                });
                return true;
            } catch (error) {
                console.error('Error grouping alerts:', error);
                return false;
            }
        },

        /**
         * Deletes alert groups by name.
         */
        async deleteGroups(groups) {
            try {
                const response = await fetch(AlertsConfig.endpoints.deleteGroups, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': AlertsConfig.csrfToken
                    },
                    body: JSON.stringify({groups})
                });
                if (!response.ok) return false;
                const data = await response.json();
                return !!data.success;
            } catch (error) {
                console.error('Error deleting groups:', error);
                return false;
            }
        },

        /**
         * Updates an existing alert with new values.
         */
        async updateAlert(alertData) {
            try {
                await fetch(AlertsConfig.endpoints.update, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': AlertsConfig.csrfToken
                    },
                    body: JSON.stringify(alertData)
                });
                return true;
            } catch (error) {
                console.error('Error updating alert:', error);
                return false;
            }
        },

        /**
         * Searches for items by name query.
         * Used for autocomplete in item name fields.
         */
        async searchItems(query) {
            try {
                const url = AlertsConfig.endpoints.itemSearch + '?q=' + encodeURIComponent(query);
                const response = await fetch(url);
                return await response.json();
            } catch (error) {
                console.error('Error searching items:', error);
                return [];
            }
        }
    };


    // =============================================================================
    // UI RENDERING
    // =============================================================================
    /**
     * Handles all DOM updates and HTML rendering.
     * 
     * Why: Separating UI logic from business logic makes the code easier to test,
     * modify, and understand. Changes to how things look don't affect how they work.
     * 
     * How: Each method handles a specific rendering task and returns HTML strings
     * or directly manipulates the DOM as appropriate.
     */
    const AlertsUI = {
        /**
         * Generates the triggered text for an alert based on its type and data.
         * 
         * Why: Different alert types need different information displayed when triggered.
         * - Spread (all items): Shows clickable link to view all matching items
         * - Spread (single item): Shows low, high, and spread percentage
         * - Above/Below: Shows the price movement that triggered the alert
         */
        buildTriggeredText(alert) {
            return 'Triggered';
        },

        /**
         * Checks if an alert is a spread-all-items type.
         */
        isSpreadAllItemsAlert(alert) {
            return alert.type === AlertsConfig.alertTypes.SPREAD &&
                alert.is_all_items &&
                alert.triggered_data;
        },

        /**
         * Checks if an alert is a spike-all-items type.
         */
        isSpikeAllItemsAlert(alert) {
            return alert.type === AlertsConfig.alertTypes.SPIKE &&
                alert.is_all_items &&
                alert.triggered_data;
        },

        /**
         * Renders the green notification banners for triggered alerts.
         * Stores notifications in localStorage so they persist until explicitly dismissed.
         * For "all items" alerts, tracks NEW triggered items.
         */
        renderTriggeredNotifications(triggeredAlerts) {
            // First, process incoming alerts and store them in active notifications cache
            if (triggeredAlerts && triggeredAlerts.length > 0) {
                triggeredAlerts.forEach(alert => {
                    // IMPORTANT: If the backend returns this alert with is_dismissed=False,
                    // it means the alert data has changed and we should show it again.
                    // Clear it from localStorage dismissed list to allow it to show.
                    // What: Clear this alert from the localStorage dismissed list
                    // Why: Backend sets is_dismissed=False when data changes, but localStorage still has it dismissed
                    // How: Call clearDismissedNotification to remove from localStorage dismissed set
                    if (AlertsState.isNotificationDismissed(alert.id)) {
                        // Backend says show it (is_dismissed=False), but localStorage says dismissed
                        // Trust the backend - clear the localStorage entry so notification can show
                        AlertsState.clearDismissedNotification(alert.id);
                    }
                    
                    const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
                    const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);
                    const isAllItemsAlert = isSpreadAllItems || isSpikeAllItems;

                    // Cache spread/spike data for later use in modal
                    if (isSpreadAllItems) {
                        AlertsState.setSpreadData(alert.id, alert.triggered_data);
                    }
                    if (isSpikeAllItems) {
                        AlertsState.setSpikeData(alert.id, alert.triggered_data);
                    }

                    // Determine notification text
                    let notificationText = alert.triggered_text;
                    
                    // For "all items" alerts, check for NEW items
                    if (isAllItemsAlert && alert.triggered_data) {
                        const result = AlertsState.computeNewTriggeredItems(alert.id, alert.triggered_data);
                        
                        // If this is a subsequent load with new items, update the text
                        if (!result.isInitialLoad && result.newCount > 0) {
                            const matchPattern = /\((\d+) item\(s\) matched\)/;
                            if (matchPattern.test(notificationText)) {
                                notificationText = notificationText.replace(matchPattern, `(${result.newCount} NEW item(s) matched)`);
                            } else {
                                notificationText += ` (${result.newCount} NEW item(s))`;
                            }
                        }
                    }

                    // Store in active notifications cache (persists to localStorage)
                    AlertsState.setActiveNotification(alert.id, {
                        id: alert.id,
                        text: notificationText,
                        type: alert.type,
                        is_all_items: alert.is_all_items,
                        isSpreadAllItems: isSpreadAllItems,
                        isSpikeAllItems: isSpikeAllItems
                    });
                });
            }

            // Now render ALL active notifications from localStorage
            const activeNotifications = AlertsState.getActiveNotifications();
            let html = '';
            
            Object.values(activeNotifications).forEach(notification => {
                // Double-check it's not dismissed
                if (AlertsState.isNotificationDismissed(notification.id)) {
                    return;
                }
                
                const clickHandler = notification.isSpreadAllItems
                    ? 'onclick="ModalManager.showSpreadDetails(' + notification.id + ')"'
                    : (notification.isSpikeAllItems ? 'onclick="ModalManager.showSpikeDetails(' + notification.id + ')"' : '');
                const clickableClass = (notification.isSpreadAllItems || notification.isSpikeAllItems) ? 'clickable-triggered' : '';

                html += '<div class="triggered-notification" data-alert-id="' + notification.id + '">' +
                    '<span class="' + clickableClass + '" ' + clickHandler + '>' + notification.text + '</span>' +
                    '<button class="dismiss-btn" onclick="dismissAlert(' + notification.id + ')">&times;</button>' +
                    '</div>';
            });

            return html;
        },

        /**
         * Renders the action dropdown and filter dropdown.
         * @param {boolean} hasAlerts - Whether there are alerts to display
         * @param {string} preservedFilterTagsHtml - HTML of preserved filter tags (optional)
         */
        renderActionButtons(hasAlerts, preservedFilterTagsHtml) {
            if (!hasAlerts) return '';

            // Build filter dropdown items
            let filterItems = '';
            for (const [id, filter] of Object.entries(AlertsConfig.filters)) {
                const isActive = FilterManager.isActive(id);
                filterItems += '<div class="custom-dropdown-item' + (isActive ? ' active' : '') + '" data-filter="' + id + '">' +
                    '<span>' + filter.label + '</span>' +
                    '<span class="filter-check">âœ“</span>' +
                    '<span class="filter-clear" title="Clear filter">Ã—</span>' +
                    '</div>';
            }

            // Use preserved filter tags if provided, otherwise build from state
            let tags = preservedFilterTagsHtml || '';
            if (!preservedFilterTagsHtml) {
                for (const filterId of AlertsState.activeFilters) {
                    const filter = AlertsConfig.filters[filterId];
                    if (filter) {
                        tags += '<span class="filter-tag" data-filter-id="' + filterId + '">' + filter.label +
                            '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                            '</span>';
                    }
                }
            }

            // Build sort indicator HTML (desktop)
            let sortIndicatorHtml = '';
            // Build mobile sort indicator HTML
            let mobileSortIndicatorHtml = '';

            if (AlertsState.sorting.sortKey) {
                const sortOption = SortManager.options[AlertsState.sorting.sortKey];
                const label = sortOption ? sortOption.label : 'Sort';
                const arrow = AlertsState.sorting.sortOrder === 'asc' ? 'â†‘' : 'â†“';
                sortIndicatorHtml = '<div class="sort-indicator-wrapper" id="sortIndicatorWrapper">' +
                    '<div class="sort-indicator active" id="sortIndicator">' +
                    '<span class="sort-indicator-label">Sorted by:</span>' +
                    '<span class="sort-indicator-value" id="sortIndicatorValue">' + label + '</span>' +
                    '<span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">' + arrow + '</span>' +
                    '<span class="sort-indicator-clear" id="sortIndicatorClear" title="Clear sort">Ã—</span>' +
                    '</div>' +
                    '</div>';
                mobileSortIndicatorHtml = '<div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">' +
                    '<div class="sort-indicator active" id="sortIndicatorMobile">' +
                    '<span class="sort-indicator-label">Sorted by:</span>' +
                    '<span class="sort-indicator-value" id="sortIndicatorValueMobile">' + label + '</span>' +
                    '<span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">' + arrow + '</span>' +
                    '<span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">Ã—</span>' +
                    '</div>' +
                    '</div>';
            } else {
                sortIndicatorHtml = '<div class="sort-indicator-wrapper" id="sortIndicatorWrapper">' +
                    '<div class="sort-indicator" id="sortIndicator">' +
                    '<span class="sort-indicator-label">Sorted by:</span>' +
                    '<span class="sort-indicator-value" id="sortIndicatorValue"></span>' +
                    '<span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">â†“</span>' +
                    '<span class="sort-indicator-clear" id="sortIndicatorClear" title="Clear sort">Ã—</span>' +
                    '</div>' +
                    '</div>';
                mobileSortIndicatorHtml = '<div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">' +
                    '<div class="sort-indicator" id="sortIndicatorMobile">' +
                    '<span class="sort-indicator-label">Sorted by:</span>' +
                    '<span class="sort-indicator-value" id="sortIndicatorValueMobile"></span>' +
                    '<span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">â†“</span>' +
                    '<span class="sort-indicator-clear" id="sortIndicatorClearMobile" title="Clear sort">Ã—</span>' +
                    '</div>' +
                    '</div>';
            }

            // Build sort dropdown items
            const currentSortKey = AlertsState.sorting.sortKey;
            const sortItems = '' +
                '<div class="custom-dropdown-item' + (currentSortKey === 'alphabetically' ? ' active' : '') + '" data-sort="alphabetically"><span>Alphabetically</span><span class="sort-check">âœ“</span></div>' +
                '<div class="custom-dropdown-item' + (currentSortKey === 'lastTriggered' ? ' active' : '') + '" data-sort="lastTriggered"><span>Last Triggered Time</span><span class="sort-check">âœ“</span></div>' +
                '<div class="custom-dropdown-item' + (currentSortKey === 'alertType' ? ' active' : '') + '" data-sort="alertType"><span>Alert Type</span><span class="sort-check">âœ“</span></div>' +
                '<div class="custom-dropdown-item' + (currentSortKey === 'thresholdDistance' ? ' active' : '') + '" data-sort="thresholdDistance"><span>Threshold Distance</span><span class="sort-check">âœ“</span></div>' +
                '<div class="custom-dropdown-item' + (currentSortKey === 'createdDate' ? ' active' : '') + '" data-sort="createdDate"><span>Created Date</span><span class="sort-check">âœ“</span></div>';

            // Calculate filter badge
            const activeCount = AlertsState.activeFilters.size;
            const filterBadge = activeCount > 0
                ? '<span class="filter-badge" id="filterBadge">' + activeCount + '</span>'
                : '<span class="filter-badge" id="filterBadge" style="display: none;">0</span>';
            const filterBtnClass = activeCount > 0 ? 'btn-dropdown btn-filter has-active' : 'btn-dropdown btn-filter';

            // Build search bar with current value preserved
            const searchValue = AlertsState.searchQuery || '';
            const searchHasValue = searchValue.length > 0 ? ' has-value' : '';
            const searchBarHtml = '' +
                '<div class="alert-search-wrapper' + searchHasValue + '">' +
                '<svg class="alert-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>' +
                '</svg>' +
                '<input type="text" class="alert-search-input" id="alertSearchInput" placeholder="Search alerts..." autocomplete="off" value="' + searchValue.replace(/"/g, '&quot;') + '">' +
                '<button type="button" class="alert-search-clear" id="alertSearchClear" title="Clear search">Ã—</button>' +
                '</div>';

            return '<div class="alert-actions-wrapper">' +
                '<div class="alert-actions">' +
                '<div class="alert-actions-left">' +
                '<div class="custom-dropdown-wrapper">' +
                '<button type="button" class="btn-dropdown btn-actions" id="actionsDropdownBtn">' +
                '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>' +
                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>' +
                '</svg>' +
                '<span class="btn-text">Actions</span>' +
                '</button>' +
                '<div class="custom-dropdown-menu" id="actionsDropdownMenu">' +
                '<div class="custom-dropdown-header">Actions</div>' +
                '<div class="custom-dropdown-item" data-action="delete"><span>Delete</span></div>' +
                '<div class="custom-dropdown-item" data-action="group"><span>Add to Group</span></div>' +
                '</div>' +
                '</div>' +
                searchBarHtml +
                '</div>' +
                '<div class="alert-actions-right" id="active-filters">' +
                '<div class="alert-actions-controls">' +
                '<div class="sort-controls">' +
                sortIndicatorHtml +
                '<div class="custom-dropdown-wrapper">' +
                '<button type="button" class="btn-dropdown btn-sort" id="sortDropdownBtn">' +
                '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>' +
                '</svg>' +
                '<span class="btn-text">Sort</span>' +
                '</button>' +
                '<div class="custom-dropdown-menu" id="sortDropdownMenu">' +
                '<div class="custom-dropdown-header">Sort by</div>' +
                sortItems +
                '</div>' +
                '</div>' +
                '</div>' +
                '<div class="custom-dropdown-wrapper">' +
                '<button type="button" class="' + filterBtnClass + '" id="filterDropdownBtn">' +
                '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>' +
                '</svg>' +
                '<span class="btn-text">Filters</span>' +
                filterBadge +
                '</button>' +
                '<div class="custom-dropdown-menu" id="filterDropdownMenu">' +
                '<div class="custom-dropdown-header">Filter by</div>' +
                filterItems +
                '</div>' +
                '</div>' +
                '</div>' +
                '</div>' +
                '</div>' +
                mobileSortIndicatorHtml +
                '<div class="alert-indicators">' +
                '<div class="filter-tags">' + tags + '</div>' +
                '</div>' +
                '</div>';
        },

        /**
         * Renders a single alert list item.
         */
        renderAlertItem(alert) {
            const isSpreadAllItems = this.isSpreadAllItemsAlert(alert);
            const isSpikeAllItems = this.isSpikeAllItemsAlert(alert);

            // typeIconSvgs: inline SVGs keyed by alert type; ensures we show meaningful icons (spread/spike/sustained/threshold) when no item art exists (e.g., all-items alerts) by rendering semantic shapes that match alert intent. Icons use color cues for quick recognition.
            const typeIconSvgs = {
                // Spread: purple double-ended arrow between price ticks (margin/difference).
                spread: '<svg fill="none" stroke="#7C3AED" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7v10M15 7v10M6 12h12M6 12l3-3M6 12l3 3M18 12l-3-3M18 12l-3 3"/></svg>',
                // Spike: red warning triangle with exclamation.
                spike: '<svg viewBox="0 0 24 24"><path d="M12 4l8 14H4L12 4z" fill="#DC2626" stroke="#B91C1C" stroke-width="1.5"/><path d="M12 9v5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"/><circle cx="12" cy="17.5" r="1.2" fill="#FFFFFF"/></svg>',
                // Sustained: straight green line up/right on chart axes.
                sustained: '<svg fill="none" stroke="#16A34A" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 18h16M4 18V6M4 18L18 6"/></svg>',
                // Threshold: orange horizontal line with arrow pointing up/down representing price crossing a threshold level.
                threshold: '<svg fill="none" stroke="#F97316" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12h16"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8V4M12 4l-3 3M12 4l3 3"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 16v4M12 20l-3-3M12 20l3-3"/></svg>'
            };

            // Cache spread data if triggered (for detail page)
            if (isSpreadAllItems && alert.is_triggered) {
                AlertsState.setSpreadData(alert.id, alert.triggered_data);
            }
            if (isSpikeAllItems && alert.is_triggered) {
                AlertsState.setSpikeData(alert.id, alert.triggered_data);
            }

            // Build triggered badge if needed
            let triggeredBadge = '';
            if (alert.is_triggered) {
                const triggeredText = this.buildTriggeredText(alert);
                triggeredBadge = '<span class="alert-triggered">' + triggeredText + '</span>';
            }

            // Build active/inactive status display
            const isActive = alert.is_active === true;
            const statusDisplay = isActive
                ? '<span class="alert-status alert-status-active">Active</span>'
                : '<span class="alert-status alert-status-inactive">Inactive</span>';

            // Build sort info text based on current sort
            let sortInfoHtml = '';
            const currentSort = AlertsState.sorting.sortKey;
            if (currentSort === 'lastTriggered') {
                const ts = alert.last_triggered_at || alert.triggered_at || alert.triggered_time || alert.last_triggered_time;
                let timeText = 'Never';
                if (ts) {
                    const date = new Date(ts);
                    if (!isNaN(date.getTime())) {
                        timeText = date.toLocaleString();
                    }
                }
                sortInfoHtml = '<div class="alert-sort-info">Last triggered: ' + timeText + '</div>';
            } else if (currentSort === 'createdDate') {
                let timeText = 'Unknown';
                if (alert.created_at) {
                    const date = new Date(alert.created_at);
                    if (!isNaN(date.getTime())) {
                        timeText = date.toLocaleString();
                    }
                }
                sortInfoHtml = '<div class="alert-sort-info">Created: ' + timeText + '</div>';
            } else if (currentSort === 'alertType') {
                const typeText = alert.type ? alert.type.charAt(0).toUpperCase() + alert.type.slice(1) : 'Unknown';
                sortInfoHtml = '<div class="alert-sort-info">Type: ' + typeText + '</div>';
            } else if (currentSort === 'thresholdDistance') {
                const thresholdDistance = SortManager.getThresholdDistance(alert);
                let distText = 'N/A';
                // =============================================================================
                // DISPLAY THRESHOLD DISTANCE OR MULTI-ITEM MESSAGE
                // =============================================================================
                // What: Format the threshold distance for display in the sort info section
                // Why: Users need visual feedback on how close alerts are to triggering
                // How: Check if result is a number (show %), 'multi' (show tracking message), or null (show N/A)
                if (thresholdDistance === 'multi') {
                    // Multi-item alert - distance calculation not applicable
                    distText = 'N/A - Tracking Multiple Items';
                } else if (typeof thresholdDistance === 'number' && !Number.isNaN(thresholdDistance)) {
                    distText = thresholdDistance.toFixed(2) + '%';
                }
                sortInfoHtml = '<div class="alert-sort-info">Threshold distance: ' + distText + '</div>';
            }

            // Build icon HTML - use item image if available, otherwise placeholder
            let iconHtml;
            if (alert.icon) {
                // Cache the icon for this item
                if (alert.item_id) {
                    AlertsState.iconCache[alert.item_id] = alert.icon;
                }
                const iconUrl = 'https://oldschool.runescape.wiki/images/' + encodeURIComponent(alert.icon.replace(/ /g, '_'));
                iconHtml = '<img class="alert-icon" src="' + iconUrl + '" alt="" loading="lazy">';
            } else if (typeIconSvgs[alert.type]) {
                // Use semantic SVG icon when we lack item art (covers all-items and missing-icon cases) so the visual matches alert intent.
                iconHtml = '<span class="alert-icon-placeholder alert-type-icon" aria-hidden="true">' + typeIconSvgs[alert.type] + '</span>';
            } else if (alert.is_all_items) {
                // "All items" alerts fallback to neutral stack icon when no type-specific SVG exists.
                iconHtml = '<span class="alert-icon-placeholder">ðŸ“Š</span>';
            } else {
                // Fallback bell for items without icons and no type-specific SVG.
                iconHtml = '<span class="alert-icon-placeholder">ðŸ””</span>';
            }

            // Determine display text - use custom name if not 'Default'
            const displayText = (alert.alert_name && alert.alert_name !== 'Default')
                ? alert.alert_name
                : alert.text;

            return '<li class="alert-item clickable-alert" data-alert-id="' + alert.id + '" data-alert-text="' + (alert.text || '').replace(/"/g, '&quot;') + '" onclick="navigateToAlertDetail(event, ' + alert.id + ')">' +
                '<input type="checkbox" class="alert-checkbox" onclick="event.stopPropagation()">' +
                iconHtml +
                '<div class="alert-content">' +
                '<span class="alert-text">' + displayText + '</span>' +
                sortInfoHtml +
                '</div>' +
                triggeredBadge +
                statusDisplay +
                '</li>';
        },

        /**
         * Renders the complete alerts list.
         * When groups filter is active, displays alerts grouped by their group names.
         */
        renderAlertsList(alerts) {
            if (!alerts || alerts.length === 0) {
                return '<p class="no-alerts">No active alerts. Create one to get started!</p>';
            }

            // Apply active filters then sort
            const filteredAlerts = SortManager.applySort(FilterManager.applyFilters(alerts));

            if (filteredAlerts.length === 0) {
                return '<p class="no-alerts">No alerts match the current filters.</p>';
            }

            // Check if groups filter is active - if so, render grouped
            const selectedGroups = AlertsState.getFilterValue('myGroups');
            if (selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups')) {
                return this.renderGroupedAlertsList(filteredAlerts, selectedGroups);
            }

            let html = '<ul class="alerts-list">';
            filteredAlerts.forEach(alert => {
                html += this.renderAlertItem(alert);
            });
            html += '</ul>';
            return html;
        },

        /**
         * Renders alerts grouped by their group names.
         * Groups are displayed in alphabetical order, each with a header.
         */
        renderGroupedAlertsList(alerts, selectedGroups) {
            // Sort selected groups alphabetically
            const sortedGroups = [...selectedGroups].sort((a, b) => a.localeCompare(b));

            // Group alerts by their groups
            const groupedAlerts = {};
            sortedGroups.forEach(group => {
                groupedAlerts[group] = [];
            });

            alerts.forEach(alert => {
                const alertGroups = alert.groups || [];
                sortedGroups.forEach(group => {
                    if (alertGroups.includes(group)) {
                        groupedAlerts[group].push(alert);
                    }
                });
            });

            let html = '';
            sortedGroups.forEach(group => {
                const groupAlerts = groupedAlerts[group];
                if (groupAlerts.length > 0) {
                    const sortedGroupAlerts = SortManager.applySort(groupAlerts);
                    html += '<div class="alert-group">';
                    html += '<h3 class="alert-group-header">' + group + '</h3>';
                    html += '<ul class="alerts-list">';
                    sortedGroupAlerts.forEach(alert => {
                        html += this.renderAlertItem(alert);
                    });
                    html += '</ul>';
                    html += '</div>';
                }
            });

            if (!html) {
                return '<p class="no-alerts">No alerts found in the selected groups.</p>';
            }

            return html;
        },

        /**
         * Renders the spread details modal content.
         */
        renderSpreadItemsList(items) {
            let html = '';
            items.forEach(item => {
                const lowPrice = item.low ? item.low.toLocaleString() : 'N/A';
                const highPrice = item.high ? item.high.toLocaleString() : 'N/A';

                html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Low: ' + lowPrice + ' | High: ' + highPrice + '</div>' +
                    '</div>' +
                    '<span class="spread-item-percentage">' + item.spread + '%</span>' +
                    '</li>';
            });
            return html;
        },

        /**
         * Renders spike items list for all-items spike alerts.
         */
        renderSpikeItemsList(items) {
            let html = '';
            items.forEach(item => {
                const baseline = item.baseline ? item.baseline.toLocaleString() : 'N/A';
                const current = item.current ? item.current.toLocaleString() : 'N/A';
                const percent = item.percent_change != null ? item.percent_change.toFixed(2) : 'N/A';
                const pctClass = (item.percent_change != null && item.percent_change < 0)
                    ? 'spread-item-percentage negative-change'
                    : 'spread-item-percentage';
                html += '<li>' +
                    '<div>' +
                    '<span class="spread-item-name">' + item.item_name + '</span>' +
                    '<div class="spread-item-details">Baseline: ' + baseline + ' | Current: ' + current + '</div>' +
                    '</div>' +
                    '<span class="' + pctClass + '">' + percent + '%</span>' +
                    '</li>';
            });
            return html;
        },

        /**
         * Renders autocomplete suggestions.
         */
        renderSuggestions(items) {
            let html = '';
            items.forEach(item => {
                html += '<div class="suggestion-item" data-id="' + item.id + '" data-name="' + item.name + '">' + item.name + '</div>';
            });
            return html;
        },

        /**
         * Updates the entire My Alerts pane with fresh data.
         * Preserves status notifications and filter tags to prevent flashing.
         */
        updateMyAlertsPane(data) {
            const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
            if (!pane) return;

            if (data && data.groups) {
                AlertsState.setAlertGroups(data.groups);
            }

            // Cache alerts data for instant filtering/sorting
            if (data && data.alerts) {
                AlertsState.setCachedAlerts(data.alerts);
            }

            // Check if any alert checkboxes are checked
            const hasCheckedAlerts = pane.querySelectorAll('.alert-checkbox:checked').length > 0;

            // If any checkboxes are checked, skip the update entirely to preserve selection
            if (hasCheckedAlerts) {
                return;
            }

            // Check if filter dropdown is currently open/focused
            const filterDropdown = pane.querySelector('.filter-dropdown');
            const isFilterDropdownOpen = filterDropdown && document.activeElement === filterDropdown;

            // Check if sort dropdown is currently open/focused
            const sortDropdown = pane.querySelector('.sort-dropdown');
            const isSortDropdownOpen = sortDropdown && document.activeElement === sortDropdown;

            // Check if actions dropdown is currently open/focused
            const actionsDropdown = pane.querySelector('.action-dropdown');
            const isActionsDropdownOpen = actionsDropdown && document.activeElement === actionsDropdown;

            // If there are active filters, a filter input is open, or any dropdown is open, do selective update
            const hasActiveFilters = AlertsState.activeFilters.size > 0;
            const hasFilterInput = pane.querySelector('.filter-input-container') !== null;

            if (hasActiveFilters || hasFilterInput || isFilterDropdownOpen || isSortDropdownOpen || isActionsDropdownOpen) {
                this.updateMyAlertsPaneSelective(data);
                return;
            }

            // Preserve any status notifications (e.g., "Alert created")
            const existingStatusNotifications = pane.querySelectorAll('.status-notification');
            let statusHtml = '';
            existingStatusNotifications.forEach(n => {
                const clone = n.cloneNode(true);
                clone.querySelectorAll('.notification-line[data-kind="triggered"]').forEach(l => l.remove());

                const check = clone.cloneNode(true);
                const btn = check.querySelector('.dismiss-btn');
                if (btn) btn.remove();

                const hasContent = check.textContent.trim().length > 0 || check.querySelector('.notification-line');
                if (hasContent) {
                    statusHtml += clone.outerHTML;
                }
            });

            const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
            const actionsHtml = this.renderActionButtons(data.alerts && data.alerts.length > 0, '');

            let alertsHtml = '';
            if (data.alerts && data.alerts.length > 0) {
                alertsHtml = this.renderAlertsList(data.alerts);
            } else if (!data.triggered || data.triggered.length === 0) {
                alertsHtml = this.renderAlertsList([]);
            }

            pane.innerHTML = '<div id="triggered-notifications">' + statusHtml + notificationsHtml + '</div>' +
                actionsHtml + alertsHtml;
            AlertActions.mergeTriggeredNotificationsIntoStatus();
        },

        /**
         * Selectively updates parts of the My Alerts pane without touching the action bar.
         * Used when filters are active to prevent filter tags from flashing.
         */
        updateMyAlertsPaneSelective(data) {
            const pane = document.querySelector(AlertsConfig.selectors.myAlertsPane);
            if (!pane) return;

            if (data && data.groups) {
                AlertsState.setAlertGroups(data.groups);
            }

            // Update triggered notifications (preserve status notifications)
            const notificationsContainer = pane.querySelector('#triggered-notifications');
            if (notificationsContainer) {
                const existingStatusNotifications = notificationsContainer.querySelectorAll('.status-notification');
                let statusHtml = '';
                existingStatusNotifications.forEach(n => {
                    const clone = n.cloneNode(true);
                    clone.querySelectorAll('.notification-line[data-kind="triggered"]').forEach(l => l.remove());

                    const check = clone.cloneNode(true);
                    const btn = check.querySelector('.dismiss-btn');
                    if (btn) btn.remove();

                    const hasContent = check.textContent.trim().length > 0 || check.querySelector('.notification-line');
                    if (hasContent) {
                        statusHtml += clone.outerHTML;
                    }
                });
                const notificationsHtml = this.renderTriggeredNotifications(data.triggered);
                notificationsContainer.innerHTML = statusHtml + notificationsHtml;
                AlertActions.mergeTriggeredNotificationsIntoStatus();
            }

            // Update alerts list only - find the container to replace
            const alertsList = pane.querySelector('.alerts-list');
            const alertGroup = pane.querySelector('.alert-group');
            const noAlertsMsg = pane.querySelector('.no-alerts');
            const loadingContainer = pane.querySelector('.loading-container');
            const alertsListContainer = pane.querySelector('#alerts-list-container');

            const filteredAlerts = FilterManager.applyFilters(data.alerts || []);
            const sortedAlerts = SortManager.applySort(filteredAlerts);

            // Check if groups filter is active
            const selectedGroups = AlertsState.getFilterValue('myGroups');
            const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');

            // Build the new HTML
            let newHtml = '';
            if (sortedAlerts.length === 0) {
                newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
            } else if (isGroupedView) {
                newHtml = this.renderGroupedAlertsList(sortedAlerts, selectedGroups);
            } else {
                newHtml = '<ul class="alerts-list">';
                sortedAlerts.forEach(alert => {
                    newHtml += this.renderAlertItem(alert);
                });
                newHtml += '</ul>';
            }

            // Replace the existing content
            if (alertGroup) {
                // If we have grouped view, replace all groups
                const allGroups = pane.querySelectorAll('.alert-group');
                const firstGroup = allGroups[0];
                allGroups.forEach((g, i) => {if (i > 0) g.remove();});
                if (firstGroup) {
                    firstGroup.outerHTML = newHtml;
                }
            } else if (alertsList) {
                alertsList.outerHTML = newHtml;
            } else if (alertsListContainer) {
                // Replace the loading container with alerts
                alertsListContainer.outerHTML = newHtml;
            } else if (loadingContainer) {
                // Replace standalone loading container
                loadingContainer.outerHTML = newHtml;
            } else if (noAlertsMsg) {
                noAlertsMsg.outerHTML = newHtml;
            }
        }
    };


    // =============================================================================
    // SORT MANAGEMENT
    // =============================================================================
    const SortManager = {
        options: {
            alphabetically: {id: 'alphabetically', label: 'Alphabetically', defaultOrder: 'asc'},
            lastTriggered: {id: 'lastTriggered', label: 'Last Triggered Time', defaultOrder: 'desc'},
            alertType: {id: 'alertType', label: 'Alert Type', defaultOrder: 'asc'},
            thresholdDistance: {id: 'thresholdDistance', label: 'Threshold Distance', defaultOrder: 'asc'},
            createdDate: {id: 'createdDate', label: 'Created Date', defaultOrder: 'desc'}
        },

        getSortValue(alert, sortKey) {
            switch (sortKey) {
                case 'alphabetically':
                    return (alert.text || '').toLowerCase();
                case 'lastTriggered': {
                    const ts = alert.last_triggered_at || alert.triggered_at || alert.triggered_time || alert.last_triggered_time;
                    return this.parseDateValue(ts);
                }
                case 'alertType':
                    return (alert.type || '').toString();
                case 'thresholdDistance':
                    return this.getThresholdDistance(alert);
                case 'createdDate':
                    return this.parseDateValue(alert.created_at);
                default:
                    return null;
            }
        },

        parseDateValue(value) {
            if (!value) return null;
            const ts = Date.parse(value);
            return isNaN(ts) ? null : ts;
        },

        getThresholdDistance(alert) {
            const {alertTypes} = AlertsConfig;
            if ((alert.type === alertTypes.ABOVE || alert.type === alertTypes.BELOW) && alert.price && alert.current_price) {
                const target = Number(alert.price);
                const current = Number(alert.current_price);
                if (!target || !Number.isFinite(current)) return null;
                const percentDiff = ((current - target) / target) * 100;
                return Number.isFinite(percentDiff) ? percentDiff : null;
            }
            if (alert.type === alertTypes.SPREAD && alert.percentage != null) {
                if (alert.spread_percentage != null) {
                    return Math.abs(alert.percentage - alert.spread_percentage);
                }
                if (alert.spread_current_percentage != null) {
                    return Math.abs(alert.percentage - alert.spread_current_percentage);
                }
            }
            if (alert.type === alertTypes.SPIKE) {
                // Use spike triggered data when available
                if (alert.triggered_data) {
                    try {
                        const data = JSON.parse(alert.triggered_data);
                        const baseline = Number(data?.baseline);
                        const current = Number(data?.current ?? alert.current_price);
                        if (Number.isFinite(baseline) && baseline !== 0 && Number.isFinite(current)) {
                            return ((current - baseline) / baseline) * 100;
                        }
                    } catch (e) {
                        // ignore parse errors
                    }
                }
                // Fallback to current price vs stored baseline in current_price if available (no baseline -> null)
                return null;
            }
            // =============================================================================
            // THRESHOLD ALERT DISTANCE CALCULATION
            // =============================================================================
            // What: Calculate how close a threshold alert is to being triggered
            // Why: Users want to see progress towards their alert threshold in the UI
            // How: For value-based: Calculate % difference between current price and target
            //      For percentage-based: Calculate current % change from baseline vs threshold
            // Note: Only works for single-item alerts; multi-item returns 'multi' flag for UI display
            if (alert.type === alertTypes.THRESHOLD) {
                // Check if this is a multi-item alert (item_ids contains multiple items or is_all_items)
                // What: Determine if alert tracks multiple items
                // Why: Threshold distance calculation only makes sense for single items
                // How: Parse item_ids JSON and check length, or check is_all_items flag
                if (alert.is_all_items) {
                    return 'multi';  // Signal to UI to show "N/A - Tracking Multiple Items"
                }
                if (alert.item_ids) {
                    try {
                        const itemIds = JSON.parse(alert.item_ids);
                        if (Array.isArray(itemIds) && itemIds.length > 1) {
                            return 'multi';  // Signal to UI to show "N/A - Tracking Multiple Items"
                        }
                    } catch (e) {
                        // Ignore parse errors, continue with calculation attempt
                    }
                }
                
                // Single-item threshold alert - calculate distance
                const thresholdType = alert.threshold_type || 'percentage';
                const currentPrice = Number(alert.current_price);
                
                if (!Number.isFinite(currentPrice) || currentPrice === 0) {
                    return null;  // No current price data available
                }
                
                if (thresholdType === 'value') {
                    // Value-based threshold: Calculate % distance from current price to target price
                    // What: How far is current price from the target in percentage terms
                    // Why: Gives user a sense of how close they are to their price target
                    // How: ((target - current) / current) * 100 for up direction
                    //      ((current - target) / current) * 100 for down direction
                    const targetPrice = Number(alert.target_price);
                    if (!Number.isFinite(targetPrice) || targetPrice === 0) {
                        return null;
                    }
                    
                    const direction = alert.direction || 'up';
                    if (direction === 'up') {
                        // For "up" alerts, positive = price needs to go up, negative = already above target
                        return ((targetPrice - currentPrice) / currentPrice) * 100;
                    } else {
                        // For "down" alerts, positive = price needs to go down, negative = already below target
                        return ((currentPrice - targetPrice) / currentPrice) * 100;
                    }
                } else {
                    // Percentage-based threshold: Calculate current % change from baseline
                    // What: How much has the price changed from baseline, compared to threshold
                    // Why: Shows progress towards the percentage threshold
                    // How: Parse reference_prices to get baseline, calculate current % change
                    if (!alert.reference_prices) {
                        return null;  // No baseline prices stored
                    }
                    
                    let baseline = null;
                    try {
                        const refPrices = JSON.parse(alert.reference_prices);
                        // For single-item alerts, get the baseline for the tracked item
                        const itemId = String(alert.item_id);
                        baseline = Number(refPrices[itemId]);
                    } catch (e) {
                        return null;  // Parse error
                    }
                    
                    if (!Number.isFinite(baseline) || baseline === 0) {
                        return null;  // Invalid baseline
                    }
                    
                    // Calculate current % change from baseline
                    // What: The actual percentage change that has occurred
                    // Why: Compare this to the threshold percentage to see how close to triggering
                    const currentChange = ((currentPrice - baseline) / baseline) * 100;
                    const thresholdPct = Number(alert.percentage) || 0;
                    const direction = alert.direction || 'up';
                    
                    if (direction === 'up') {
                        // For "up" alerts: threshold - currentChange = how much more it needs to rise
                        // Positive = needs to rise more, negative = already above threshold
                        return thresholdPct - currentChange;
                    } else {
                        // For "down" alerts: (-thresholdPct) - currentChange = how much more it needs to fall
                        // We want to show: if threshold is -5% and current is -3%, distance is 2%
                        return (-thresholdPct) - currentChange;
                    }
                }
            }
            return null;
        },

        applySort(alerts) {
            const sorted = [...alerts];
            const {sortKey, sortOrder} = AlertsState.sorting || {};
            if (!sortKey) {
                return sorted.sort((a, b) => (a.text || '').localeCompare(b.text || ''));
            }

            const direction = sortOrder === 'asc' ? 1 : -1;

            sorted.sort((a, b) => {
                const aVal = this.getSortValue(a, sortKey);
                const bVal = this.getSortValue(b, sortKey);
                // =============================================================================
                // HANDLE MISSING/INVALID SORT VALUES
                // =============================================================================
                // What: Determine if sort values are missing or non-numeric
                // Why: Alerts with missing values (null, undefined, NaN, 'multi') should sort to the end
                // How: Check for null, undefined, NaN, and string values (like 'multi' for multi-item alerts)
                const aMissing = aVal === null || aVal === undefined || Number.isNaN(aVal) || typeof aVal === 'string';
                const bMissing = bVal === null || bVal === undefined || Number.isNaN(bVal) || typeof bVal === 'string';

                if (!aMissing || !bMissing) {
                    if (aMissing) return 1;
                    if (bMissing) return -1;
                    if (aVal > bVal) return direction;
                    if (aVal < bVal) return -direction;
                }

                return (a.text || '').localeCompare(b.text || '');
            });

            return sorted;
        },

        handleSortSelection(sortKey) {
            if (!sortKey) return;
            const defaultOrder = this.options[sortKey]?.defaultOrder || 'asc';

            // If same sort is already active, just toggle order
            if (AlertsState.sorting.sortKey === sortKey) {
                this.toggleSortOrder();
                return;
            }

            // Apply new sort with default order
            AlertsState.sorting.sortKey = sortKey;
            AlertsState.sorting.sortOrder = defaultOrder;
            AlertsState.sorting.pendingKey = null;
            this.updateSortIndicator();
            FilterManager.updateAlertsList();
        },

        toggleSortOrder() {
            if (!AlertsState.sorting.sortKey) return;
            AlertsState.sorting.sortOrder = AlertsState.sorting.sortOrder === 'asc' ? 'desc' : 'asc';
            this.updateSortIndicator();
            FilterManager.updateAlertsList();
        },

        updateSortIndicator() {
            const indicator = document.getElementById('sortIndicator');
            const valueEl = document.getElementById('sortIndicatorValue');
            const arrowEl = document.getElementById('sortIndicatorArrow');

            // Mobile sort indicator elements
            const mobileRow = document.getElementById('sortIndicatorMobileRow');
            const mobileIndicator = document.getElementById('sortIndicatorMobile');
            const mobileValueEl = document.getElementById('sortIndicatorValueMobile');
            const mobileArrowEl = document.getElementById('sortIndicatorArrowMobile');

            if (!indicator) return;

            if (AlertsState.sorting.sortKey) {
                const option = this.options[AlertsState.sorting.sortKey];
                const label = option ? option.label : 'Sort';
                const arrow = AlertsState.sorting.sortOrder === 'asc' ? 'â†‘' : 'â†“';

                // Update desktop indicator
                if (valueEl) valueEl.textContent = label;
                if (arrowEl) arrowEl.textContent = arrow;
                indicator.classList.add('active');

                // Update mobile indicator
                if (mobileValueEl) mobileValueEl.textContent = label;
                if (mobileArrowEl) mobileArrowEl.textContent = arrow;
                if (mobileIndicator) mobileIndicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
                if (mobileIndicator) mobileIndicator.classList.remove('active');
            }

            // Update dropdown active states
            syncSortDropdownState();
        },

        applySortOrder(order) {
            const sortKey = AlertsState.sorting.pendingKey || AlertsState.sorting.sortKey;
            if (!sortKey) return;
            AlertsState.sorting.sortKey = sortKey;
            AlertsState.sorting.sortOrder = order || this.options[sortKey]?.defaultOrder || 'asc';
            AlertsState.sorting.pendingKey = null;
            this.updateSortIndicator();
            FilterManager.updateAlertsList();
            AlertsRefresh.resumeAfterSort();
        },

        clearSort() {
            AlertsState.sorting = {sortKey: null, sortOrder: null, pendingKey: null};
            this.updateSortIndicator();
            FilterManager.updateAlertsList();
        },

        renderSortTag() {
            // No longer using sort tags - using sort indicator instead
            // Keep this method for compatibility but do nothing
        }
    };


    // =============================================================================
    // FILTER MANAGEMENT
    // =============================================================================
    /**
     * Manages alert list filtering.
     * 
     * Why: Users need to filter alerts by various criteria (triggered status, etc.)
     * to quickly find relevant alerts.
     * 
     * How: Maintains a set of active filter IDs in AlertsState. When rendering,
     * alerts are filtered through all active filter test functions.
     */
    const FilterManager = {
        /**
         * Adds a filter to the active filters set and updates the DOM.
         * For input-based filters, shows an input prompt first.
         */
        addFilter(filterId) {
            const filter = AlertsConfig.filters[filterId];
            if (!filter) return;
            if (filterId === 'myGroups' && AlertsState.activeFilters.has(filterId)) {
                this.showFilterModal(filterId);
                return;
            }
            if (AlertsState.activeFilters.has(filterId)) return;

            // If filter requires a modal, open it
            if (filter.requiresModal) {
                this.showFilterModal(filterId);
                return;
            }

            // If filter requires input, show input UI instead of adding directly
            if (filter.requiresInput) {
                this.showFilterInput(filterId);
                return;
            }

            this.activateFilter(filterId);
        },

        /**
         * Shows a modal for a modal-based filter.
         */
        showFilterModal(filterId) {
            const dropdown = document.querySelector('#active-filters .filter-dropdown');
            if (dropdown) dropdown.value = '';
            if (filterId === 'myGroups') {
                openGroupsFilterModal();
            } else if (filterId === 'priceRange') {
                openPriceFilterModal();
            }
        },

        /**
         * Shows the input UI for an input-based filter.
         */
        showFilterInput(filterId) {
            const filter = AlertsConfig.filters[filterId];
            const container = document.querySelector('#active-filters');
            const dropdown = container ? container.querySelector('.filter-dropdown') : null;
            if (!dropdown) return;

            // Create input UI
            const inputHtml = '<span class="filter-input-container" data-filter-id="' + filterId + '">' +
                '<input type="' + (filter.inputType || 'text') + '" class="filter-input" ' +
                'placeholder="' + (filter.inputPlaceholder || 'Enter value...') + '" ' +
                'onkeydown="handleFilterInputKeydown(event, \'' + filterId + '\')">' +
                '<button class="filter-input-confirm" onclick="confirmFilterInput(\'' + filterId + '\')">âœ“</button>' +
                '<button class="filter-input-cancel" onclick="cancelFilterInput(\'' + filterId + '\')">&times;</button>' +
                '</span>';

            dropdown.insertAdjacentHTML('beforebegin', inputHtml);

            // Focus the input
            const input = container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"] .filter-input');
            if (input) input.focus();

            // Reset dropdown
            dropdown.value = '';
        },

        /**
         * Confirms the input for an input-based filter and activates it.
         */
        confirmFilterInput(filterId) {
            const container = document.querySelector('#active-filters');
            const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
            const input = inputContainer ? inputContainer.querySelector('.filter-input') : null;

            if (!input || !input.value.trim()) {
                this.cancelFilterInput(filterId);
                return;
            }

            const value = input.value.trim();
            AlertsState.setFilterValue(filterId, value);

            // Remove input container
            inputContainer.remove();

            // Activate the filter with the value displayed
            this.activateFilter(filterId, value);
        },

        /**
         * Cancels the input for an input-based filter.
         */
        cancelFilterInput(filterId) {
            const container = document.querySelector('#active-filters');
            const inputContainer = container ? container.querySelector('.filter-input-container[data-filter-id="' + filterId + '"]') : null;
            if (inputContainer) {
                inputContainer.remove();
            }
        },

        /**
         * Activates a filter and adds its tag to the DOM.
         * @param {string} filterId - The filter ID
         * @param {string} displayValue - Optional value to display in the tag
         */
        activateFilter(filterId, displayValue) {
            AlertsState.activeFilters.add(filterId);

            // Add filter tag to DOM
            const filter = AlertsConfig.filters[filterId];
            const container = document.querySelector('#active-filters');
            const dropdown = container ? container.querySelector('.filter-dropdown') : null;
            const tagContainer = document.querySelector('.alert-indicators .filter-tags');
            if (dropdown) {
                // Format the label based on whether it's a numeric value or not
                let label;
                if (displayValue) {
                    const numValue = parseInt(displayValue);
                    if (!isNaN(numValue) && filter.requiresInput) {
                        label = filter.label + ': ' + numValue.toLocaleString();
                    } else {
                        label = filter.label + ': ' + displayValue;
                    }
                } else {
                    label = filter.label;
                }
                const tagHtml = '<span class="filter-tag" data-filter-id="' + filterId + '">' + label +
                    '<button class="filter-tag-remove" onclick="removeFilter(\'' + filterId + '\')">&times;</button>' +
                    '</span>';
                if (tagContainer) {
                    tagContainer.insertAdjacentHTML('beforeend', tagHtml);
                } else {
                    dropdown.insertAdjacentHTML('beforebegin', tagHtml);
                }

                // Remove the option from dropdown
                const option = dropdown.querySelector('option[value="' + filterId + '"]');
                if (option && filterId !== 'myGroups') option.remove();
            }

            // Only update the alerts list, not the entire pane
            this.updateAlertsList();
        },

        /**
         * Removes a filter from the active filters set.
         */
        removeFilter(filterId) {
            AlertsState.activeFilters.delete(filterId);
            AlertsState.filterValues[filterId] = null; // Clear any stored value

            const tagEl = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
            if (tagEl) tagEl.remove();

            // Re-add the option to dropdown
            const filter = AlertsConfig.filters[filterId];
            const dropdown = document.querySelector('#active-filters .filter-dropdown');
            if (dropdown && filter) {
                const existingOption = dropdown.querySelector('option[value="' + filterId + '"]');
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = filterId;
                    option.textContent = filter.label;
                    dropdown.appendChild(option);
                }
            }

            // Only update the alerts list, not the entire pane
            this.updateAlertsList();
        },

        /**
         * Updates just the alerts list based on current filters.
         * Uses cached alerts data for instant response - no network request.
         */
        updateAlertsList() {
            const alerts = AlertsState.getCachedAlerts();

            const pane = document.querySelector('#my-alerts');
            if (!pane) return;

            const alertsList = pane.querySelector('.alerts-list');
            const alertGroup = pane.querySelector('.alert-group');
            const noAlertsMsg = pane.querySelector('.no-alerts');
            const filteredAlerts = this.applyFilters(alerts);
            const sortedAlerts = SortManager.applySort(filteredAlerts);
            const selectedGroups = AlertsState.getFilterValue('myGroups');
            const isGroupedView = selectedGroups && selectedGroups.length > 0 && AlertsState.activeFilters.has('myGroups');

            let newHtml = '';
            if (sortedAlerts.length === 0) {
                newHtml = '<p class="no-alerts">No alerts match the current filters.</p>';
            } else if (isGroupedView) {
                newHtml = AlertsUI.renderGroupedAlertsList(sortedAlerts, selectedGroups);
            } else {
                newHtml = '<ul class="alerts-list">';
                sortedAlerts.forEach(alert => {
                    newHtml += AlertsUI.renderAlertItem(alert);
                });
                newHtml += '</ul>';
            }

            if (alertGroup) {
                const allGroups = pane.querySelectorAll('.alert-group');
                const firstGroup = allGroups[0];
                allGroups.forEach((g, i) => {if (i > 0) g.remove();});
                if (firstGroup) {
                    firstGroup.outerHTML = newHtml;
                }
            } else if (alertsList) {
                alertsList.outerHTML = newHtml;
            } else if (noAlertsMsg) {
                noAlertsMsg.outerHTML = newHtml;
            }
        },

        /**
         * Checks if a filter is currently active.
         */
        isActive(filterId) {
            return AlertsState.activeFilters.has(filterId);
        },

        /**
         * Applies all active filters to an array of alerts.
         * Returns only alerts that pass ALL active filter tests.
         */
        applyFilters(alerts) {
            let result = alerts;

            // Apply search filter first
            if (AlertsState.searchQuery && AlertsState.searchQuery.trim()) {
                const query = AlertsState.searchQuery.toLowerCase().trim();
                result = result.filter(alert => {
                    const text = (alert.text || '').toLowerCase();
                    return text.includes(query);
                });
            }

            // Apply active filters
            if (AlertsState.activeFilters.size === 0) {
                return result;
            }

            return result.filter(alert => {
                for (const filterId of AlertsState.activeFilters) {
                    const filter = AlertsConfig.filters[filterId];
                    if (!filter) continue;

                    // Use testWithValue for input-based or modal-based filters
                    if ((filter.requiresInput || filter.requiresModal) && filter.testWithValue) {
                        const value = AlertsState.getFilterValue(filterId);
                        if (!filter.testWithValue(alert, value)) {
                            return false;
                        }
                    } else if (filter.test && !filter.test(alert)) {
                        return false;
                    }
                }
                return true;
            });
        }
    };


    // =============================================================================
    // FORM MANAGEMENT
    // =============================================================================
    /**
     * Manages form field visibility and state for create/edit forms.
     * 
     * Why: Different alert types require different fields. This manager handles
     * showing/hiding the appropriate fields based on user selections.
     * 
     * How: Uses configuration-driven approach to map alert types to visible fields.
     */
    const FormManager = {
        /**
         * Updates tabindex values based on alert type and scope (specific/all items).
         * 
         * What: Dynamically sets tabindex attributes to match visual layout
         * Why: The visual order of fields changes when switching between "Specific Items" and "All Items"
         *      modes because different fields are shown/hidden. Tab order must match visual order.
         * How: Defines tabindex maps for each alert type and scope combination, then applies them
         * 
         * @param {string} alertType - The type of alert ('spread', 'spike', 'sustained', 'threshold')
         * @param {boolean} isAllItems - Whether "All Items" mode is selected
         */
        updateTabIndices(alertType, isAllItems) {
            // =============================================================================
            // TABINDEX CONFIGURATION
            // =============================================================================
            // What: Defines the correct tab order for each alert type and scope combination
            // Why: Visual field order differs between "Specific Items" (shows item selector) and
            //      "All Items" (shows min/max price filters) modes
            // How: Maps field IDs to tabindex values based on their visual position in each mode
            // Note: Values start at 7 because common fields (Alert Type, Name, Group) use 1-6
            // =============================================================================
            
            const tabConfigs = {
                // SPREAD alert tabindex configuration
                spread: {
                    // Specific Items: Apply To â†’ Items â†’ Percentage â†’ Notifications
                    specific: {
                        'spread-scope': 7,
                        'spread-item-input': 8,
                        'spread-multi-item-toggle': 9,
                        'percentage': 10
                    },
                    // All Items: Apply To â†’ Max Price â†’ Min Price â†’ Percentage â†’ Notifications
                    all: {
                        'spread-scope': 7,
                        'maximum-price': 8,
                        'minimum-price': 9,
                        'percentage': 10
                    }
                },
                
                // SPIKE alert tabindex configuration
                spike: {
                    // Specific Items: Apply To â†’ Items â†’ Direction â†’ Percentage â†’ Reference â†’ Time Frame
                    specific: {
                        'spike-scope': 7,
                        'spike-item-input': 8,
                        'spike-multi-item-toggle': 9,
                        'direction': 10,
                        'percentage': 11,
                        'reference': 12,
                        'time-frame': 13
                    },
                    // All Items: Apply To â†’ Direction â†’ Max Price â†’ Min Price â†’ Percentage â†’ Reference â†’ Time Frame
                    all: {
                        'spike-scope': 7,
                        'direction': 8,
                        'maximum-price': 9,
                        'minimum-price': 10,
                        'percentage': 11,
                        'reference': 12,
                        'time-frame': 13
                    }
                },
                
                // SUSTAINED alert tabindex configuration
                sustained: {
                    // Specific Items: Apply To â†’ Items â†’ Direction â†’ Market Pressure â†’ Min Consecutive â†’
                    //                 Min Move% â†’ Min Spread% â†’ Min Volume â†’ Reference â†’ Time Frame â†’
                    //                 Vol Buffer â†’ Vol Multiplier
                    specific: {
                        'sustained-scope': 7,
                        'sustained-item-input': 8,
                        'sustained-multi-item-toggle': 9,
                        'direction': 10,
                        'min-pressure-strength': 11,
                        'min-consecutive-moves': 12,
                        'min-move-percentage': 13,
                        'min-pressure-spread': 14,
                        'min-volume': 15,
                        'reference': 16,
                        'time-frame': 17,
                        'volatility-buffer-size': 18,
                        'volatility-multiplier': 19
                    },
                    // All Items: Apply To â†’ Direction â†’ Market Pressure â†’ Max Price â†’ Min Consecutive â†’
                    //            Min Move% â†’ Min Spread% â†’ Min Volume â†’ Min Price â†’ Reference â†’ Time Frame â†’
                    //            Vol Buffer â†’ Vol Multiplier
                    all: {
                        'sustained-scope': 7,
                        'direction': 8,
                        'min-pressure-strength': 9,
                        'maximum-price': 10,
                        'min-consecutive-moves': 11,
                        'min-move-percentage': 12,
                        'min-pressure-spread': 13,
                        'min-volume': 14,
                        'minimum-price': 15,
                        'reference': 16,
                        'time-frame': 17,
                        'volatility-buffer-size': 18,
                        'volatility-multiplier': 19
                    }
                },
                
                // THRESHOLD alert tabindex configuration
                threshold: {
                    // Specific Items: Apply To â†’ Items â†’ Above/Below â†’ Threshold Type â†’ Reference â†’ Threshold
                    specific: {
                        'threshold-items-tracked': 7,
                        'threshold-item-input': 8,
                        'threshold-multi-item-toggle': 9,
                        'threshold-direction': 10,
                        'threshold-type': 11,
                        'threshold-reference': 12,
                        'threshold-value': 13
                    },
                    // All Items: Apply To â†’ Above/Below â†’ Threshold Type â†’ Max Price â†’ Min Price â†’ Reference â†’ Threshold
                    all: {
                        'threshold-items-tracked': 7,
                        'threshold-direction': 8,
                        'threshold-type': 9,
                        'maximum-price': 10,
                        'minimum-price': 11,
                        'threshold-reference': 12,
                        'threshold-value': 13
                    }
                }
            };
            
            // Get the configuration for this alert type and scope
            const config = tabConfigs[alertType];
            if (!config) return;
            
            const tabMap = isAllItems ? config.all : config.specific;
            
            // Apply tabindex values to each field
            // What: Set the tabindex attribute on each input/select element
            // Why: Browser uses tabindex to determine tab navigation order
            // How: Find each element by ID and set its tabindex attribute
            for (const [fieldId, tabIndex] of Object.entries(tabMap)) {
                const element = document.getElementById(fieldId);
                if (element) {
                    element.setAttribute('tabindex', tabIndex);
                }
            }
        },

        /**
         * Updates form field visibility based on selected alert type.
         * 
         * @param {string} formType - 'create' for create form
         */
        handleAlertTypeChange(formType) {
            const selectors = AlertsConfig.selectors[formType];
            const alertType = document.querySelector(selectors.alertType).value;
            const groups = selectors.groups;

            // Get all form group elements
            const elements = {
                spreadScope: document.querySelector(groups.spreadScope),
                spreadItems: document.querySelector(groups.spreadItems),  // Spread multi-item selector group
                spikeScope: document.querySelector(groups.spikeScope),
                spikeItems: document.querySelector(groups.spikeItems),
                itemName: document.querySelector(groups.itemName),
                price: document.querySelector(groups.price),
                reference: document.querySelector(groups.reference),
                percentage: document.querySelector(groups.percentage),
                timeFrame: document.querySelector(groups.timeFrame),
                direction: document.querySelector(groups.direction),
                minPrice: document.querySelector(groups.minPrice),
                maxPrice: document.querySelector(groups.maxPrice),
                minConsecutiveMoves: document.querySelector(groups.minConsecutiveMoves),
                minMovePercentage: document.querySelector(groups.minMovePercentage),
                volatilityBuffer: document.querySelector(groups.volatilityBuffer),
                volatilityMultiplier: document.querySelector(groups.volatilityMultiplier),
                minVolume: document.querySelector(groups.minVolume),
                sustainedScope: document.querySelector(groups.sustainedScope),
                sustainedItems: document.querySelector(groups.sustainedItems),
                pressureStrength: document.querySelector(groups.pressureStrength),
                pressureSpread: document.querySelector(groups.pressureSpread),
                // Threshold alert elements
                thresholdItemsTracked: document.querySelector(groups.thresholdItemsTracked),
                thresholdItems: document.querySelector(groups.thresholdItems),
                thresholdType: document.querySelector(groups.thresholdType),
                thresholdDirection: document.querySelector(groups.thresholdDirection),
                thresholdValue: document.querySelector(groups.thresholdValue),
                thresholdReference: document.querySelector(groups.thresholdReference)
            };

            // Helper to hide all sustained move fields
            const hideSustainedFields = () => {
                if (elements.minConsecutiveMoves) elements.minConsecutiveMoves.style.display = 'none';
                if (elements.minMovePercentage) elements.minMovePercentage.style.display = 'none';
                if (elements.volatilityBuffer) elements.volatilityBuffer.style.display = 'none';
                if (elements.volatilityMultiplier) elements.volatilityMultiplier.style.display = 'none';
                if (elements.minVolume) elements.minVolume.style.display = 'none';
                if (elements.sustainedScope) elements.sustainedScope.style.display = 'none';
                if (elements.sustainedItems) elements.sustainedItems.style.display = 'none';
                if (elements.pressureStrength) elements.pressureStrength.style.display = 'none';
                if (elements.pressureSpread) elements.pressureSpread.style.display = 'none';
            };

            /**
             * Helper to hide all threshold alert specific fields
             * What: Hides all form fields that are specific to threshold alerts
             * Why: When switching away from threshold alert type, these fields should be hidden
             * How: Sets display to 'none' for each threshold-specific field group
             */
            const hideThresholdFields = () => {
                if (elements.thresholdItemsTracked) elements.thresholdItemsTracked.style.display = 'none';
                if (elements.thresholdItems) elements.thresholdItems.style.display = 'none';
                if (elements.thresholdType) elements.thresholdType.style.display = 'none';
                if (elements.thresholdDirection) elements.thresholdDirection.style.display = 'none';
                if (elements.thresholdValue) elements.thresholdValue.style.display = 'none';
                if (elements.thresholdReference) elements.thresholdReference.style.display = 'none';
                // Clear selected items when hiding
                ThresholdMultiItemSelector.clear();
            };

            /**
             * Helper to hide all spike alert specific fields
             * What: Hides the spike scope selector and multi-item selector
             * Why: When switching away from spike alert type, these fields should be hidden
             * How: Sets display to 'none' for spike-specific field groups and clears selected items
             */
            const hideSpikeFields = () => {
                if (elements.spikeScope) elements.spikeScope.style.display = 'none';
                if (elements.spikeItems) elements.spikeItems.style.display = 'none';
                // Clear selected items when hiding
                if (typeof SpikeMultiItemSelector !== 'undefined') {
                    SpikeMultiItemSelector.clear();
                }
            };
            
            /**
             * Helper to hide all spread alert specific fields
             * What: Hides the spread scope selector and multi-item selector
             * Why: When switching away from spread alert type, these fields should be hidden
             *      to prevent duplicate item input elements from appearing
             * How: Sets display to 'none' for spread-specific field groups and clears selected items
             */
            const hideSpreadFields = () => {
                if (elements.spreadScope) elements.spreadScope.style.display = 'none';
                if (elements.spreadItems) elements.spreadItems.style.display = 'none';
                // Clear selected items when hiding
                if (typeof SpreadMultiItemSelector !== 'undefined') {
                    SpreadMultiItemSelector.clear();
                }
            };

            if (alertType === AlertsConfig.alertTypes.SPREAD) {
                // Spread alerts: show spread-specific fields
                elements.spreadScope.style.display = 'block';
                elements.itemName.style.display = 'block';
                elements.price.style.display = 'none';
                elements.reference.style.display = 'none';
                elements.percentage.style.display = 'block';
                elements.timeFrame.style.display = 'none';
                elements.direction.style.display = 'none';
                hideSustainedFields();
                hideThresholdFields();
                hideSpikeFields();

                // Let scope change handler determine remaining visibility
                this.handleSpreadScopeChange(formType);
            } else if (alertType === AlertsConfig.alertTypes.SPIKE) {
                // Spike alerts: show spike scope selector + percentage + time frame + direction
                // What: Configure form fields for spike alert creation
                // Why: Spike alerts can monitor all items or specific item(s) via the multi-item selector
                // How: Show spike-specific fields and use handleSpikeScopeChange to manage item selector visibility
                hideSpreadFields();  // Hide spread items to prevent duplicate item inputs
                if (elements.spikeScope) elements.spikeScope.style.display = 'block';
                // Note: itemName is hidden for spike alerts - we use the multi-item selector instead
                elements.itemName.style.display = 'none';
                elements.price.style.display = 'none';
                elements.reference.style.display = 'block';
                elements.percentage.style.display = 'block';
                elements.timeFrame.style.display = 'block';
                elements.direction.style.display = 'block';
                hideSustainedFields();
                hideThresholdFields();
                // Spike uses min/max only when all items selected; handleSpikeScopeChange manages visibility
                this.handleSpikeScopeChange(formType);
            } else if (alertType === AlertsConfig.alertTypes.SUSTAINED) {
                // Sustained Move alerts: scope selector + time frame + direction + reference + sustained-specific fields
                // What: Configure form fields for sustained move alert creation
                // Why: Sustained alerts need reference price selection (High/Low/Average) like spike and threshold
                // How: Show all sustained-specific fields plus the reference dropdown
                hideSpreadFields();  // Hide spread items to prevent duplicate item inputs
                hideSpikeFields();
                elements.itemName.style.display = 'none';
                elements.price.style.display = 'none';
                elements.reference.style.display = 'block';  // Show reference selector for sustained alerts
                elements.percentage.style.display = 'none';
                elements.timeFrame.style.display = 'block';
                elements.direction.style.display = 'block';
                hideThresholdFields();

                // Show sustained scope selector
                if (elements.sustainedScope) elements.sustainedScope.style.display = 'block';

                // Show sustained-specific fields
                if (elements.minConsecutiveMoves) elements.minConsecutiveMoves.style.display = 'block';
                if (elements.minMovePercentage) elements.minMovePercentage.style.display = 'block';
                if (elements.volatilityBuffer) elements.volatilityBuffer.style.display = 'block';
                if (elements.volatilityMultiplier) elements.volatilityMultiplier.style.display = 'block';
                if (elements.minVolume) elements.minVolume.style.display = 'block';

                // Show pressure filter fields
                if (elements.pressureStrength) elements.pressureStrength.style.display = 'block';
                if (elements.pressureSpread) elements.pressureSpread.style.display = 'block';

                // Let scope change handler determine item selector vs min/max price
                this.handleSustainedScopeChange(formType);
            } else if (alertType === AlertsConfig.alertTypes.THRESHOLD) {
                /**
                 * Threshold alerts configuration
                 * What: Shows threshold-specific fields and hides other alert type fields
                 * Why: Threshold alerts have a unique set of configuration options
                 * How: Hides spread/sustained/spike/above/below specific fields, shows threshold fields
                 */
                hideSpreadFields();  // Hide spread items to prevent duplicate item inputs
                hideSpikeFields();   // Hide spike items to prevent duplicate item inputs
                hideSustainedFields();
                if (elements.numberItems) elements.numberItems.style.display = 'none';
                elements.itemName.style.display = 'none';  // Using threshold's own item selector
                elements.price.style.display = 'none';  // Using threshold value instead
                elements.reference.style.display = 'none';  // Using threshold reference instead
                elements.percentage.style.display = 'none';  // Using threshold value instead
                elements.timeFrame.style.display = 'none';
                elements.direction.style.display = 'none';  // Using threshold direction instead
                elements.minPrice.style.display = 'none';
                elements.maxPrice.style.display = 'none';

                // Show threshold-specific fields
                if (elements.thresholdItemsTracked) elements.thresholdItemsTracked.style.display = 'block';
                if (elements.thresholdType) elements.thresholdType.style.display = 'block';
                if (elements.thresholdDirection) elements.thresholdDirection.style.display = 'block';
                if (elements.thresholdValue) elements.thresholdValue.style.display = 'block';
                if (elements.thresholdReference) elements.thresholdReference.style.display = 'block';

                // Let items tracked change handler determine item selector visibility
                this.handleThresholdItemsTrackedChange(formType);

                // Set is_all_items based on items tracked selection
                const itemsTrackedSelect = document.querySelector(selectors.thresholdItemsTracked);
                if (itemsTrackedSelect) {
                    document.querySelector(selectors.isAllItems).value = itemsTrackedSelect.value === 'all' ? 'true' : 'false';
                }
            } else {
                // Above/Below alerts: show threshold fields
                hideSpreadFields();  // Hide spread items to prevent duplicate item inputs
                hideSpikeFields();   // Hide spike items to prevent duplicate item inputs
                hideSustainedFields();
                hideThresholdFields();
                if (elements.numberItems) elements.numberItems.style.display = 'none';
                elements.itemName.style.display = 'block';
                elements.price.style.display = 'block';
                elements.reference.style.display = 'block';
                elements.percentage.style.display = 'none';
                elements.timeFrame.style.display = 'none';
                elements.direction.style.display = 'none';
                elements.minPrice.style.display = 'none';
                elements.maxPrice.style.display = 'none';

                // Reset is_all_items
                document.querySelector(selectors.isAllItems).value = 'false';
            }

            const directionInput = document.querySelector(selectors.direction);
            if (directionInput && elements.direction.style.display === 'none') {
                directionInput.value = 'both';
            }
        },

        /**
         * Handles changes to the threshold alert "Items Tracked" dropdown.
         * 
         * What: Shows/hides the item selector and manages threshold type based on selection
         * Why: When "All Items" is selected, items selector is hidden and threshold type is locked to percentage
         *      When "Specific Items" is selected, items selector is shown and threshold type can be changed
         * How: Toggles visibility of items group and enforces percentage type for multi-item scenarios
         * 
         * @param {string} formType - 'create' for create form
         */
        handleThresholdItemsTrackedChange(formType) {
            const selectors = AlertsConfig.selectors[formType];
            const groups = selectors.groups;
            
            // Get the items tracked selection
            const itemsTrackedSelect = document.querySelector(selectors.thresholdItemsTracked);
            const thresholdItemsGroup = document.querySelector(groups.thresholdItems);
            const thresholdTypeSelect = document.querySelector(selectors.thresholdType);
            const isAllItemsInput = document.querySelector(selectors.isAllItems);
            
            // minPriceGroup/maxPriceGroup: Price filter containers for "all items" mode
            // What: DOM elements for minimum and maximum price filter inputs
            // Why: When tracking all items, users need to filter by price range to avoid noise
            // How: Show these fields only when "All Items" is selected
            const minPriceGroup = document.querySelector(groups.minPrice);
            const maxPriceGroup = document.querySelector(groups.maxPrice);
            
            if (!itemsTrackedSelect) return;
            
            const selection = itemsTrackedSelect.value;
            
            if (selection === 'all') {
                // All Items mode: hide item selector, show price filters, lock threshold type to percentage
                if (thresholdItemsGroup) thresholdItemsGroup.style.display = 'none';
                if (isAllItemsInput) isAllItemsInput.value = 'true';
                
                // Show min/max price filters for all items mode
                // What: Display price range filters when tracking all items
                // Why: Users need to filter which items to monitor based on price range
                // How: Set display to 'block' for both min and max price groups
                if (minPriceGroup) minPriceGroup.style.display = 'block';
                if (maxPriceGroup) maxPriceGroup.style.display = 'block';
                
                // Force percentage type for all items (can't use value for all items)
                if (thresholdTypeSelect) {
                    thresholdTypeSelect.value = 'percentage';
                    thresholdTypeSelect.disabled = true;
                }
                
                // Show locked indicator since threshold type is forced to percentage
                // What: Display ðŸš« icon to indicate dropdown is locked
                // Why: Users need visual feedback that they cannot change this setting
                // How: Call helper function that manages indicator visibility
                this.updateThresholdTypeLockIndicator(true);
                
                // Clear any selected items
                ThresholdMultiItemSelector.clear();
                
                // Update tabindex values for All Items mode
                this.updateTabIndices('threshold', true);
            } else {
                // Specific Items mode: show item selector, hide price filters
                if (thresholdItemsGroup) thresholdItemsGroup.style.display = 'block';
                if (isAllItemsInput) isAllItemsInput.value = 'false';
                
                // Hide min/max price filters for specific items mode
                // What: Hide price range filters when tracking specific items
                // Why: Price filters only apply to "all items" mode where we need to narrow down
                // How: Set display to 'none' for both min and max price groups
                if (minPriceGroup) minPriceGroup.style.display = 'none';
                if (maxPriceGroup) maxPriceGroup.style.display = 'none';
                
                // Hide locked indicator (updateThresholdTypeState will re-show if needed)
                // What: Initially hide the locked indicator when switching to specific items
                // Why: Indicator should only show if multiple items are selected
                // How: Call helper function, then let updateThresholdTypeState decide
                this.updateThresholdTypeLockIndicator(false);
                
                // Check if threshold type should be enabled or disabled based on item count
                this.updateThresholdTypeState();
                
                // Update tabindex values for Specific Items mode
                this.updateTabIndices('threshold', false);
            }
        },

        /**
         * Updates the threshold type dropdown state based on selected item count.
         * 
         * What: Enables/disables threshold type dropdown based on number of selected items
         * Why: Value-based threshold only makes sense for single item; percentage works for multiple
         * How: If more than 1 item selected, force percentage and disable dropdown
         */
        updateThresholdTypeState() {
            const thresholdTypeSelect = document.querySelector(AlertsConfig.selectors.create.thresholdType);
            const selectedCount = ThresholdMultiItemSelector.selectedItems.length;
            // lockedIndicator: The ðŸš« icon that appears when dropdown is locked
            const lockedIndicator = document.getElementById('threshold-type-locked-indicator');
            // lockedTooltip: The explanation popup that appears when indicator is clicked
            const lockedTooltip = document.getElementById('threshold-type-locked-tooltip');
            
            if (!thresholdTypeSelect) return;
            
            if (selectedCount > 1) {
                // Multiple items: force percentage type and show locked indicator
                // What: Lock the dropdown and display the locked indicator
                // Why: Value-based thresholds don't work with multiple items (each has different price)
                // How: Disable select, show ðŸš« icon, hide any open tooltip
                thresholdTypeSelect.value = 'percentage';
                thresholdTypeSelect.disabled = true;
                if (lockedIndicator) lockedIndicator.style.display = 'inline-block';
            } else {
                // Single or no items: allow choice and hide locked indicator
                // What: Unlock the dropdown and hide the locked indicator
                // Why: Value-based thresholds are valid for single item monitoring
                // How: Enable select, hide ðŸš« icon and tooltip
                thresholdTypeSelect.disabled = false;
                if (lockedIndicator) lockedIndicator.style.display = 'none';
                if (lockedTooltip) lockedTooltip.style.display = 'none';
            }
        },
        
        /**
         * Shows/hides the locked indicator for threshold type based on "All Items" mode.
         * 
         * What: Manages the locked indicator visibility when switching to/from All Items
         * Why: All Items mode forces percentage type, so users need visual feedback
         * How: Shows indicator when isAllItems is true, hides when false (unless multiple items selected)
         * 
         * @param {boolean} isAllItems - Whether "All Items" mode is selected
         */
        updateThresholdTypeLockIndicator(isAllItems) {
            const lockedIndicator = document.getElementById('threshold-type-locked-indicator');
            const lockedTooltip = document.getElementById('threshold-type-locked-tooltip');
            
            if (isAllItems) {
                // All Items mode: show locked indicator
                if (lockedIndicator) lockedIndicator.style.display = 'inline-block';
            } else {
                // Specific Items mode: let updateThresholdTypeState handle visibility
                // (it will show indicator if multiple items are selected)
                if (lockedIndicator) lockedIndicator.style.display = 'none';
                if (lockedTooltip) lockedTooltip.style.display = 'none';
            }
        },

        /**
         * Updates form fields based on spread scope selection.
         * 
         * What: Shows/hides form fields based on spread scope (all, specific, multiple)
         * Why: Different scope options require different input fields
         * How:
         *   - "all": Show min/max price filters, hide item selectors
         *   - "specific": Show single item selector, hide min/max and multi-item
         *   - "multiple": Show multi-item selector, hide single item and min/max
         * 
         * @param {string} formType - 'create' for create form
         */
        handleSpreadScopeChange(formType) {
            const selectors = AlertsConfig.selectors[formType];
            const spreadScope = document.querySelector(selectors.spreadScope).value;
            const groups = selectors.groups;

            // itemNameGroup: Container for single item name input
            const itemNameGroup = document.querySelector(groups.itemName);
            // spreadItemsGroup: Container for multi-item selector
            const spreadItemsGroup = document.querySelector(groups.spreadItems);
            // minPriceGroup/maxPriceGroup: Price filter containers for "all items" mode
            const minPriceGroup = document.querySelector(groups.minPrice);
            const maxPriceGroup = document.querySelector(groups.maxPrice);
            // isAllItemsInput: Hidden field that tells the backend if this is an all-items alert
            const isAllItemsInput = document.querySelector(selectors.isAllItems);

            if (spreadScope === 'all') {
                // All Items mode: show price filters, hide item selectors
                itemNameGroup.style.display = 'none';
                if (spreadItemsGroup) spreadItemsGroup.style.display = 'none';
                minPriceGroup.style.display = 'block';
                maxPriceGroup.style.display = 'block';
                isAllItemsInput.value = 'true';
                // Clear the multi-item selector when switching away
                SpreadMultiItemSelector.clear();
                // Update tabindex values for All Items mode
                this.updateTabIndices('spread', true);
            } else if (spreadScope === 'multiple') {
                // Multiple Specific Items mode: show multi-item selector, hide single item and price filters
                itemNameGroup.style.display = 'none';
                if (spreadItemsGroup) spreadItemsGroup.style.display = 'block';
                minPriceGroup.style.display = 'none';
                maxPriceGroup.style.display = 'none';
                isAllItemsInput.value = 'false';
                // Update tabindex values for Specific Items mode
                this.updateTabIndices('spread', false);
            } else {
                // Single Specific Item mode: show single item input, hide multi-item and price filters
                itemNameGroup.style.display = 'block';
                if (spreadItemsGroup) spreadItemsGroup.style.display = 'none';
                minPriceGroup.style.display = 'none';
                maxPriceGroup.style.display = 'none';
                isAllItemsInput.value = 'false';
                // Clear the multi-item selector when switching away
                SpreadMultiItemSelector.clear();
                // Update tabindex values for Specific Items mode
                this.updateTabIndices('spread', false);
            }
        },

        /**
         * Updates form fields based on spike scope selection.
         * 
         * What: Controls visibility of spike alert form fields based on scope dropdown
         * Why: Spike alerts can monitor all items or specific item(s) - the multi-item selector handles both single and multiple items
         * How: Shows/hides appropriate fields and updates hidden is_all_items flag
         *
         * @param {string} formType - 'create' for create form
         */
        handleSpikeScopeChange(formType) {
            const selectors = AlertsConfig.selectors[formType];
            const spikeScopeSelect = document.querySelector(selectors.spikeScope);
            const groups = selectors.groups;
            
            // itemNameGroup: Container for single item name input (no longer used for spike alerts)
            const itemNameGroup = document.querySelector(groups.itemName);
            // spikeItemsGroup: Container for multi-item selector (handles both single and multiple items)
            const spikeItemsGroup = document.querySelector(groups.spikeItems);
            // minPriceGroup/maxPriceGroup: Price filter containers for "all items" mode
            const minPriceGroup = document.querySelector(groups.minPrice);
            const maxPriceGroup = document.querySelector(groups.maxPrice);
            // isAllItemsInput: Hidden field that tells the backend if this is an all-items alert
            const isAllItemsInput = document.querySelector(selectors.isAllItems);

            // selection: Current value of the spike scope dropdown
            // What: Get the selected scope option
            // Why: Determines which form fields to show/hide
            // How: Read value from dropdown, default to 'multiple' (specific items mode)
            const selection = spikeScopeSelect ? spikeScopeSelect.value : 'multiple';

            if (selection === 'all') {
                // All Items mode: show price filters, hide item selectors
                // What: Configure form for monitoring all items
                // Why: When tracking all items, users need price range filters instead of item selectors
                // How: Hide item inputs, show price filters, set is_all_items flag to true
                if (itemNameGroup) itemNameGroup.style.display = 'none';
                if (spikeItemsGroup) spikeItemsGroup.style.display = 'none';
                if (minPriceGroup) minPriceGroup.style.display = 'block';
                if (maxPriceGroup) maxPriceGroup.style.display = 'block';
                if (isAllItemsInput) isAllItemsInput.value = 'true';
                // Clear the multi-item selector when switching to all items mode
                if (typeof SpikeMultiItemSelector !== 'undefined') {
                    SpikeMultiItemSelector.clear();
                }
                // Update tabindex values for All Items mode
                this.updateTabIndices('spike', true);
            } else {
                // Specific Item(s) mode: show multi-item selector, hide price filters
                // What: Configure form for monitoring specific item(s)
                // Why: Multi-item selector handles both single and multiple item selection
                // How: Show multi-item selector, hide legacy single item input and price filters
                if (itemNameGroup) itemNameGroup.style.display = 'none';
                if (spikeItemsGroup) spikeItemsGroup.style.display = 'block';
                if (minPriceGroup) minPriceGroup.style.display = 'none';
                if (maxPriceGroup) maxPriceGroup.style.display = 'none';
                if (isAllItemsInput) isAllItemsInput.value = 'false';
                // Update tabindex values for Specific Items mode
                this.updateTabIndices('spike', false);
            }
        },

        /**
         * Updates form fields based on sustained move scope selection.
         */
        handleSustainedScopeChange(formType) {
            const selectors = AlertsConfig.selectors[formType];
            const sustainedScopeSelect = document.querySelector(selectors.sustainedScope);
            const groups = selectors.groups;
            const sustainedItemsGroup = document.querySelector(groups.sustainedItems);
            const minPriceGroup = document.querySelector(groups.minPrice);
            const maxPriceGroup = document.querySelector(groups.maxPrice);
            const isAllItemsInput = document.querySelector(selectors.isAllItems);

            const selection = sustainedScopeSelect ? sustainedScopeSelect.value : 'specific';
            const isAll = selection === 'all';

            if (sustainedItemsGroup) sustainedItemsGroup.style.display = isAll ? 'none' : 'block';
            if (minPriceGroup) minPriceGroup.style.display = isAll ? 'block' : 'none';
            if (maxPriceGroup) maxPriceGroup.style.display = isAll ? 'block' : 'none';
            if (isAllItemsInput) isAllItemsInput.value = isAll ? 'true' : 'false';
            
            // Update tabindex values based on scope
            // What: Adjust tab order to match visual layout
            // Why: "All Items" mode shows different fields than "Specific Items" mode
            // How: Call updateTabIndices with the appropriate scope flag
            this.updateTabIndices('sustained', isAll);
        }
    };


    // =============================================================================
    // MODAL MANAGEMENT
    // =============================================================================
    /**
     * Controls modal dialogs (spread details modal and spike details modal).
     * 
     * Why: Modals have common behavior that should be handled consistently.
     */
    const ModalManager = {
        /**
         * Opens spread details modal with matching items.
         */
        showSpreadDetails(alertId) {
            const dataStr = AlertsState.getSpreadData(alertId);

            if (!dataStr) {
                console.error('No spread data found for alert', alertId);
                return;
            }

            const data = JSON.parse(dataStr);
            const list = document.querySelector(AlertsConfig.selectors.spreadItemsList);
            list.innerHTML = AlertsUI.renderSpreadItemsList(data);

            document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'flex';
        },

        /**
         * Closes the spread details modal.
         */
        closeSpreadModal() {
            document.querySelector(AlertsConfig.selectors.spreadModal).style.display = 'none';
        },

        /**
         * Opens spike details modal with matching items.
         */
        showSpikeDetails(alertId) {
            const dataStr = AlertsState.getSpikeData(alertId);

            if (!dataStr) {
                console.error('No spike data found for alert', alertId);
                return;
            }

            let data = [];
            try {
                data = JSON.parse(dataStr);
            } catch (e) {
                console.error('Failed to parse spike data', e);
                return;
            }
            const list = document.getElementById('spike-items-list');
            if (list) {
                list.innerHTML = AlertsUI.renderSpikeItemsList(data);
            }

            document.getElementById('spike-modal').style.display = 'flex';
        },

        /**
         * Closes the spike details modal.
         */
        closeSpikeModal() {
            const modal = document.getElementById('spike-modal');
            if (modal) modal.style.display = 'none';
        }
    };


    // =============================================================================
    // ALERT ACTIONS
    // =============================================================================
    /**
     * Handles user actions on alerts (dismiss, delete, save).
     */
    const AlertActions = {
        /**
         * Handles selection from the actions dropdown.
         */
        handleAction(action) {
            if (action === 'delete') {
                this.confirmDelete();
            } else if (action === 'group') {
                GroupManager.open();
            }
        },

        /**
         * Dismisses a triggered alert notification.
         */
        async dismiss(alertId) {
            // Mark as dismissed in localStorage so it stays dismissed across refreshes
            AlertsState.dismissNotification(alertId);
            // Also remove from active notifications cache
            AlertsState.removeActiveNotification(alertId);
            
            // Animate out immediately for responsive feedback
            const banner = document.querySelector('.triggered-notification[data-alert-id="' + alertId + '"]');
            if (banner) {
                banner.classList.add('dismissing');
                setTimeout(() => banner.remove(), 300);
            }

            const line = document.querySelector('.status-notification .notification-line[data-kind="triggered"][data-alert-id="' + alertId + '"]');
            if (line) {
                const box = line.closest('.status-notification');
                line.remove();
                if (box) {
                    const hasLines = box.querySelector('.notification-line');
                    // If no lines remain (status or triggered), remove box.
                    if (!hasLines) {
                        box.classList.add('dismissing');
                        setTimeout(() => box.remove(), 300);
                    }
                }
            }

            await AlertsAPI.dismissAlert(alertId);
        },

        /**
         * Confirms deletion of selected alerts.
         * Opens the delete confirmation modal instead of browser confirm.
         */
        confirmDelete() {
            const selectedItems = [];
            const selectedIds = [];

            document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
                const alertItem = cb.closest('.alert-item');
                if (alertItem) {
                    selectedItems.push(alertItem);
                    selectedIds.push(alertItem.dataset.alertId);
                }
            });

            if (selectedIds.length === 0) {
                AlertActions.showErrorNotification('Please select at least one alert to delete.');
                return;
            }

            // Store selected items and IDs for later use
            this.pendingDeleteItems = selectedItems;
            this.pendingDeleteIds = selectedIds;

            // Update modal message
            const message = document.getElementById('delete-confirm-message');
            if (message) {
                const count = selectedIds.length;
                message.textContent = 'Are you sure you want to delete ' + count + ' selected alert' + (count > 1 ? 's' : '') + '?';
            }

            // Show modal
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        },

        /**
         * Executes the delete after modal confirmation.
         */
        async executeDelete() {
            const selectedItems = this.pendingDeleteItems || [];
            const selectedIds = this.pendingDeleteIds || [];

            if (selectedIds.length === 0) {
                closeDeleteConfirmModal();
                return;
            }

            // Close modal first
            closeDeleteConfirmModal();

            // Animate items out
            selectedItems.forEach(item => {
                item.classList.add('deleting');
            });

            // Wait for animation to complete (300ms matches CSS transition)
            await new Promise(resolve => setTimeout(resolve, 300));

            // Call API to delete
            const success = await AlertsAPI.deleteAlerts(selectedIds);
            if (success) {
                this.clearSelections();
                // Show status notification
                this.showStatusNotification('Alert' + (selectedIds.length > 1 ? 's' : '') + ' deleted');
                await AlertsRefresh.refresh();
            } else {
                selectedItems.forEach(item => item.classList.remove('deleting'));
            }

            // Clear pending state
            this.pendingDeleteItems = null;
            this.pendingDeleteIds = null;
        },

        /**
         * Clears any selected checkboxes.
         */
        clearSelections() {
            document.querySelectorAll('.alert-checkbox').forEach(cb => cb.checked = false);
        },

        /**
         * Shows a status notification at the top of the alerts pane.
         * 
         * What: Creates and displays a dismissible status message
         * Why: Provides user feedback for actions like delete
         * How: Inserts notification HTML into triggered-notifications container
         */
        clearStatusNotifications() {
            const container = document.getElementById('triggered-notifications');
            if (!container) return;

            container.querySelectorAll('.status-notification').forEach(box => {
                // Remove only status lines; keep triggered lines.
                box.querySelectorAll('.notification-line[data-kind="status"]').forEach(l => l.remove());

                // Remove legacy plain text (server messages) and <br> (treat as status).
                Array.from(box.childNodes).forEach(node => {
                    if (node.nodeType === 3 && node.textContent.trim()) node.remove();
                    if (node.nodeType === 1 && node.tagName === 'BR') node.remove();
                });

                const hasTriggered = box.querySelector('.notification-line[data-kind="triggered"]');
                if (!hasTriggered) {
                    box.remove();
                }
            });
        },

        normalizeStatusNotifications() {
            const container = document.getElementById('triggered-notifications');
            if (!container) return;

            const existingAll = container.querySelectorAll('.status-notification');
            if (existingAll.length === 0) return;

            const toStatusLine = (box, message) => {
                const btn = box.querySelector('.dismiss-btn');
                const line = document.createElement('div');
                line.className = 'notification-line';
                line.dataset.kind = 'status';
                const span = document.createElement('span');
                span.textContent = message;
                line.appendChild(span);
                if (btn) box.insertBefore(line, btn);
                else box.appendChild(line);
            };

            // Convert any legacy plain-text status messages into status lines.
            existingAll.forEach(box => {
                const plainText = Array.from(box.childNodes)
                    .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn')))
                    .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('notification-line')))
                    .filter(node => node.nodeType === 3 || (node.nodeType === 1 && node.tagName === 'BR'))
                    .map(node => (node.textContent || '').trim())
                    .filter(Boolean)
                    .join(' ');

                // Remove those legacy nodes.
                Array.from(box.childNodes).forEach(node => {
                    const isBtn = node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn');
                    const isLine = node.nodeType === 1 && node.classList && node.classList.contains('notification-line');
                    if (isBtn || isLine) return;
                    if (node.nodeType === 3 || (node.nodeType === 1 && node.tagName === 'BR')) {
                        node.remove();
                    }
                });

                if (plainText) {
                    toStatusLine(box, plainText);
                }
            });

            if (existingAll.length <= 1) return;

            const first = existingAll[0];
            const firstBtn = first.querySelector('.dismiss-btn');

            for (let i = 1; i < existingAll.length; i++) {
                const n = existingAll[i];
                // Move status lines into the first box.
                n.querySelectorAll('.notification-line[data-kind="status"]').forEach(line => {
                    if (firstBtn) first.insertBefore(line.cloneNode(true), firstBtn);
                    else first.appendChild(line.cloneNode(true));
                });
                n.remove();
            }
        },

        mergeTriggeredNotificationsIntoStatus() {
            const container = document.getElementById('triggered-notifications');
            if (!container) return;

            this.normalizeStatusNotifications();

            const triggered = Array.from(container.querySelectorAll('.triggered-notification:not(.status-notification)'));
            if (triggered.length === 0) return;

            let statusBox = container.querySelector('.status-notification');
            if (!statusBox) {
                statusBox = document.createElement('div');
                statusBox.className = 'triggered-notification status-notification';

                const btn = document.createElement('button');
                btn.className = 'dismiss-btn';
                btn.innerHTML = '&times;';
                btn.setAttribute('onclick', 'dismissStatusNotification(this)');
                statusBox.appendChild(btn);

                container.insertBefore(statusBox, container.firstChild);
            }

            const globalBtn = statusBox.querySelector('.dismiss-btn');

            triggered.forEach(n => {
                const alertId = n.dataset.alertId;
                const span = n.querySelector('span');

                const line = document.createElement('div');
                line.className = 'notification-line';
                line.dataset.kind = 'triggered';
                if (alertId) line.dataset.alertId = alertId;

                if (span) {
                    line.appendChild(span.cloneNode(true));
                } else {
                    const msg = Array.from(n.childNodes)
                        .filter(node => !(node.nodeType === 1 && node.classList && node.classList.contains('dismiss-btn')))
                        .map(node => (node.textContent || '').trim())
                        .filter(Boolean)
                        .join(' ');
                    const s = document.createElement('span');
                    s.textContent = msg;
                    line.appendChild(s);
                }


                if (globalBtn) statusBox.insertBefore(line, globalBtn);
                else statusBox.appendChild(line);

                n.remove();
            });
        },

        showStatusNotification(message) {
            const container = document.getElementById('triggered-notifications');
            if (!container) return;

            this.normalizeStatusNotifications();

            let statusBox = container.querySelector('.status-notification');
            if (!statusBox) {
                statusBox = document.createElement('div');
                statusBox.className = 'triggered-notification status-notification';

                const btn = document.createElement('button');
                btn.className = 'dismiss-btn';
                btn.innerHTML = '&times;';
                btn.setAttribute('onclick', 'dismissStatusNotification(this)');
                statusBox.appendChild(btn);

                container.insertBefore(statusBox, container.firstChild);
            }

            const globalBtn = statusBox.querySelector('.dismiss-btn');

            const line = document.createElement('div');
            line.className = 'notification-line';
            line.dataset.kind = 'status';
            const span = document.createElement('span');
            span.textContent = message;
            line.appendChild(span);

            if (globalBtn) statusBox.insertBefore(line, globalBtn);
            else statusBox.appendChild(line);

            // Keep triggered + status in one visible box.
            this.mergeTriggeredNotificationsIntoStatus();
        },

        /**
         * Shows an error notification above the actions area.
         * @param {string} message - The error message to display
         */
        showErrorNotification(message) {
            const actionsWrapper = document.querySelector('.alert-actions-wrapper');
            if (!actionsWrapper) return;

            // Pause refresh while error notification is shown
            AlertsRefresh.errorNotificationActive = true;

            // Find or create error container above actions
            let errorContainer = actionsWrapper.querySelector('.actions-error-container');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.className = 'actions-error-container';
                actionsWrapper.insertBefore(errorContainer, actionsWrapper.firstChild);
            }

            // Remove any existing error notifications
            errorContainer.querySelectorAll('.triggered-notification.error-notification').forEach(n => n.remove());

            // Create error notification
            const notification = document.createElement('div');
            notification.className = 'triggered-notification error-notification';
            notification.innerHTML = message + '<button class="dismiss-btn" type="button">&times;</button>';

            // Function to clear error state
            const clearErrorState = () => {
                AlertsRefresh.errorNotificationActive = false;
            };

            // Add click handler for dismiss button
            const dismissBtn = notification.querySelector('.dismiss-btn');
            if (dismissBtn) {
                dismissBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    notification.classList.add('dismissing');
                    setTimeout(() => {
                        notification.remove();
                        clearErrorState();
                    }, 300);
                });
            }

            errorContainer.appendChild(notification);

            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('dismissing');
                    setTimeout(() => {
                        notification.remove();
                        clearErrorState();
                    }, 300);
                }
            }, 5000);
        }
    };


    // =============================================================================
    // GROUP MANAGEMENT
    // =============================================================================
    /**
     * Handles organizing alerts into groups.
     */
    const GroupManager = {
        escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        },

        open() {
            const selectedIds = this.getSelectedAlertIds();
            if (selectedIds.length === 0) {
                AlertActions.showErrorNotification('Please select at least one alert first.');
                return;
            }

            this.renderExistingGroups();
            this.clearNewGroupInput();
            const modal = document.querySelector(AlertsConfig.selectors.groupModal);
            if (modal) {
                modal.style.display = 'flex';
            }
        },

        close() {
            const modal = document.querySelector(AlertsConfig.selectors.groupModal);
            if (modal) {
                modal.style.display = 'none';
            }
        },

        clearNewGroupInput() {
            const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
            if (input) input.value = '';
        },

        renderExistingGroups() {
            const list = document.querySelector(AlertsConfig.selectors.groupList);
            if (!list) return;

            const groups = AlertsState.getAlertGroups();
            if (!groups || groups.length === 0) {
                list.innerHTML = '<p class="no-alerts">No groups yet. Add a new one below.</p>';
                return;
            }

            list.innerHTML = '';
            groups.forEach(name => {
                const pill = document.createElement('span');
                pill.className = 'group-pill';
                pill.dataset.group = name;
                pill.textContent = name;
                pill.onclick = function () {
                    this.classList.toggle('selected');
                };
                list.appendChild(pill);
            });
        },

        getSelectedAlertIds() {
            const ids = [];
            document.querySelectorAll('.alert-checkbox:checked').forEach(cb => {
                const item = cb.closest('.alert-item');
                if (item && item.dataset.alertId) {
                    ids.push(item.dataset.alertId);
                }
            });
            return ids;
        },

        parseNewGroups() {
            const input = document.querySelector(AlertsConfig.selectors.newGroupInput);
            if (!input || !input.value.trim()) return [];
            return input.value.split(',')
                .map(g => g.trim())
                .filter(g => g.length > 0);
        },

        getSelectedGroups() {
            const selected = [];
            document.querySelectorAll(AlertsConfig.selectors.groupList + ' .group-pill.selected')
                .forEach(pill => selected.push(pill.dataset.group));
            return selected;
        },

        async save() {
            const alertIds = this.getSelectedAlertIds();
            if (alertIds.length === 0) {
                AlertActions.showErrorNotification('Please select at least one alert first.');
                return;
            }

            const existingGroups = this.getSelectedGroups();
            const newGroups = this.parseNewGroups();

            if (existingGroups.length === 0 && newGroups.length === 0) {
                AlertActions.showErrorNotification('Please choose an existing group or add a new one.');
                return;
            }

            const success = await AlertsAPI.groupAlerts(alertIds, existingGroups, newGroups);
            if (success) {
                AlertActions.showStatusNotification('Alert' + (alertIds.length > 1 ? 's' : '') + ' organized into group(s)');
                this.close();
                AlertActions.clearSelections();
                await AlertsRefresh.refresh();
            }
        },

        async deleteSelectedGroups() {
            const selectedGroups = this.getSelectedGroups();
            if (selectedGroups.length === 0) {
                AlertActions.showErrorNotification('Please select at least one group to delete.');
                return;
            }

            const confirmed = window.confirm('Delete selected group' + (selectedGroups.length > 1 ? 's' : '') + '? This will remove them from all alerts.');
            if (!confirmed) return;

            const success = await AlertsAPI.deleteGroups(selectedGroups);
            if (success) {
                AlertActions.showStatusNotification('Group' + (selectedGroups.length > 1 ? 's' : '') + ' deleted');
                // Optimistically remove from local state to reflect immediately
                const remaining = AlertsState.getAlertGroups().filter(g => !selectedGroups.includes(g));
                AlertsState.setAlertGroups(remaining);
                await AlertsRefresh.refresh();
                this.renderExistingGroups();
            } else {
                AlertActions.showErrorNotification('Failed to delete selected group(s). Please try again.');
            }
        }
    };


    // =============================================================================
    // AUTOCOMPLETE MANAGEMENT
    // =============================================================================
    /**
     * Manages item search autocomplete functionality.
     * 
     * Why: Both create and edit forms need autocomplete. This manager provides
     * reusable autocomplete logic for any item name input.
     */
    const AutocompleteManager = {
        /**
         * Tracks the currently selected suggestion index for each dropdown.
         * Keys are dropdown element IDs, values are the selected index (-1 = none).
         */
        selectedIndex: {},

        /**
         * Sets up autocomplete for an input/dropdown pair with full keyboard support.
         * 
         * What: Enables item search with suggestions dropdown
         * Why: Users need to find items by name, and keyboard navigation improves UX
         * How: Listens for input changes to fetch suggestions, and keydown events
         *      for arrow key navigation, Enter to select, and Escape to close
         * 
         * @param {HTMLElement} input - The text input element
         * @param {HTMLElement} hiddenInput - Hidden input to store selected item ID
         * @param {HTMLElement} dropdown - The suggestions dropdown container
         */
        setup(input, hiddenInput, dropdown) {
            if (!input || !dropdown) return;

            const dropdownId = dropdown.id;
            this.selectedIndex[dropdownId] = -1;

            /**
             * Updates visual highlighting of the currently selected suggestion.
             * Adds 'selected' class to the active item and scrolls it into view.
             */
            const updateSelection = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (index === this.selectedIndex[dropdownId]) {
                        item.classList.add('selected');
                        item.scrollIntoView({block: 'nearest'});
                    } else {
                        item.classList.remove('selected');
                    }
                });
            };

            /**
             * Selects the currently highlighted suggestion.
             * Sets the input value and hidden ID, then closes the dropdown.
             */
            const selectCurrentItem = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                const index = this.selectedIndex[dropdownId];

                if (index >= 0 && index < items.length) {
                    const selectedItem = items[index];
                    input.value = selectedItem.dataset.name;
                    hiddenInput.value = selectedItem.dataset.id;
                    dropdown.style.display = 'none';
                    this.selectedIndex[dropdownId] = -1;
                }
            };

            /**
             * Resets the selection index when new suggestions are loaded.
             */
            const resetSelection = () => {
                this.selectedIndex[dropdownId] = -1;
            };

            // Handle input changes - fetch suggestions
            input.addEventListener('input', async () => {
                const query = input.value;

                if (query.length < AlertsConfig.timing.minSearchLength) {
                    dropdown.style.display = 'none';
                    resetSelection();
                    return;
                }

                const items = await AlertsAPI.searchItems(query);

                if (items.length > 0) {
                    dropdown.innerHTML = AlertsUI.renderSuggestions(items);
                    dropdown.style.display = 'block';
                    resetSelection();
                } else {
                    dropdown.style.display = 'none';
                    resetSelection();
                }
            });

            // Handle keyboard navigation
            input.addEventListener('keydown', (e) => {
                // Only handle keys when dropdown is visible
                if (dropdown.style.display === 'none') return;

                const items = dropdown.querySelectorAll('.suggestion-item');
                if (items.length === 0) return;

                switch (e.key) {
                    case 'ArrowDown':
                        // Move selection down, wrap to top if at bottom
                        e.preventDefault();
                        this.selectedIndex[dropdownId] =
                            (this.selectedIndex[dropdownId] + 1) % items.length;
                        updateSelection();
                        break;

                    case 'ArrowUp':
                        // Move selection up, wrap to bottom if at top
                        e.preventDefault();
                        this.selectedIndex[dropdownId] =
                            this.selectedIndex[dropdownId] <= 0
                                ? items.length - 1
                                : this.selectedIndex[dropdownId] - 1;
                        updateSelection();
                        break;

                    case 'Tab':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Shift+Tab moves selection up like ArrowUp
                            this.selectedIndex[dropdownId] =
                                this.selectedIndex[dropdownId] <= 0
                                    ? items.length - 1
                                    : this.selectedIndex[dropdownId] - 1;
                        } else {
                            // Tab moves selection down like ArrowDown
                            this.selectedIndex[dropdownId] =
                                (this.selectedIndex[dropdownId] + 1) % items.length;
                        }
                        updateSelection();
                        break;

                    case 'Enter':
                        // Enter selects current item
                        if (this.selectedIndex[dropdownId] >= 0) {
                            e.preventDefault();
                            selectCurrentItem();
                        }
                        break;

                    case 'Escape':
                        // Escape closes dropdown without selecting
                        e.preventDefault();
                        dropdown.style.display = 'none';
                        resetSelection();
                        break;
                }
            });

            // Handle mouse click on suggestion
            dropdown.addEventListener('click', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    input.value = e.target.dataset.name;
                    hiddenInput.value = e.target.dataset.id;
                    dropdown.style.display = 'none';
                    resetSelection();
                }
            });

            // Handle mouse hover to update selection
            dropdown.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    const items = dropdown.querySelectorAll('.suggestion-item');
                    items.forEach((item, index) => {
                        if (item === e.target) {
                            this.selectedIndex[dropdownId] = index;
                        }
                    });
                    updateSelection();
                }
            });
        },

        /**
         * Initializes autocomplete for both forms.
         */
        init() {
            // Create form autocomplete
            const createSelectors = AlertsConfig.selectors.create;
            this.setup(
                document.querySelector(createSelectors.itemName),
                document.querySelector(createSelectors.itemId),
                document.querySelector(createSelectors.suggestions)
            );
        }
    };


    // =============================================================================
    // MULTI-ITEM SELECTOR
    // =============================================================================
    /**
     * Manages multi-item selection for sustained move alerts.
     * 
     * What: Allows users to select multiple specific items to monitor for sustained price moves
     * Why: Users may want to monitor sustained moves on a curated list of items
     * How: Uses box-style input with dropdown toggle showing selected items - matches alert_detail.html
     * 
     * This implementation mirrors the styling and behavior from alert_detail.html's MultiItemEditor
     * for visual consistency across the application.
     */
    const MultiItemSelector = {
        // selectedItems: Array of {id, name} objects representing currently selected items
        selectedItems: [],
        // selectedIndex: Index of currently highlighted suggestion in dropdown (-1 = none)
        selectedIndex: -1,
        // notificationTimeout: Reference to timeout for auto-hiding notifications
        notificationTimeout: null,
        // dropdownOpen: Tracks if the selected items dropdown is currently open
        dropdownOpen: false,

        /**
         * Initializes the multi-item selector for sustained move alerts.
         * 
         * What: Sets up event listeners for the sustained item search input and dropdown toggle
         * Why: Enables autocomplete functionality, dropdown management, and item removal
         * How: Attaches input, keydown, click handlers to relevant DOM elements
         */
        init() {
            // Get all DOM elements needed for the multi-item selector
            // input: Text input where user types to search for items to add
            const input = document.querySelector(AlertsConfig.selectors.create.sustainedItemInput);
            // dropdown: Container showing autocomplete suggestions when typing
            const dropdown = document.querySelector(AlertsConfig.selectors.create.sustainedItemSuggestions);
            // hiddenInput: Hidden field that stores comma-separated item IDs for form submission
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.sustainedItemIds);
            // selectedDropdown: Container showing list of already selected items
            const selectedDropdown = document.querySelector(AlertsConfig.selectors.create.sustainedSelectedItemsDropdown);
            // selectedList: Inner container where selected item rows are rendered
            const selectedList = document.querySelector(AlertsConfig.selectors.create.sustainedSelectedItemsList);
            // noItemsMsg: Message shown when no items are selected
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.sustainedNoItemsMessage);
            // toggleBtn: Button with chevron arrow to show/hide selected items dropdown
            const toggleBtn = document.querySelector(AlertsConfig.selectors.create.sustainedMultiItemToggle);
            // selectorBox: The main container box for the selector (for click-outside handling)
            const selectorBox = input ? input.closest('.multi-item-selector-box') : null;

            if (!input || !dropdown || !hiddenInput || !selectedDropdown) return;

            // Reference to 'this' for use inside closures
            const self = this;
            this.selectedItems = [];
            this.selectedIndex = -1;
            this.dropdownOpen = false;

            /**
             * Updates the hidden input with current selected item IDs.
             * Called whenever items are added or removed to keep form data in sync.
             */
            const updateHiddenInput = () => {
                hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
            };

            /**
             * Updates visual selection state in autocomplete dropdown.
             * Highlights the currently selected suggestion item.
             */
            const updateSelection = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (index === this.selectedIndex) {
                        item.classList.add('selected');
                        item.scrollIntoView({block: 'nearest'});
                    } else {
                        item.classList.remove('selected');
                    }
                });
            };

            /**
             * Adds an item to the selected list.
             * 
             * What: Adds item to selectedItems array and updates UI
             * Why: Central function for adding items from autocomplete or manual entry
             * How: Checks for duplicates, adds to array, updates hidden input and renders list
             * 
             * @param {string} id - The item's unique identifier
             * @param {string} name - The item's display name
             */
            const addItem = (id, name) => {
                // =============================================================================
                // CHECK FOR DUPLICATE ITEMS BEFORE ADDING
                // =============================================================================
                // What: Prevents the same item from being added multiple times to the selection
                // Why: Users shouldn't be able to add duplicate items - this would cause confusion
                //      and potentially duplicate alert notifications for the same item
                // How: Compares IDs using String() conversion to handle type mismatches
                //      (API returns numbers, DOM stores strings from dataset attributes)
                if (this.selectedItems.some(item => String(item.id) === String(id))) {
                    this.showNotification(`${name} is already selected`, 'error');
                    return;
                }

                this.selectedItems.push({id, name});
                updateHiddenInput();
                this.renderSelectedItems();
                input.value = '';
                dropdown.style.display = 'none';
                this.selectedIndex = -1;

                // Show success notification
                this.showNotification(`${name} added`, 'success');
            };

            /**
             * Removes an item from the selected list.
             * 
             * What: Removes item from selectedItems array and updates UI
             * Why: Called when user clicks the red X button on an item
             * 
             * @param {string} id - The item's unique identifier to remove
             */
            const removeItem = (id) => {
                const itemToRemove = this.selectedItems.find(item => String(item.id) === String(id));
                const itemName = itemToRemove ? itemToRemove.name : 'Item';
                this.selectedItems = this.selectedItems.filter(item => String(item.id) !== String(id));
                updateHiddenInput();
                this.renderSelectedItems();

                // Show removal notification
                this.showNotification(`${itemName} removed`, 'success');
            };

            // Handle remove button clicks in selected items dropdown (event delegation)
            if (selectedList) {
                selectedList.addEventListener('click', function(e) {
                    if (e.target.classList.contains('remove-item-btn')) {
                        e.preventDefault();
                        e.stopPropagation();
                        const itemId = e.target.dataset.id;
                        removeItem(itemId);
                    }
                });
            }

            // Handle dropdown toggle button clicks
            if (toggleBtn) {
                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close autocomplete suggestions if open
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    
                    // Toggle selected items dropdown
                    this.dropdownOpen = !this.dropdownOpen;
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.add('show');
                        toggleBtn.classList.add('active');
                    } else {
                        selectedDropdown.classList.remove('show');
                        toggleBtn.classList.remove('active');
                    }
                });
            }

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (selectorBox && !selectorBox.contains(e.target)) {
                    // Close selected items dropdown
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.remove('show');
                        if (toggleBtn) toggleBtn.classList.remove('active');
                        this.dropdownOpen = false;
                    }
                    // Close autocomplete suggestions
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle input changes - fetch suggestions
            input.addEventListener('input', async () => {
                const query = input.value;

                // Close selected items dropdown when user starts typing
                if (this.dropdownOpen) {
                    selectedDropdown.classList.remove('show');
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    this.dropdownOpen = false;
                }

                if (query.length < AlertsConfig.timing.minSearchLength) {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    return;
                }

                const items = await AlertsAPI.searchItems(query);

                // =============================================================================
                // FILTER OUT ALREADY SELECTED ITEMS FROM SUGGESTIONS
                // =============================================================================
                // What: Removes items that are already in the selectedItems array from the suggestions
                // Why: Once a user has added an item to be tracked, it shouldn't appear in the
                //      dropdown suggestions anymore - this prevents confusion and duplicate selection attempts
                // How: Uses Array.filter() to keep only items whose ID is not found in selectedItems.
                //      String conversion ensures type-safe comparison (API may return number, DOM stores string)
                const filteredItems = items.filter(item =>
                    !this.selectedItems.some(selected => String(selected.id) === String(item.id))
                );

                if (filteredItems.length > 0) {
                    dropdown.innerHTML = AlertsUI.renderSuggestions(filteredItems);
                    dropdown.style.display = 'block';
                    this.selectedIndex = -1;
                } else {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle keyboard navigation in dropdown
            input.addEventListener('keydown', (e) => {
                if (dropdown.style.display === 'none') {
                    // Backspace with empty input removes last item
                    if (e.key === 'Backspace' && input.value === '' && this.selectedItems.length > 0) {
                        const lastItem = this.selectedItems[this.selectedItems.length - 1];
                        removeItem(lastItem.id);
                    }
                    return;
                }

                const items = dropdown.querySelectorAll('.suggestion-item');
                if (items.length === 0) return;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        updateSelection();
                        break;

                    case 'ArrowUp':
                        e.preventDefault();
                        this.selectedIndex = this.selectedIndex <= 0
                            ? items.length - 1
                            : this.selectedIndex - 1;
                        updateSelection();
                        break;

                    case 'Tab':
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.selectedIndex = this.selectedIndex <= 0
                                ? items.length - 1
                                : this.selectedIndex - 1;
                        } else {
                            this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        }
                        updateSelection();
                        break;

                    case 'Enter':
                        if (this.selectedIndex >= 0) {
                            e.preventDefault();
                            const selectedItem = items[this.selectedIndex];
                            addItem(selectedItem.dataset.id, selectedItem.dataset.name);
                        }
                        break;

                    case 'Escape':
                        e.preventDefault();
                        dropdown.style.display = 'none';
                        this.selectedIndex = -1;
                        break;
                }
            });

            // Handle mouse click on suggestion
            dropdown.addEventListener('click', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    addItem(e.target.dataset.id, e.target.dataset.name);
                }
            });

            // Handle mouse hover to update selection
            dropdown.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    const items = dropdown.querySelectorAll('.suggestion-item');
                    items.forEach((item, index) => {
                        if (item === e.target) {
                            this.selectedIndex = index;
                        }
                    });
                    updateSelection();
                }
            });
        },

        /**
         * Renders the selected items in the dropdown list.
         * Shows each item with its name and a red X remove button - matching alert_detail.html styling.
         * 
         * What: Updates the DOM to display all currently selected items
         * Why: Provides visual feedback of selected items with ability to remove
         * How: Generates HTML rows for each item with remove button
         */
        renderSelectedItems() {
            const selectedList = document.querySelector(AlertsConfig.selectors.create.sustainedSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.sustainedNoItemsMessage);

            if (!selectedList) return;

            if (this.selectedItems.length === 0) {
                selectedList.innerHTML = '';
                if (noItemsMsg) noItemsMsg.classList.add('show');
            } else {
                if (noItemsMsg) noItemsMsg.classList.remove('show');
                selectedList.innerHTML = this.selectedItems.map(item =>
                    `<div class="selected-item-row">
                        <span class="item-name">${item.name}</span>
                        <button type="button" class="remove-item-btn" data-id="${item.id}" title="Remove ${item.name}">Ã—</button>
                    </div>`
                ).join('');
            }
        },

        /**
         * Shows a small notification next to the "Items" label.
         * 
         * What: Displays success/error feedback for item add/remove operations
         * Why: Provides immediate visual feedback without disruptive popups
         * How: Updates the notification span with text and appropriate class, auto-hides after delay
         * 
         * @param {string} message - The notification message to display
         * @param {string} type - 'success' for green (item added/removed) or 'error' for red (duplicate)
         */
        showNotification(message, type) {
            const notification = document.querySelector(AlertsConfig.selectors.create.sustainedItemNotification);
            if (!notification) return;

            // Clear any existing timeout to prevent overlapping notifications
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout);
            }

            // Set the message and styling
            notification.textContent = message;
            notification.className = 'item-notification ' + type + ' show';

            // Auto-hide after 2.5 seconds
            this.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, 2500);
        },

        /**
         * Clears all selected items.
         * 
         * What: Removes all items from the selection
         * Why: Called when switching scope mode or after form submission
         * How: Empties the array and clears DOM elements
         */
        clear() {
            this.selectedItems = [];
            const selectedList = document.querySelector(AlertsConfig.selectors.create.sustainedSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.sustainedNoItemsMessage);
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.sustainedItemIds);
            
            if (selectedList) selectedList.innerHTML = '';
            if (noItemsMsg) noItemsMsg.classList.add('show');
            if (hiddenInput) hiddenInput.value = '';
        },

        /**
         * Gets the selected item IDs.
         */
        getSelectedIds() {
            return this.selectedItems.map(item => item.id);
        }
    };


    // =============================================================================
    // SPREAD MULTI-ITEM SELECTOR
    // =============================================================================
    /**
     * Manages multi-item selection for spread alerts with "Specific Item(s)" option.
     * 
     * What: Allows users to select multiple specific items to monitor for spread threshold
     * Why: Users may want to monitor spread on a curated list of items instead of all or just one
     * How: Uses box-style input with dropdown toggle showing selected items - matches alert_detail.html
     * 
     * This implementation mirrors the styling and behavior from alert_detail.html's MultiItemEditor
     * for visual consistency across the application.
     */
    const SpreadMultiItemSelector = {
        // selectedItems: Array of {id, name} objects representing currently selected items
        selectedItems: [],
        // selectedIndex: Index of currently highlighted suggestion in dropdown (-1 = none)
        selectedIndex: -1,
        // notificationTimeout: Reference to timeout for auto-hiding notifications
        notificationTimeout: null,
        // dropdownOpen: Tracks if the selected items dropdown is currently open
        dropdownOpen: false,

        /**
         * Initializes the spread multi-item selector.
         * 
         * What: Sets up event listeners for the spread item search input and dropdown toggle
         * Why: Enables autocomplete functionality, dropdown management, and item removal
         * How: Attaches input, keydown, click handlers to relevant DOM elements
         */
        init() {
            // Get all DOM elements needed for the multi-item selector
            // input: Text input where user types to search for items to add
            const input = document.querySelector(AlertsConfig.selectors.create.spreadItemInput);
            // dropdown: Container showing autocomplete suggestions when typing
            const dropdown = document.querySelector(AlertsConfig.selectors.create.spreadItemSuggestions);
            // hiddenInput: Hidden field that stores comma-separated item IDs for form submission
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.spreadItemIds);
            // selectedDropdown: Container showing list of already selected items
            const selectedDropdown = document.querySelector(AlertsConfig.selectors.create.spreadSelectedItemsDropdown);
            // selectedList: Inner container where selected item rows are rendered
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spreadSelectedItemsList);
            // noItemsMsg: Message shown when no items are selected
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spreadNoItemsMessage);
            // toggleBtn: Button with chevron arrow to show/hide selected items dropdown
            const toggleBtn = document.querySelector(AlertsConfig.selectors.create.spreadMultiItemToggle);
            // selectorBox: The main container box for the selector (for click-outside handling)
            const selectorBox = input ? input.closest('.multi-item-selector-box') : null;

            if (!input || !dropdown || !hiddenInput || !selectedDropdown) return;

            // Reference to 'this' for use inside closures
            const self = this;
            this.selectedItems = [];
            this.selectedIndex = -1;
            this.dropdownOpen = false;

            /**
             * Updates the hidden input with current selected item IDs.
             * Called whenever items are added or removed to keep form data in sync.
             */
            const updateHiddenInput = () => {
                hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
            };

            /**
             * Updates visual selection state in autocomplete dropdown.
             * Highlights the currently selected suggestion item.
             */
            const updateSelection = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (index === this.selectedIndex) {
                        item.classList.add('selected');
                        item.scrollIntoView({block: 'nearest'});
                    } else {
                        item.classList.remove('selected');
                    }
                });
            };

            /**
             * Adds an item to the selected list.
             * 
             * What: Adds item to selectedItems array and updates UI
             * Why: Central function for adding items from autocomplete or manual entry
             * How: Checks for duplicates, adds to array, updates hidden input and renders list
             * 
             * @param {string} id - The item's unique identifier
             * @param {string} name - The item's display name
             */
            const addItem = (id, name) => {
                // =============================================================================
                // CHECK FOR DUPLICATE ITEMS BEFORE ADDING
                // =============================================================================
                // What: Prevents the same item from being added multiple times to the selection
                // Why: Users shouldn't be able to add duplicate items - this would cause confusion
                //      and potentially duplicate alert notifications for the same item
                // How: Compares IDs using String() conversion to handle type mismatches
                //      (API returns numbers, DOM stores strings from dataset attributes)
                if (this.selectedItems.some(item => String(item.id) === String(id))) {
                    this.showNotification(`${name} is already selected`, 'error');
                    return;
                }

                this.selectedItems.push({id, name});
                updateHiddenInput();
                this.renderSelectedItems();
                input.value = '';
                dropdown.style.display = 'none';
                this.selectedIndex = -1;

                // Show success notification
                this.showNotification(`${name} added`, 'success');
            };

            /**
             * Removes an item from the selected list.
             * 
             * What: Removes item from selectedItems array and updates UI
             * Why: Called when user clicks the red X button on an item
             * 
             * @param {string} id - The item's unique identifier to remove
             */
            const removeItem = (id) => {
                const itemToRemove = this.selectedItems.find(item => String(item.id) === String(id));
                const itemName = itemToRemove ? itemToRemove.name : 'Item';
                this.selectedItems = this.selectedItems.filter(item => String(item.id) !== String(id));
                updateHiddenInput();
                this.renderSelectedItems();

                // Show removal notification
                this.showNotification(`${itemName} removed`, 'success');
            };

            // Handle remove button clicks in selected items dropdown (event delegation)
            if (selectedList) {
                selectedList.addEventListener('click', function(e) {
                    if (e.target.classList.contains('remove-item-btn')) {
                        e.preventDefault();
                        e.stopPropagation();
                        const itemId = e.target.dataset.id;
                        removeItem(itemId);
                    }
                });
            }

            // Handle dropdown toggle button clicks
            if (toggleBtn) {
                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close autocomplete suggestions if open
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    
                    // Toggle selected items dropdown
                    this.dropdownOpen = !this.dropdownOpen;
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.add('show');
                        toggleBtn.classList.add('active');
                    } else {
                        selectedDropdown.classList.remove('show');
                        toggleBtn.classList.remove('active');
                    }
                });
            }

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (selectorBox && !selectorBox.contains(e.target)) {
                    // Close selected items dropdown
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.remove('show');
                        if (toggleBtn) toggleBtn.classList.remove('active');
                        this.dropdownOpen = false;
                    }
                    // Close autocomplete suggestions
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle input changes - fetch suggestions from API
            input.addEventListener('input', async () => {
                const query = input.value;

                // Close selected items dropdown when user starts typing
                if (this.dropdownOpen) {
                    selectedDropdown.classList.remove('show');
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    this.dropdownOpen = false;
                }

                // minSearchLength: Minimum characters before searching (prevents API spam)
                if (query.length < AlertsConfig.timing.minSearchLength) {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    return;
                }

                // Fetch matching items from API
                const items = await AlertsAPI.searchItems(query);

                // =============================================================================
                // FILTER OUT ALREADY SELECTED ITEMS FROM SUGGESTIONS
                // =============================================================================
                // What: Removes items that are already in the selectedItems array from the suggestions
                // Why: Once a user has added an item to be tracked, it shouldn't appear in the
                //      dropdown suggestions anymore - this prevents confusion and duplicate selection attempts
                // How: Uses Array.filter() to keep only items whose ID is not found in selectedItems.
                //      String conversion ensures type-safe comparison (API returns number IDs, DOM stores string IDs)
                const filteredItems = items.filter(item =>
                    !this.selectedItems.some(selected => String(selected.id) === String(item.id))
                );

                if (filteredItems.length > 0) {
                    dropdown.innerHTML = AlertsUI.renderSuggestions(filteredItems);
                    dropdown.style.display = 'block';
                    this.selectedIndex = -1;
                } else {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle keyboard navigation in dropdown
            input.addEventListener('keydown', (e) => {
                if (dropdown.style.display === 'none') {
                    // Backspace with empty input removes last item
                    if (e.key === 'Backspace' && input.value === '' && this.selectedItems.length > 0) {
                        const lastItem = this.selectedItems[this.selectedItems.length - 1];
                        removeItem(lastItem.id);
                    }
                    return;
                }

                const items = dropdown.querySelectorAll('.suggestion-item');
                if (items.length === 0) return;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        updateSelection();
                        break;

                    case 'ArrowUp':
                        e.preventDefault();
                        this.selectedIndex = this.selectedIndex <= 0
                            ? items.length - 1
                            : this.selectedIndex - 1;
                        updateSelection();
                        break;

                    case 'Tab':
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.selectedIndex = this.selectedIndex <= 0
                                ? items.length - 1
                                : this.selectedIndex - 1;
                        } else {
                            this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        }
                        updateSelection();
                        break;

                    case 'Enter':
                        if (this.selectedIndex >= 0) {
                            e.preventDefault();
                            const selectedItem = items[this.selectedIndex];
                            addItem(selectedItem.dataset.id, selectedItem.dataset.name);
                        }
                        break;

                    case 'Escape':
                        e.preventDefault();
                        dropdown.style.display = 'none';
                        this.selectedIndex = -1;
                        break;
                }
            });

            // Handle mouse click on suggestion
            dropdown.addEventListener('click', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    addItem(e.target.dataset.id, e.target.dataset.name);
                }
            });

            // Handle mouse hover to update selection
            dropdown.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    const items = dropdown.querySelectorAll('.suggestion-item');
                    items.forEach((item, index) => {
                        if (item === e.target) {
                            this.selectedIndex = index;
                        }
                    });
                    updateSelection();
                }
            });
        },

        /**
         * Renders the selected items in the dropdown list.
         * Shows each item with its name and a red X remove button - matching alert_detail.html styling.
         * 
         * What: Updates the DOM to display all currently selected items
         * Why: Provides visual feedback of selected items with ability to remove
         * How: Generates HTML rows for each item with remove button
         */
        renderSelectedItems() {
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spreadSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spreadNoItemsMessage);

            if (!selectedList) return;

            if (this.selectedItems.length === 0) {
                selectedList.innerHTML = '';
                if (noItemsMsg) noItemsMsg.classList.add('show');
            } else {
                if (noItemsMsg) noItemsMsg.classList.remove('show');
                selectedList.innerHTML = this.selectedItems.map(item =>
                    `<div class="selected-item-row">
                        <span class="item-name">${item.name}</span>
                        <button type="button" class="remove-item-btn" data-id="${item.id}" title="Remove ${item.name}">Ã—</button>
                    </div>`
                ).join('');
            }
        },

        /**
         * Shows a small notification next to the "Items" label.
         * 
         * What: Displays success/error feedback for item add/remove operations
         * Why: Provides immediate visual feedback without disruptive popups
         * How: Updates the notification span with text and appropriate class, auto-hides after delay
         * 
         * @param {string} message - The notification message to display
         * @param {string} type - 'success' for green (item added/removed) or 'error' for red (duplicate)
         */
        showNotification(message, type) {
            const notification = document.querySelector(AlertsConfig.selectors.create.spreadItemNotification);
            if (!notification) return;

            // Clear any existing timeout to prevent overlapping notifications
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout);
            }

            // Set the message and styling
            notification.textContent = message;
            notification.className = 'item-notification ' + type + ' show';

            // Auto-hide after 2.5 seconds
            this.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, 2500);
        },

        /**
         * Clears all selected items.
         * 
         * What: Removes all items from the selection
         * Why: Called when switching scope mode or after form submission
         * How: Empties the array and clears DOM elements
         */
        clear() {
            this.selectedItems = [];
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spreadSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spreadNoItemsMessage);
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.spreadItemIds);
            
            if (selectedList) selectedList.innerHTML = '';
            if (noItemsMsg) noItemsMsg.classList.add('show');
            if (hiddenInput) hiddenInput.value = '';
        },

        /**
         * Gets the selected item IDs.
         * 
         * @returns {Array} Array of item ID strings
         */
        getSelectedIds() {
            return this.selectedItems.map(item => item.id);
        }
    };


    // =============================================================================
    // SPIKE MULTI-ITEM SELECTOR
    // =============================================================================
    /**
     * SpikeMultiItemSelector
     * ======================
     * What: Manages multi-item selection for spike alerts with "Specific Item(s)" option.
     * Why: Users may want to monitor spike on a curated list of items instead of all or just one.
     * How: Uses box-style input with dropdown toggle showing selected items - same pattern as spread.
     * 
     * This implementation mirrors SpreadMultiItemSelector for visual and behavioral consistency.
     * Multi-item spike alerts will:
     * - Trigger when ANY item exceeds the threshold
     * - Re-trigger when triggered_data changes (different items or percentages)
     * - Deactivate when ALL items are simultaneously within threshold
     */
    const SpikeMultiItemSelector = {
        // selectedItems: Array of {id, name} objects representing currently selected items
        selectedItems: [],
        // selectedIndex: Index of currently highlighted suggestion in dropdown (-1 = none)
        selectedIndex: -1,
        // notificationTimeout: Reference to timeout for auto-hiding notifications
        notificationTimeout: null,
        // dropdownOpen: Tracks if the selected items dropdown is currently open
        dropdownOpen: false,

        /**
         * Initializes the spike multi-item selector.
         * 
         * What: Sets up event listeners for the spike item search input and dropdown toggle
         * Why: Enables autocomplete functionality, dropdown management, and item removal
         * How: Attaches input, keydown, click handlers to relevant DOM elements
         */
        init() {
            // Get all DOM elements needed for the multi-item selector
            const input = document.querySelector(AlertsConfig.selectors.create.spikeItemInput);
            const dropdown = document.querySelector(AlertsConfig.selectors.create.spikeItemSuggestions);
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.spikeItemIds);
            const selectedDropdown = document.querySelector(AlertsConfig.selectors.create.spikeSelectedItemsDropdown);
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spikeSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spikeNoItemsMessage);
            const toggleBtn = document.querySelector(AlertsConfig.selectors.create.spikeMultiItemToggle);
            const selectorBox = input ? input.closest('.multi-item-selector-box') : null;

            if (!input || !dropdown || !hiddenInput || !selectedDropdown) return;

            const self = this;
            this.selectedItems = [];
            this.selectedIndex = -1;
            this.dropdownOpen = false;

            /**
             * Updates the hidden input with current selected item IDs.
             */
            const updateHiddenInput = () => {
                hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
            };

            /**
             * Updates visual selection state in autocomplete dropdown.
             */
            const updateSelection = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (index === this.selectedIndex) {
                        item.classList.add('selected');
                        item.scrollIntoView({block: 'nearest'});
                    } else {
                        item.classList.remove('selected');
                    }
                });
            };

            /**
             * Adds an item to the selected list.
             * 
             * What: Adds item to selectedItems array and updates UI
             * Why: Central function for adding items from autocomplete or manual entry
             * How: Checks for duplicates using String() conversion for type-safe comparison,
             *      adds to array, updates hidden input and renders list
             */
            const addItem = (id, name) => {
                // =============================================================================
                // CHECK FOR DUPLICATE ITEMS BEFORE ADDING
                // =============================================================================
                // What: Prevents the same item from being added multiple times to the selection
                // Why: Users shouldn't be able to add duplicate items - this would cause confusion
                //      and potentially duplicate alert notifications for the same item
                // How: Compares IDs using String() conversion to handle type mismatches
                //      (API returns numbers, DOM stores strings from dataset attributes)
                if (this.selectedItems.some(item => String(item.id) === String(id))) {
                    this.showNotification(`${name} is already selected`, 'error');
                    return;
                }

                this.selectedItems.push({id, name});
                updateHiddenInput();
                this.renderSelectedItems();
                input.value = '';
                dropdown.style.display = 'none';
                this.selectedIndex = -1;
                this.showNotification(`${name} added`, 'success');
            };

            /**
             * Removes an item from the selected list.
             */
            const removeItem = (id) => {
                const itemToRemove = this.selectedItems.find(item => String(item.id) === String(id));
                const itemName = itemToRemove ? itemToRemove.name : 'Item';
                this.selectedItems = this.selectedItems.filter(item => String(item.id) !== String(id));
                updateHiddenInput();
                this.renderSelectedItems();
                this.showNotification(`${itemName} removed`, 'success');
            };

            // Handle remove button clicks in selected items dropdown
            if (selectedList) {
                selectedList.addEventListener('click', function(e) {
                    if (e.target.classList.contains('remove-item-btn')) {
                        e.preventDefault();
                        e.stopPropagation();
                        const itemId = e.target.dataset.id;
                        removeItem(itemId);
                    }
                });
            }

            // Handle dropdown toggle button clicks
            if (toggleBtn) {
                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    
                    this.dropdownOpen = !this.dropdownOpen;
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.add('show');
                        toggleBtn.classList.add('active');
                    } else {
                        selectedDropdown.classList.remove('show');
                        toggleBtn.classList.remove('active');
                    }
                });
            }

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (selectorBox && !selectorBox.contains(e.target)) {
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.remove('show');
                        if (toggleBtn) toggleBtn.classList.remove('active');
                        this.dropdownOpen = false;
                    }
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle input changes - fetch suggestions from API
            input.addEventListener('input', async () => {
                const query = input.value;

                if (this.dropdownOpen) {
                    selectedDropdown.classList.remove('show');
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    this.dropdownOpen = false;
                }

                if (query.length < AlertsConfig.timing.minSearchLength) {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    return;
                }

                const items = await AlertsAPI.searchItems(query);
                
                // =============================================================================
                // FILTER OUT ALREADY SELECTED ITEMS FROM SUGGESTIONS
                // =============================================================================
                // What: Removes items that are already in the selectedItems array from the suggestions
                // Why: Once a user has added an item to be tracked, it shouldn't appear in the
                //      dropdown suggestions anymore - this prevents confusion and duplicate selection attempts
                // How: Uses Array.filter() to keep only items whose ID is not found in selectedItems
                const filteredItems = items ? items.filter(item =>
                    !this.selectedItems.some(selected => String(selected.id) === String(item.id))
                ) : [];
                
                if (filteredItems.length > 0) {
                    dropdown.innerHTML = filteredItems.map(item =>
                        `<div class="suggestion-item" data-id="${item.id}" data-name="${item.name}">${item.name}</div>`
                    ).join('');
                    dropdown.style.display = 'block';
                    this.selectedIndex = -1;

                    // Add click handlers to suggestions
                    dropdown.querySelectorAll('.suggestion-item').forEach(item => {
                        item.addEventListener('click', () => {
                            addItem(item.dataset.id, item.dataset.name);
                        });
                    });
                } else {
                    // If no items left after filtering, hide the dropdown entirely
                    // (don't show "No items found" since items exist but are already selected)
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle keyboard navigation in dropdown
            // What: Enables keyboard-based navigation and selection of autocomplete suggestions
            // Why: Users expect Tab/Shift+Tab to navigate through suggestions like arrow keys
            // How: ArrowDown/Tab move down, ArrowUp/Shift+Tab move up, Enter selects, Escape closes
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                const itemCount = items.length;

                // Only process navigation keys when dropdown is visible and has items
                // What: Check if dropdown is visible before handling navigation
                // Why: Allows normal Tab behavior when no suggestions are shown
                // How: Check display style and item count before preventing default
                if (dropdown.style.display === 'none' || itemCount === 0) {
                    // Backspace with empty input removes last selected item
                    if (e.key === 'Backspace' && input.value === '' && this.selectedItems.length > 0) {
                        const lastItem = this.selectedItems[this.selectedItems.length - 1];
                        removeItem(lastItem.id);
                    }
                    return;
                }

                switch (e.key) {
                    case 'ArrowDown':
                        // What: Move selection down through suggestions
                        // Why: Standard keyboard navigation pattern
                        // How: Increment index, wrap around at end using modulo
                        e.preventDefault();
                        this.selectedIndex = (this.selectedIndex + 1) % itemCount;
                        updateSelection();
                        break;

                    case 'ArrowUp':
                        // What: Move selection up through suggestions
                        // Why: Standard keyboard navigation pattern
                        // How: Decrement index, wrap to end if at beginning
                        e.preventDefault();
                        this.selectedIndex = this.selectedIndex <= 0
                            ? itemCount - 1
                            : this.selectedIndex - 1;
                        updateSelection();
                        break;

                    case 'Tab':
                        // What: Tab navigates through suggestions like arrow keys
                        // Why: Users expect Tab to move through autocomplete options, not focus next element
                        // How: Shift+Tab goes up, Tab goes down, same as arrow keys
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Shift+Tab: Move selection up (same as ArrowUp)
                            this.selectedIndex = this.selectedIndex <= 0
                                ? itemCount - 1
                                : this.selectedIndex - 1;
                        } else {
                            // Tab: Move selection down (same as ArrowDown)
                            this.selectedIndex = (this.selectedIndex + 1) % itemCount;
                        }
                        updateSelection();
                        break;

                    case 'Enter':
                        // What: Select the currently highlighted suggestion
                        // Why: Standard keyboard pattern for confirming selection
                        // How: Add the highlighted item to selected list, clear input
                        e.preventDefault();
                        if (this.selectedIndex >= 0 && this.selectedIndex < itemCount) {
                            const selected = items[this.selectedIndex];
                            addItem(selected.dataset.id, selected.dataset.name);
                        }
                        break;

                    case 'Escape':
                        // What: Close the suggestions dropdown without selecting
                        // Why: Standard keyboard pattern for canceling/dismissing
                        // How: Hide dropdown, reset selection index
                        e.preventDefault();
                        dropdown.style.display = 'none';
                        this.selectedIndex = -1;
                        break;
                }
            });

            // Handle focus
            input.addEventListener('focus', async () => {
                if (input.value.length >= AlertsConfig.timing.minSearchLength) {
                    const items = await AlertsAPI.searchItems(input.value);
                    if (items && items.length > 0) {
                        dropdown.innerHTML = items.map(item =>
                            `<div class="suggestion-item" data-id="${item.id}" data-name="${item.name}">${item.name}</div>`
                        ).join('');
                        dropdown.style.display = 'block';

                        dropdown.querySelectorAll('.suggestion-item').forEach(item => {
                            item.addEventListener('click', () => {
                                addItem(item.dataset.id, item.dataset.name);
                            });
                        });
                    }
                    updateSelection();
                }
            });
        },

        /**
         * Renders the selected items in the dropdown list.
         */
        renderSelectedItems() {
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spikeSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spikeNoItemsMessage);

            if (!selectedList) return;

            if (this.selectedItems.length === 0) {
                selectedList.innerHTML = '';
                if (noItemsMsg) noItemsMsg.classList.add('show');
            } else {
                if (noItemsMsg) noItemsMsg.classList.remove('show');
                selectedList.innerHTML = this.selectedItems.map(item =>
                    `<div class="selected-item-row">
                        <span class="item-name">${item.name}</span>
                        <button type="button" class="remove-item-btn" data-id="${item.id}" title="Remove ${item.name}">Ã—</button>
                    </div>`
                ).join('');
            }
        },

        /**
         * Shows a small notification next to the "Items" label.
         */
        showNotification(message, type) {
            const notification = document.querySelector(AlertsConfig.selectors.create.spikeItemNotification);
            if (!notification) return;

            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout);
            }

            notification.textContent = message;
            notification.className = 'item-notification ' + type + ' show';

            this.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, 2500);
        },

        /**
         * Clears all selected items.
         */
        clear() {
            this.selectedItems = [];
            const selectedList = document.querySelector(AlertsConfig.selectors.create.spikeSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.spikeNoItemsMessage);
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.spikeItemIds);
            
            if (selectedList) selectedList.innerHTML = '';
            if (noItemsMsg) noItemsMsg.classList.add('show');
            if (hiddenInput) hiddenInput.value = '';
        },

        /**
         * Gets the selected item IDs.
         * 
         * @returns {Array} Array of item ID strings
         */
        getSelectedIds() {
            return this.selectedItems.map(item => item.id);
        },

        /**
         * Sets items for editing an existing alert.
         * 
         * @param {Array} items - Array of {id, name} objects to set as selected
         */
        setItems(items) {
            this.selectedItems = items || [];
            this.renderSelectedItems();
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.spikeItemIds);
            if (hiddenInput) {
                hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
            }
        }
    };


    // =============================================================================
    // THRESHOLD MULTI-ITEM SELECTOR
    // =============================================================================
    /**
     * ThresholdMultiItemSelector
     * ===========================
     * What: Manages the multi-item selection interface for threshold alerts.
     * Why: Threshold alerts can monitor multiple specific items, requiring a UI to add/remove items.
     * How: Provides autocomplete search, selected items dropdown, and item management functionality.
     *      Nearly identical to SpreadMultiItemSelector but operates on threshold-specific DOM elements.
     * 
     * This selector is used when:
     * - User selects "Threshold" as alert type
     * - User selects "Specific Items" in Items Tracked dropdown
     * 
     * Key behaviors:
     * - When items are added/removed, updates FormManager.updateThresholdTypeState()
     *   to enforce percentage mode when multiple items are selected
     * - Clears selection when switching to "All Items" mode
     */
    const ThresholdMultiItemSelector = {
        // selectedItems: Array of {id, name} objects representing currently selected items
        selectedItems: [],
        // selectedIndex: Index of currently highlighted suggestion in dropdown (-1 = none)
        selectedIndex: -1,
        // notificationTimeout: Reference to timeout for auto-hiding notifications
        notificationTimeout: null,
        // dropdownOpen: Tracks if the selected items dropdown is currently open
        dropdownOpen: false,

        /**
         * Initializes the threshold multi-item selector.
         * 
         * What: Sets up event listeners for the threshold item search input and dropdown toggle
         * Why: Enables autocomplete functionality, dropdown management, and item removal
         * How: Attaches input, keydown, click handlers to relevant DOM elements
         */
        init() {
            // Get all DOM elements needed for the multi-item selector
            // input: Text input where user types to search for items to add
            const input = document.querySelector(AlertsConfig.selectors.create.thresholdItemInput);
            // dropdown: Container showing autocomplete suggestions when typing
            const dropdown = document.querySelector(AlertsConfig.selectors.create.thresholdItemSuggestions);
            // hiddenInput: Hidden field that stores comma-separated item IDs for form submission
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.thresholdItemIds);
            // selectedDropdown: Container showing list of already selected items
            const selectedDropdown = document.querySelector(AlertsConfig.selectors.create.thresholdSelectedItemsDropdown);
            // selectedList: Inner container where selected item rows are rendered
            const selectedList = document.querySelector(AlertsConfig.selectors.create.thresholdSelectedItemsList);
            // noItemsMsg: Message shown when no items are selected
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.thresholdNoItemsMessage);
            // toggleBtn: Button with chevron arrow to show/hide selected items dropdown
            const toggleBtn = document.querySelector(AlertsConfig.selectors.create.thresholdMultiItemToggle);
            // selectorBox: The main container box for the selector (for click-outside handling)
            const selectorBox = input ? input.closest('.multi-item-selector-box') : null;

            if (!input || !dropdown || !hiddenInput || !selectedDropdown) return;

            // Reference to 'this' for use inside closures
            const self = this;
            this.selectedItems = [];
            this.selectedIndex = -1;
            this.dropdownOpen = false;

            /**
             * Updates the hidden input with current selected item IDs.
             * Called whenever items are added or removed to keep form data in sync.
             */
            const updateHiddenInput = () => {
                hiddenInput.value = this.selectedItems.map(item => item.id).join(',');
            };

            /**
             * Updates visual selection state in autocomplete dropdown.
             * Highlights the currently selected suggestion item.
             */
            const updateSelection = () => {
                const items = dropdown.querySelectorAll('.suggestion-item');
                items.forEach((item, index) => {
                    if (index === this.selectedIndex) {
                        item.classList.add('selected');
                        item.scrollIntoView({block: 'nearest'});
                    } else {
                        item.classList.remove('selected');
                    }
                });
            };

            /**
             * Adds an item to the selected list.
             * 
             * What: Adds item to selectedItems array and updates UI
             * Why: Central function for adding items from autocomplete or manual entry
             * How: Checks for duplicates, adds to array, updates hidden input and renders list
             * 
             * @param {string} id - The item's unique identifier
             * @param {string} name - The item's display name
             */
            const addItem = (id, name) => {
                // =============================================================================
                // CHECK FOR DUPLICATE ITEMS BEFORE ADDING
                // =============================================================================
                // What: Prevents the same item from being added multiple times to the selection
                // Why: Users shouldn't be able to add duplicate items - this would cause confusion
                //      and potentially duplicate alert notifications for the same item
                // How: Compares IDs using String() conversion to handle type mismatches
                //      (API returns numbers, DOM stores strings from dataset attributes)
                if (this.selectedItems.some(item => String(item.id) === String(id))) {
                    this.showNotification(`${name} is already selected`, 'error');
                    return;
                }

                this.selectedItems.push({id, name});
                updateHiddenInput();
                this.renderSelectedItems();
                input.value = '';
                dropdown.style.display = 'none';
                this.selectedIndex = -1;

                // Show success notification
                this.showNotification(`${name} added`, 'success');

                // Update threshold type state (lock to percentage if multiple items)
                FormManager.updateThresholdTypeState();
            };

            /**
             * Removes an item from the selected list.
             * 
             * What: Removes item from selectedItems array and updates UI
             * Why: Called when user clicks the red X button on an item
             * 
             * @param {string} id - The item's unique identifier to remove
             */
            const removeItem = (id) => {
                const itemToRemove = this.selectedItems.find(item => String(item.id) === String(id));
                const itemName = itemToRemove ? itemToRemove.name : 'Item';
                this.selectedItems = this.selectedItems.filter(item => String(item.id) !== String(id));
                updateHiddenInput();
                this.renderSelectedItems();

                // Show removal notification
                this.showNotification(`${itemName} removed`, 'success');

                // Update threshold type state (may unlock value option if only 1 item left)
                FormManager.updateThresholdTypeState();
            };

            // Handle remove button clicks in selected items dropdown (event delegation)
            if (selectedList) {
                selectedList.addEventListener('click', function(e) {
                    if (e.target.classList.contains('remove-item-btn')) {
                        e.preventDefault();
                        e.stopPropagation();
                        const itemId = e.target.dataset.id;
                        removeItem(itemId);
                    }
                });
            }

            // Handle dropdown toggle button clicks
            if (toggleBtn) {
                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close autocomplete suggestions if open
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    
                    // Toggle selected items dropdown
                    this.dropdownOpen = !this.dropdownOpen;
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.add('show');
                        toggleBtn.classList.add('active');
                    } else {
                        selectedDropdown.classList.remove('show');
                        toggleBtn.classList.remove('active');
                    }
                });
            }

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (selectorBox && !selectorBox.contains(e.target)) {
                    // Close selected items dropdown
                    if (this.dropdownOpen) {
                        selectedDropdown.classList.remove('show');
                        if (toggleBtn) toggleBtn.classList.remove('active');
                        this.dropdownOpen = false;
                    }
                    // Close autocomplete suggestions
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle input changes - fetch suggestions from API
            input.addEventListener('input', async () => {
                const query = input.value;

                // Close selected items dropdown when user starts typing
                if (this.dropdownOpen) {
                    selectedDropdown.classList.remove('show');
                    if (toggleBtn) toggleBtn.classList.remove('active');
                    this.dropdownOpen = false;
                }

                // minSearchLength: Minimum characters before searching (prevents API spam)
                if (query.length < AlertsConfig.timing.minSearchLength) {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                    return;
                }

                // Fetch matching items from API
                const items = await AlertsAPI.searchItems(query);

                // =============================================================================
                // FILTER OUT ALREADY SELECTED ITEMS FROM SUGGESTIONS
                // =============================================================================
                // What: Removes items that are already in the selectedItems array from the suggestions
                // Why: Once a user has added an item to be tracked, it shouldn't appear in the
                //      dropdown suggestions anymore - this prevents confusion and duplicate selection attempts
                // How: Uses Array.filter() to keep only items whose ID is not found in selectedItems.
                //      String conversion ensures type-safe comparison (API returns number IDs, DOM stores string IDs)
                const filteredItems = items.filter(item =>
                    !this.selectedItems.some(selected => String(selected.id) === String(item.id))
                );

                if (filteredItems.length > 0) {
                    dropdown.innerHTML = AlertsUI.renderSuggestions(filteredItems);
                    dropdown.style.display = 'block';
                    this.selectedIndex = -1;
                } else {
                    dropdown.style.display = 'none';
                    this.selectedIndex = -1;
                }
            });

            // Handle keyboard navigation in dropdown
            input.addEventListener('keydown', (e) => {
                if (dropdown.style.display === 'none') {
                    // Backspace with empty input removes last item
                    if (e.key === 'Backspace' && input.value === '' && this.selectedItems.length > 0) {
                        const lastItem = this.selectedItems[this.selectedItems.length - 1];
                        removeItem(lastItem.id);
                    }
                    return;
                }

                const items = dropdown.querySelectorAll('.suggestion-item');
                if (items.length === 0) return;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        updateSelection();
                        break;

                    case 'ArrowUp':
                        e.preventDefault();
                        this.selectedIndex = this.selectedIndex <= 0
                            ? items.length - 1
                            : this.selectedIndex - 1;
                        updateSelection();
                        break;

                    case 'Tab':
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.selectedIndex = this.selectedIndex <= 0
                                ? items.length - 1
                                : this.selectedIndex - 1;
                        } else {
                            this.selectedIndex = (this.selectedIndex + 1) % items.length;
                        }
                        updateSelection();
                        break;

                    case 'Enter':
                        if (this.selectedIndex >= 0) {
                            e.preventDefault();
                            const selectedItem = items[this.selectedIndex];
                            addItem(selectedItem.dataset.id, selectedItem.dataset.name);
                        }
                        break;

                    case 'Escape':
                        e.preventDefault();
                        dropdown.style.display = 'none';
                        this.selectedIndex = -1;
                        break;
                }
            });

            // Handle mouse click on suggestion
            dropdown.addEventListener('click', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    addItem(e.target.dataset.id, e.target.dataset.name);
                }
            });

            // Handle mouse hover to update selection
            dropdown.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('suggestion-item')) {
                    const items = dropdown.querySelectorAll('.suggestion-item');
                    items.forEach((item, index) => {
                        if (item === e.target) {
                            this.selectedIndex = index;
                        }
                    });
                    updateSelection();
                }
            });
        },

        /**
         * Renders the selected items in the dropdown list.
         * Shows each item with its name and a red X remove button - matching spread selector styling.
         * 
         * What: Updates the DOM to display all currently selected items
         * Why: Provides visual feedback of selected items with ability to remove
         * How: Generates HTML rows for each item with remove button
         */
        renderSelectedItems() {
            const selectedList = document.querySelector(AlertsConfig.selectors.create.thresholdSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.thresholdNoItemsMessage);

            if (!selectedList) return;

            if (this.selectedItems.length === 0) {
                selectedList.innerHTML = '';
                if (noItemsMsg) noItemsMsg.classList.add('show');
            } else {
                if (noItemsMsg) noItemsMsg.classList.remove('show');
                selectedList.innerHTML = this.selectedItems.map(item =>
                    `<div class="selected-item-row">
                        <span class="item-name">${item.name}</span>
                        <button type="button" class="remove-item-btn" data-id="${item.id}" title="Remove ${item.name}">Ã—</button>
                    </div>`
                ).join('');
            }
        },

        /**
         * Shows a small notification next to the "Items" label.
         * 
         * What: Displays success/error feedback for item add/remove operations
         * Why: Provides immediate visual feedback without disruptive popups
         * How: Updates the notification span with text and appropriate class, auto-hides after delay
         * 
         * @param {string} message - The notification message to display
         * @param {string} type - 'success' for green (item added/removed) or 'error' for red (duplicate)
         */
        showNotification(message, type) {
            const notification = document.querySelector(AlertsConfig.selectors.create.thresholdItemNotification);
            if (!notification) return;

            // Clear any existing timeout to prevent overlapping notifications
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout);
            }

            // Set the message and styling
            notification.textContent = message;
            notification.className = 'item-notification ' + type + ' show';

            // Auto-hide after 2.5 seconds
            this.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, 2500);
        },

        /**
         * Clears all selected items.
         * 
         * What: Removes all items from the selection
         * Why: Called when switching to "All Items" mode or after form submission
         * How: Empties the array and clears DOM elements
         */
        clear() {
            this.selectedItems = [];
            const selectedList = document.querySelector(AlertsConfig.selectors.create.thresholdSelectedItemsList);
            const noItemsMsg = document.querySelector(AlertsConfig.selectors.create.thresholdNoItemsMessage);
            const hiddenInput = document.querySelector(AlertsConfig.selectors.create.thresholdItemIds);
            
            if (selectedList) selectedList.innerHTML = '';
            if (noItemsMsg) noItemsMsg.classList.add('show');
            if (hiddenInput) hiddenInput.value = '';
        },

        /**
         * Gets the selected item IDs.
         * 
         * @returns {Array} Array of item ID strings
         */
        getSelectedIds() {
            return this.selectedItems.map(item => item.id);
        }
    };


    // =============================================================================
    // ALERTS REFRESH
    // =============================================================================
    /**
     * Handles periodic refresh of alerts data.
     * 
     * Why: Alerts can be triggered by the background script at any time.
     * Periodic refresh ensures the UI stays in sync.
     */
    const AlertsRefresh = {
        intervalId: null,
        pausedForSort: false,
        errorNotificationActive: false,
        dropdownOpen: false,

        /**
         * Checks if any dropdown is currently open or search is active.
         */
        isDropdownOpen() {
            // Check the explicit dropdown open flag first
            if (this.dropdownOpen) {
                return true;
            }
            // Check if any dropdown menu is open
            if (document.querySelector('.custom-dropdown-menu.show') !== null) {
                return true;
            }
            // Check if search input is focused
            const searchInput = document.getElementById('alertSearchInput');
            if (searchInput && document.activeElement === searchInput) {
                return true;
            }
            // Check if error notification is active
            if (this.errorNotificationActive) {
                return true;
            }
            return false;
        },

        /**
         * Called immediately when a dropdown button is clicked to pause refresh.
         */
        onDropdownOpen() {
            this.dropdownOpen = true;
        },

        /**
         * Called when all dropdowns are closed to resume refresh.
         */
        onDropdownClose() {
            this.dropdownOpen = false;
        },

        /**
         * Fetches fresh data and updates the UI.
         * Skips refresh if a dropdown is open to prevent UI disruption.
         */
        async refresh() {
            // Don't refresh if any dropdown is open
            if (this.isDropdownOpen()) {
                return;
            }

            const data = await AlertsAPI.fetchAlerts();
            if (data) {
                AlertsUI.updateMyAlertsPane(data);
            }
        },

        /**
         * Starts the periodic refresh interval.
         */
        start() {
            if (this.intervalId) return;
            this.refresh();
            this.intervalId = setInterval(
                () => this.refresh(),
                AlertsConfig.timing.refreshInterval
            );
        },

        /**
         * Temporarily pause refresh while user chooses sort order.
         */
        pauseForSort() {
            this.pausedForSort = true;
            this.stop();
        },

        /**
         * Resume refresh if it was paused for sort selection.
         */
        resumeAfterSort() {
            if (!this.pausedForSort) return;
            this.pausedForSort = false;
            this.start();
        },

        /**
         * Stops the periodic refresh.
         */
        stop() {
            if (this.intervalId) {
                clearInterval(this.intervalId);
                this.intervalId = null;
            }
        }
    };


    // =============================================================================
    // TAB NAVIGATION
    // =============================================================================
    /**
     * Manages tab switching between views.
     */
    const TabManager = {
        /**
         * Switches to a specific tab.
         */
        switchTo(tabId) {
            const activeBtn = document.querySelector(AlertsConfig.selectors.tabButtons + '.active');
            const currentTab = activeBtn ? activeBtn.getAttribute('data-tab') : null;
            if (currentTab === 'my-alerts' && tabId !== 'my-alerts') {
                AlertActions.clearStatusNotifications();
            }

            document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-tab') === tabId) {
                    btn.classList.add('active');
                }
            });

            document.querySelectorAll(AlertsConfig.selectors.tabPanes).forEach(pane => {
                pane.style.display = 'none';
            });
            document.getElementById(tabId).style.display = 'block';

            if (tabId === 'my-alerts') {
                AlertActions.mergeTriggeredNotificationsIntoStatus();
            }
        },

        /**
         * Initializes tab click handlers.
         */
        init() {
            document.querySelectorAll(AlertsConfig.selectors.tabButtons).forEach(button => {
                button.addEventListener('click', function () {
                    const tabId = button.getAttribute('data-tab');
                    TabManager.switchTo(tabId);
                });
            });
        }
    };


    // =============================================================================
    // FORM VALIDATION
    // =============================================================================
    /**
     * Handles form validation and error display for the create alert form.
     */
    const FormValidation = {
        /**
         * Shows an error notification in the triggered-notifications area.
         * @param {string} message - The error message to display
         */
        showError(message) {
            // =============================================================================
            // DETERMINE WHERE TO SHOW THE ERROR NOTIFICATION
            // =============================================================================
            // What: Find or create a container to display the error notification
            // Why: Errors can occur on either the Create Alert tab (form validation) or
            //       the My Alerts tab (validation errors passed from alert_detail.html)
            // How: Check which tab is currently visible by checking the display style
            //       If Create Alert is visible, show error above the form card
            //       If My Alerts is visible, use triggered-notifications container
            
            let notificationsContainer = null;
            
            // Check which tab is currently visible by checking the display style of tab panes
            // The active tab pane has display: block (or non-empty), inactive ones have display: none
            const createAlertTab = document.getElementById('create-alert');
            const myAlertsTab = document.getElementById('my-alerts');
            
            // isCreateAlertVisible: True if Create Alert tab pane is currently displayed
            // Check for display === 'block' because that's what TabManager.switchTo sets
            const isCreateAlertVisible = createAlertTab && createAlertTab.style.display === 'block';
            
            if (isCreateAlertVisible) {
                // We're on the Create Alert tab - show error ABOVE the form card
                notificationsContainer = createAlertTab.querySelector('.form-error-container');

                // If no dedicated error container exists, create one above the form (not inside it)
                // What: Create a container div that sits above the white form card
                // Why: User wants the error notification to appear above the form, not within it
                // How: Insert the container as the first child of the tab pane, before the form
                if (!notificationsContainer) {
                    const form = document.querySelector('.create-alert-form');
                    if (form && createAlertTab) {
                        notificationsContainer = document.createElement('div');
                        notificationsContainer.className = 'form-error-container';
                        // Insert before the form, making it appear above the white card
                        createAlertTab.insertBefore(notificationsContainer, form);
                    }
                }
            } else {
                // We're on My Alerts tab (or fallback) - use triggered-notifications container
                // This is used when errors are passed from alert_detail.html via sessionStorage
                const triggeredNotificationsContainer = document.getElementById('triggered-notifications');
                if (triggeredNotificationsContainer) {
                    notificationsContainer = triggeredNotificationsContainer;
                }
            }

            if (!notificationsContainer) return;

            // Remove any existing error notifications
            notificationsContainer.querySelectorAll('.triggered-notification.error-notification').forEach(n => n.remove());

            // Create error notification
            const notification = document.createElement('div');
            notification.className = 'triggered-notification error-notification';
            notification.innerHTML = message + '<button class="dismiss-btn" type="button">&times;</button>';

            // Add click handler for dismiss button
            const dismissBtn = notification.querySelector('.dismiss-btn');
            if (dismissBtn) {
                dismissBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    notification.classList.add('dismissing');
                    setTimeout(() => notification.remove(), 300);
                });
            }

            notificationsContainer.appendChild(notification);
            
            // Scroll to top of the form/container so user can see the error notification
            // This ensures visibility even if user has scrolled down
            notificationsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('dismissing');
                    setTimeout(() => notification.remove(), 300);
                }
            }, 5000);
        }
    };


    // =============================================================================
    // EVENT MANAGEMENT
    // =============================================================================
    /**
     * Sets up all event listeners for the alerts system.
     */
    const EventManager = {
        /**
         * Sets up modal event listeners.
         */
        setupModalEvents() {
            const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
            const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
            const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);

            // Close spread modal on backdrop click
            if (spreadModal) {
                spreadModal.addEventListener('click', function (e) {
                    if (e.target.id === 'spread-modal') {
                        ModalManager.closeSpreadModal();
                    }
                });
            }

            // Close spike modal on backdrop click
            if (spikeModal) {
                spikeModal.addEventListener('click', function (e) {
                    if (e.target.id === 'spike-modal') {
                        ModalManager.closeSpikeModal();
                    }
                });
            }

            // Close group modal on backdrop click
            if (groupModal) {
                groupModal.addEventListener('click', function (e) {
                    if (e.target.id === 'group-modal') {
                        GroupManager.close();
                    }
                });
            }

            // Close delete confirm modal on backdrop click
            const deleteModal = document.getElementById('delete-confirm-modal');
            if (deleteModal) {
                deleteModal.addEventListener('click', function (e) {
                    if (e.target.id === 'delete-confirm-modal') {
                        closeDeleteConfirmModal();
                    }
                });
            }

            // Close modals on Escape key
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    const spreadModal = document.querySelector(AlertsConfig.selectors.spreadModal);
                    if (spreadModal && spreadModal.style.display === 'flex') {
                        ModalManager.closeSpreadModal();
                    }
                    const spikeModal = document.querySelector(AlertsConfig.selectors.spikeModal);
                    if (spikeModal && spikeModal.style.display === 'flex') {
                        ModalManager.closeSpikeModal();
                    }
                    const groupModal = document.querySelector(AlertsConfig.selectors.groupModal);
                    if (groupModal && groupModal.style.display === 'flex') {
                        GroupManager.close();
                    }
                    const deleteModal = document.getElementById('delete-confirm-modal');
                    if (deleteModal && deleteModal.style.display === 'flex') {
                        closeDeleteConfirmModal();
                    }
                }
            });
        },

        /**
         * Sets up autocomplete dropdown close on outside click.
         */
        setupAutocompleteEvents() {
            document.addEventListener('click', function (e) {
                if (!e.target.closest('.form-group')) {
                    const createSuggestions = document.querySelector(AlertsConfig.selectors.create.suggestions);

                    if (createSuggestions) createSuggestions.style.display = 'none';
                }
            });
        },

        /**
         * Sets up custom dropdown toggle and click outside behavior.
         * Uses event delegation to handle dynamically rendered dropdowns.
         */
        setupDropdownEvents() {
            // Toggle dropdown menus on button click (event delegation)
            document.addEventListener('click', function (e) {
                const btn = e.target.closest('.btn-dropdown');
                if (btn) {
                    // IMMEDIATELY pause refresh before doing anything else
                    AlertsRefresh.onDropdownOpen();

                    e.stopPropagation();
                    const wrapper = btn.closest('.custom-dropdown-wrapper');
                    const menu = wrapper.querySelector('.custom-dropdown-menu');
                    const isOpen = menu.classList.contains('show');

                    // Close all other dropdowns
                    document.querySelectorAll('.custom-dropdown-menu.show').forEach(m => {
                        m.classList.remove('show');
                    });

                    // Toggle this dropdown
                    if (!isOpen) {
                        menu.classList.add('show');
                    } else {
                        // Dropdown is being closed, resume refresh
                        AlertsRefresh.onDropdownClose();
                    }
                    return;
                }

                // Handle actions dropdown item clicks
                const actionItem = e.target.closest('#actionsDropdownMenu .custom-dropdown-item');
                if (actionItem) {
                    const action = actionItem.dataset.action;
                    AlertActions.handleAction(action);
                    document.getElementById('actionsDropdownMenu')?.classList.remove('show');
                    AlertsRefresh.onDropdownClose();
                    return;
                }

                // Handle sort dropdown item clicks
                const sortItem = e.target.closest('#sortDropdownMenu .custom-dropdown-item');
                if (sortItem) {
                    const sortKey = sortItem.dataset.sort;

                    // Update active state visually
                    document.querySelectorAll('#sortDropdownMenu .custom-dropdown-item').forEach(i => {
                        i.classList.remove('active');
                    });
                    sortItem.classList.add('active');

                    handleSortSelection(sortKey);
                    document.getElementById('sortDropdownMenu')?.classList.remove('show');
                    AlertsRefresh.onDropdownClose();
                    return;
                }

                // Handle sort indicator arrow click (toggle order)
                if (e.target.id === 'sortIndicatorArrow' || e.target.closest('#sortIndicatorArrow') ||
                    e.target.id === 'sortIndicatorArrowMobile' || e.target.closest('#sortIndicatorArrowMobile')) {
                    e.stopPropagation();
                    SortManager.toggleSortOrder();
                    return;
                }

                // Handle sort indicator clear click
                if (e.target.id === 'sortIndicatorClear' || e.target.closest('#sortIndicatorClear') ||
                    e.target.id === 'sortIndicatorClearMobile' || e.target.closest('#sortIndicatorClearMobile')) {
                    e.stopPropagation();
                    clearSort();
                    return;
                }

                // Handle filter dropdown item clicks
                const filterItem = e.target.closest('#filterDropdownMenu .custom-dropdown-item');
                if (filterItem) {
                    const filterId = filterItem.dataset.filter;

                    // Check if clicking the clear button
                    if (e.target.classList.contains('filter-clear')) {
                        filterItem.classList.remove('active');
                        removeFilter(filterId);
                        updateFilterBadge();
                        document.getElementById('filterDropdownMenu')?.classList.remove('show');
                        return;
                    }

                    // Check if this filter requires a modal (don't toggle active state yet)
                    const filter = AlertsConfig.filters[filterId];
                    const requiresModal = filter && filter.requiresModal;

                    // Toggle filter
                    if (filterItem.classList.contains('active')) {
                        filterItem.classList.remove('active');
                        removeFilter(filterId);
                        updateFilterBadge();
                    } else {
                        // Only mark as active immediately if it doesn't require a modal
                        if (!requiresModal) {
                            filterItem.classList.add('active');
                            updateFilterBadge();
                        }
                        addFilter(filterId);
                    }
                    document.getElementById('filterDropdownMenu')?.classList.remove('show');
                    return;
                }

                // Close dropdowns on outside click
                if (!e.target.closest('.custom-dropdown-wrapper')) {
                    document.querySelectorAll('.custom-dropdown-menu.show').forEach(m => {
                        m.classList.remove('show');
                    });
                }
            });
        },

        /**
         * Sets up search input event handlers using event delegation.
         */
        setupSearchEvents() {
            // Use event delegation so events work after DOM re-render
            document.addEventListener('input', function (e) {
                if (e.target.id === 'alertSearchInput') {
                    AlertsState.searchQuery = e.target.value;
                    const searchWrapper = e.target.closest('.alert-search-wrapper');
                    if (searchWrapper) {
                        searchWrapper.classList.toggle('has-value', e.target.value.length > 0);
                    }
                    FilterManager.updateAlertsList();
                }
            });

            document.addEventListener('keydown', function (e) {
                if (e.target.id === 'alertSearchInput') {
                    if (e.key === 'Escape') {
                        e.target.value = '';
                        AlertsState.searchQuery = '';
                        const searchWrapper = e.target.closest('.alert-search-wrapper');
                        if (searchWrapper) {
                            searchWrapper.classList.remove('has-value');
                        }
                        FilterManager.updateAlertsList();
                        e.target.blur();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                }
            });

            document.addEventListener('click', function (e) {
                if (e.target.id === 'alertSearchClear' || e.target.closest('#alertSearchClear')) {
                    const searchInput = document.getElementById('alertSearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                        AlertsState.searchQuery = '';
                        const searchWrapper = searchInput.closest('.alert-search-wrapper');
                        if (searchWrapper) {
                            searchWrapper.classList.remove('has-value');
                        }
                        FilterManager.updateAlertsList();
                    }
                }
            });
        },

        /**
         * Initializes all event listeners.
         */
        init() {
            this.setupModalEvents();
            this.setupAutocompleteEvents();
            this.setupDropdownEvents();
            this.setupSearchEvents();
            this.setupFormValidation();
        },

        /**
         * Sets up form validation for the create alert form.
         */
        setupFormValidation() {
            const form = document.querySelector('.create-alert-form');
            if (!form) return;

            // Prevent Enter from submitting unless the Create Alert button is focused
            form.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    const submitBtn = form.querySelector('button[type="submit"]');
                    if (document.activeElement !== submitBtn) {
                        e.preventDefault();
                    }
                }
            });

            // Validate on submit
            form.addEventListener('submit', function (e) {
                const alertType = document.getElementById('alert-type').value;
                const errors = [];

                // Check item name for types that need it
                const itemNameGroup = document.getElementById('item-name-group');
                const itemNameVisible = itemNameGroup && itemNameGroup.style.display !== 'none';

                if (itemNameVisible) {
                    const itemName = document.getElementById('item-name').value.trim();
                    const itemId = document.getElementById('item-id').value.trim();

                    if (!itemName) {
                        errors.push('Item name is required');
                    } else if (!itemId) {
                        errors.push('Please select a valid item from the suggestions');
                    }
                }

                // Check price for above/below types
                if (alertType === 'above' || alertType === 'below') {
                    const price = document.getElementById('price').value;
                    if (!price || price <= 0) {
                        errors.push('Price threshold is required');
                    }
                }

                // Check percentage for spread/spike types
                if (alertType === 'spread' || alertType === 'spike') {
                    const percentage = document.getElementById('percentage').value;
                    if (!percentage || percentage <= 0) {
                        errors.push('Percentage is required');
                    }
                }

                // Check time frame for spike type
                if (alertType === 'spike') {
                    const timeFrame = document.getElementById('time-frame').value;
                    if (!timeFrame || timeFrame <= 0) {
                        errors.push('Time frame is required');
                    }
                }

                // Check sustained move specific fields
                if (alertType === 'sustained') {
                    const timeFrame = document.getElementById('time-frame').value;
                    if (!timeFrame || timeFrame <= 0) {
                        errors.push('Time frame is required');
                    }
                    const minMoves = document.getElementById('min-consecutive-moves').value;
                    if (!minMoves || minMoves < 2) {
                        errors.push('Minimum consecutive moves must be at least 2');
                    }
                    const minMovePercent = document.getElementById('min-move-percentage').value;
                    if (!minMovePercent || minMovePercent <= 0) {
                        errors.push('Minimum move percentage is required');
                    }
                    const volBuffer = document.getElementById('volatility-buffer-size').value;
                    if (!volBuffer || volBuffer < 5) {
                        errors.push('Volatility buffer size must be at least 5');
                    }
                    const volMultiplier = document.getElementById('volatility-multiplier').value;
                    if (!volMultiplier || volMultiplier <= 0) {
                        errors.push('Volatility multiplier is required');
                    }

                    // Check items - either all items or at least one specific item
                    const sustainedScope = document.getElementById('sustained-scope').value;
                    if (sustainedScope === 'specific') {
                        const selectedItemIds = document.getElementById('sustained-item-ids').value;
                        if (!selectedItemIds || selectedItemIds.trim() === '') {
                            errors.push('Please select at least one item');
                        }
                    }
                }

                // =============================================================================
                // ALL ITEMS MIN/MAX PRICE VALIDATION
                // =============================================================================
                // What: Validates that both minimum and maximum price fields have values when
                //       "All Items" is selected for any alert type
                // Why: When monitoring all items, price range filters are REQUIRED to narrow
                //       down the items being tracked - without them, the alert would monitor
                //       every single item in the database which is impractical and noisy
                // How: Check the hidden is-all-items field value, and if true, verify both
                //       minimum-price and maximum-price inputs have non-empty values
                // Note: This validation applies to ALL alert types (spread, spike, sustained, threshold)
                //       when they are configured to track "All Items"
                const isAllItemsValue = document.getElementById('is-all-items').value;
                if (isAllItemsValue === 'true') {
                    // minPriceValue: The value from the minimum price input field
                    // maxPriceValue: The value from the maximum price input field
                    // We check for empty string, null, or undefined to catch all cases
                    const minPriceValue = document.getElementById('minimum-price').value;
                    const maxPriceValue = document.getElementById('maximum-price').value;
                    
                    // Both fields must have values when All Items is selected
                    // We trim to catch whitespace-only inputs as invalid
                    if (!minPriceValue || minPriceValue.trim() === '') {
                        errors.push('Minimum Price is required when tracking All Items');
                    }
                    if (!maxPriceValue || maxPriceValue.trim() === '') {
                        errors.push('Maximum Price is required when tracking All Items');
                    }
                }

                if (errors.length > 0) {
                    e.preventDefault();
                    FormValidation.showError(errors[0]);
                }
            });
        }
    };


    // =============================================================================
    // GLOBAL FUNCTION EXPORTS
    // =============================================================================
    /**
     * These functions are exposed globally for use in onclick handlers in HTML.
     */

    // Alert name type handler
    function handleAlertNameTypeChange() {
        const nameType = document.getElementById('alert-name-type').value;
        const customNameGroup = document.getElementById('custom-name-group');
        const customNameInput = document.getElementById('alert-custom-name');

        if (nameType === 'custom') {
            customNameGroup.style.display = '';
            customNameInput.required = true;
        } else {
            customNameGroup.style.display = 'none';
            customNameInput.required = false;
            customNameInput.value = '';
        }
    }

    // Form handlers
    function handleAlertTypeChange() {
        FormManager.handleAlertTypeChange('create');
    }

    function handleSpreadScopeChange() {
        FormManager.handleSpreadScopeChange('create');
    }

    function handleSpikeScopeChange() {
        FormManager.handleSpikeScopeChange('create');
    }

    function handleSustainedScopeChange() {
        FormManager.handleSustainedScopeChange('create');
    }

    /**
     * Global wrapper for handling threshold Items Tracked dropdown changes.
     * 
     * What: Calls FormManager.handleThresholdItemsTrackedChange when user changes "All Items" vs "Specific Items"
     * Why: HTML onchange attributes can only call global functions, not module-scoped ones
     * How: Delegates to FormManager which shows/hides the item selector and updates threshold type state
     */
    function handleThresholdItemsTrackedChange() {
        FormManager.handleThresholdItemsTrackedChange('create');
    }

    // Modal handlers
    function closeSpreadModal() {
        ModalManager.closeSpreadModal();
    }

    function showSpreadDetails(alertId) {
        ModalManager.showSpreadDetails(alertId);
    }

    function closeSpikeModal() {
        ModalManager.closeSpikeModal();
    }

    function showSpikeDetails(alertId) {
        ModalManager.showSpikeDetails(alertId);
    }

    // Navigate to alert detail page
    function navigateToAlertDetail(event, alertId) {
        // Don't navigate if clicking on checkbox
        if (event.target.classList.contains('alert-checkbox')) {
            return;
        }
        window.location.href = '/alerts/' + alertId + '/';
    }

    // Alert action handlers
    function dismissAlert(alertId) {
        AlertActions.dismiss(alertId);
    }

    function dismissStatusNotification(button) {
        const notification = button.closest('.triggered-notification');
        if (!notification) return;

        // For error notifications, just dismiss immediately
        if (notification.classList.contains('error-notification')) {
            notification.classList.add('dismissing');
            setTimeout(() => notification.remove(), 300);
            return;
        }

        if (notification.classList.contains('status-notification')) {
            // Dismiss all triggered alerts referenced in this box.
            const alertIds = new Set();
            notification.querySelectorAll('.notification-line[data-kind="triggered"][data-alert-id]').forEach(l => {
                alertIds.add(l.dataset.alertId);
            });
            // Also handle any unmerged triggered banners that may still be in the container.
            const container = notification.parentElement;
            if (container) {
                container.querySelectorAll('.triggered-notification[data-alert-id]:not(.status-notification)').forEach(n => {
                    alertIds.add(n.dataset.alertId);
                });
            }
            alertIds.forEach(id => AlertActions.dismiss(id));
        }

        notification.classList.add('dismissing');
        setTimeout(() => notification.remove(), 300);
    }

    function addFilter(filterId) {
        if (filterId) {
            FilterManager.addFilter(filterId);
            updateFilterBadge();
            syncFilterDropdownState();
        }
    }

    function removeFilter(filterId) {
        // Animate the tag out first
        const tag = document.querySelector('.filter-tag[data-filter-id="' + filterId + '"]');
        if (tag) {
            tag.classList.add('removing');
            setTimeout(() => {
                FilterManager.removeFilter(filterId);
                updateFilterBadge();
                syncFilterDropdownState();
            }, 300);
        } else {
            FilterManager.removeFilter(filterId);
            updateFilterBadge();
            syncFilterDropdownState();
        }
    }

    function updateFilterBadge() {
        const badge = document.getElementById('filterBadge');
        const btn = document.getElementById('filterDropdownBtn');
        const activeCount = AlertsState.activeFilters.size;

        if (badge) {
            if (activeCount > 0) {
                badge.textContent = activeCount;
                badge.style.display = 'inline';
                if (btn) btn.classList.add('has-active');
            } else {
                badge.style.display = 'none';
                if (btn) btn.classList.remove('has-active');
            }
        }
    }

    function syncFilterDropdownState() {
        document.querySelectorAll('#filterDropdownMenu .custom-dropdown-item').forEach(item => {
            const filterId = item.dataset.filter;
            if (AlertsState.activeFilters.has(filterId)) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
    }

    function confirmFilterInput(filterId) {
        FilterManager.confirmFilterInput(filterId);
    }

    function cancelFilterInput(filterId) {
        FilterManager.cancelFilterInput(filterId);
    }

    function handleFilterInputKeydown(event, filterId) {
        if (event.key === 'Enter') {
            event.preventDefault();
            confirmFilterInput(filterId);
        } else if (event.key === 'Escape') {
            event.preventDefault();
            cancelFilterInput(filterId);
        }
    }

    // Sort handlers
    function handleSortSelection(sortKey) {
        SortManager.handleSortSelection(sortKey);
        syncSortDropdownState();
    }

    function applySortOrder(order) {
        SortManager.applySortOrder(order);
        syncSortDropdownState();
    }

    function clearSort() {
        SortManager.clearSort();
        syncSortDropdownState();
    }

    function syncSortDropdownState() {
        const currentSortKey = AlertsState.sorting.sortKey;
        document.querySelectorAll('#sortDropdownMenu .custom-dropdown-item').forEach(item => {
            if (item.dataset.sort === currentSortKey) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
    }

    // Groups filter modal functions
    function openGroupsFilterModal() {
        const modal = document.getElementById('groups-filter-modal');
        const listContainer = document.getElementById('groups-filter-list');
        const noGroupsMsg = document.getElementById('no-groups-message');

        const groups = AlertsState.getAlertGroups();
        const selectedGroups = AlertsState.getFilterValue('myGroups') || [];

        if (groups.length === 0) {
            listContainer.style.display = 'none';
            noGroupsMsg.style.display = 'block';
        } else {
            listContainer.style.display = 'block';
            noGroupsMsg.style.display = 'none';

            listContainer.innerHTML = '';
            groups.forEach(group => {
                const pill = document.createElement('span');
                pill.className = 'group-pill' + (selectedGroups.includes(group) ? ' selected' : '');
                pill.textContent = group;
                pill.dataset.group = group;
                pill.addEventListener('click', function () {
                    this.classList.toggle('selected');
                });
                listContainer.appendChild(pill);
            });
        }

        modal.style.display = 'flex';
    }

    function closeGroupsFilterModal() {
        const modal = document.getElementById('groups-filter-modal');
        modal.style.display = 'none';
    }

    function applyGroupsFilter() {
        const pills = document.querySelectorAll('#groups-filter-list .group-pill.selected');
        const selectedGroups = Array.from(pills).map(pill => pill.dataset.group);
        const sortedSelectedGroups = selectedGroups.slice().sort((a, b) => a.localeCompare(b));

        if (sortedSelectedGroups.length === 0) {
            // If no groups selected, remove the filter if it exists
            if (AlertsState.activeFilters.has('myGroups')) {
                FilterManager.removeFilter('myGroups');
            }
            closeGroupsFilterModal();
            syncFilterDropdownState();
            updateFilterBadge();
            return;
        }

        AlertsState.setFilterValue('myGroups', sortedSelectedGroups);

        // If filter not already active, activate it
        if (!AlertsState.activeFilters.has('myGroups')) {
            const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
            FilterManager.activateFilter('myGroups', displayValue);
        } else {
            // Update the filter tag label
            const tag = document.querySelector('.filter-tag[data-filter-id="myGroups"]');
            if (tag) {
                const displayValue = sortedSelectedGroups.length === 1 ? sortedSelectedGroups[0] : sortedSelectedGroups.length + ' groups';
                tag.innerHTML = 'My Groups: ' + displayValue +
                    '<button class="filter-tag-remove" onclick="removeFilter(\'myGroups\')">&times;</button>';
            }
            FilterManager.updateAlertsList();
        }

        closeGroupsFilterModal();
        syncFilterDropdownState();
        updateFilterBadge();
    }

    function openPriceFilterModal() {
        const modal = document.getElementById('price-filter-modal');
        const minInput = document.getElementById('price-filter-min');
        const maxInput = document.getElementById('price-filter-max');
        if (!modal) return;

        // Load existing values if filter is active
        const existingValue = AlertsState.getFilterValue('priceRange');
        if (existingValue) {
            if (minInput) minInput.value = existingValue.min || '';
            if (maxInput) maxInput.value = existingValue.max || '';
        } else {
            if (minInput) minInput.value = '';
            if (maxInput) maxInput.value = '';
        }

        modal.style.display = 'flex';
        setTimeout(() => minInput && minInput.focus(), 0);
    }

    function closePriceFilterModal() {
        const modal = document.getElementById('price-filter-modal');
        if (modal) modal.style.display = 'none';
    }

    function clearPriceFilter() {
        const minInput = document.getElementById('price-filter-min');
        const maxInput = document.getElementById('price-filter-max');
        if (minInput) minInput.value = '';
        if (maxInput) maxInput.value = '';

        // Remove the filter
        removeFilter('priceRange');
        closePriceFilterModal();
    }

    function applyPriceFilter() {
        const minInput = document.getElementById('price-filter-min');
        const maxInput = document.getElementById('price-filter-max');
        if (!minInput || !maxInput) return;

        const minValue = minInput.value.trim();
        const maxValue = maxInput.value.trim();

        // If both are empty, clear the filter
        if (!minValue && !maxValue) {
            removeFilter('priceRange');
            closePriceFilterModal();
            return;
        }

        const filterValue = {
            min: minValue || null,
            max: maxValue || null
        };

        AlertsState.setFilterValue('priceRange', filterValue);
        FilterManager.activateFilter('priceRange', filterValue);

        // Update the filter tag to show the range
        const tag = document.querySelector('.filter-tag[data-filter-id="priceRange"]');
        if (tag) {
            let displayText = 'Price: ';
            if (minValue && maxValue) {
                displayText += minValue + ' - ' + maxValue;
            } else if (minValue) {
                displayText += 'â‰¥ ' + minValue;
            } else if (maxValue) {
                displayText += 'â‰¤ ' + maxValue;
            }
            tag.innerHTML = displayText +
                '<button class="filter-tag-remove" onclick="removeFilter(\'priceRange\')">&times;</button>';
        }

        closePriceFilterModal();
        syncFilterDropdownState();
        updateFilterBadge();
    }

    function closeDeleteConfirmModal() {
        const modal = document.getElementById('delete-confirm-modal');
        if (modal) modal.style.display = 'none';
    }

    function executeDelete() {
        AlertActions.executeDelete();
    }

    function confirmDelete() {
        AlertActions.confirmDelete();
    }


    // =============================================================================
    // INITIALIZATION
    // =============================================================================
    /**
     * Initialize the alerts system when the script loads.
     */
    (function init() {
        // Validate server-rendered triggered notifications FIRST (before any other processing)
        // This prevents flash of notifications that should be hidden
        validateServerRenderedNotifications();

        TabManager.init();
        AutocompleteManager.init();
        MultiItemSelector.init();
        SpreadMultiItemSelector.init();  // Initialize spread multi-item selector
        SpikeMultiItemSelector.init();   // Initialize spike multi-item selector
        ThresholdMultiItemSelector.init();  // Initialize threshold multi-item selector
        EventManager.init();
        DropdownSizer.init();
        AlertsRefresh.start();

        // If the page is restored from the back/forward cache, clear transient status notifications.
        window.addEventListener('pageshow', function (e) {
            if (e.persisted) {
                AlertActions.clearStatusNotifications();
            }
        });

        // Ensure only one status notification box (merge server-side messages if any).
        AlertActions.normalizeStatusNotifications();
        AlertActions.mergeTriggeredNotificationsIntoStatus();

        // Check for deleted parameter and show notification
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('deleted') === '1') {
            AlertActions.showStatusNotification('Alert deleted');
            // Remove the parameter from URL without reload
            const newUrl = window.location.pathname;
            window.history.replaceState({}, document.title, newUrl);
        }
        
        // =============================================================================
        // CHECK FOR VALIDATION ERROR FROM ALERT DETAIL PAGE
        // =============================================================================
        // What: Checks sessionStorage for error messages passed from alert_detail.html
        // Why: When server-side validation fails during alert edit (e.g., missing min/max
        //       price for All Items), the server returns a redirect URL. The alert_detail.html
        //       stores the error in sessionStorage before redirecting here.
        // How: Check sessionStorage for 'alertValidationError' key, if present show it
        //       as an error notification and remove the key to prevent re-showing on refresh
        const validationError = sessionStorage.getItem('alertValidationError');
        if (validationError) {
            // Remove the error from sessionStorage immediately so it doesn't show again on refresh
            sessionStorage.removeItem('alertValidationError');
            // Show the error notification using FormValidation (red error notification)
            FormValidation.showError(validationError);
        }
        
        // =============================================================================
        // INITIALIZE DEFAULT ALERT TYPE FORM FIELDS
        // =============================================================================
        // What: Triggers the alert type change handler on page load
        // Why: The default alert type is now "threshold" but the form fields need to be
        //       configured to show the correct inputs for threshold alerts on initial load
        // How: Call handleAlertTypeChange which will read the current selected value and
        //       show/hide the appropriate form fields
        handleAlertTypeChange();
        
        // =============================================================================
        // LOCKED INDICATOR EVENT LISTENERS
        // =============================================================================
        // What: Set up click handlers for the threshold type locked indicator and tooltip
        // Why: Users need to click the ðŸš« icon to see why the field is locked
        // How: Add event listeners to toggle tooltip visibility on click
        
        // Locked indicator click handler - shows the tooltip
        const lockedIndicator = document.getElementById('threshold-type-locked-indicator');
        const lockedTooltip = document.getElementById('threshold-type-locked-tooltip');
        
        if (lockedIndicator && lockedTooltip) {
            // Show tooltip when indicator is clicked
            // What: Toggle tooltip visibility on indicator click
            // Why: Users clicking the ðŸš« want to know why the field is locked
            // How: Toggle display between 'none' and 'block'
            lockedIndicator.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const isVisible = lockedTooltip.style.display === 'block';
                lockedTooltip.style.display = isVisible ? 'none' : 'block';
            });
            
            // Close button click handler - hides the tooltip
            // What: Close the tooltip when X button is clicked
            // Why: Users need a way to dismiss the tooltip after reading
            // How: Set tooltip display to 'none'
            const closeBtn = lockedTooltip.querySelector('.locked-tooltip-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    lockedTooltip.style.display = 'none';
                });
            }
            
            // Click outside to close tooltip
            // What: Close tooltip when user clicks anywhere else on the page
            // Why: Standard UX pattern - clicking outside dismisses popups
            // How: Listen for document clicks, close if click is outside tooltip and indicator
            document.addEventListener('click', function(e) {
                if (lockedTooltip.style.display === 'block' &&
                    !lockedTooltip.contains(e.target) &&
                    !lockedIndicator.contains(e.target)) {
                    lockedTooltip.style.display = 'none';
                }
            });
        }
    })();

    /**
     * Validates server-rendered triggered notifications against localStorage.
     * Removes notifications for "all items" alerts where we've already seen all items.
     * Also removes notifications that the user has dismissed.
     * Shows notifications that pass validation by adding 'validated' class.
     * 
     * IMPORTANT: Server-rendered notifications come from the backend where is_dismissed=False.
     * If the backend says show it, we should trust that and clear any localStorage dismissal.
     */
    function validateServerRenderedNotifications() {
        const notifications = document.querySelectorAll('.triggered-notification[data-alert-id]:not(.status-notification)');

        notifications.forEach(notification => {
            const alertId = notification.dataset.alertId;
            if (!alertId) {
                // No alert ID, show it
                notification.classList.add('validated');
                return;
            }

            // If this notification is server-rendered, the backend is saying is_dismissed=False
            // Clear any localStorage dismissal entry to ensure it shows
            // What: Clear dismissed status from localStorage for server-rendered notifications
            // Why: Backend has is_dismissed=False (data changed), localStorage may still have it dismissed
            // How: Call clearDismissedNotification before checking if dismissed
            if (AlertsState.isNotificationDismissed(alertId)) {
                // Backend says show it, so clear the localStorage dismissal
                AlertsState.clearDismissedNotification(alertId);
            }

            // Server-rendered notifications should be shown and stored in active cache
            // Extract data and store it
            const text = notification.textContent.replace('Ã—', '').trim();
            AlertsState.setActiveNotification(alertId, {
                id: alertId,
                text: text,
                type: 'unknown',
                is_all_items: false,
                isSpreadAllItems: false,
                isSpikeAllItems: false
            });
            
            notification.classList.add('validated');
        });
    }
</script>

<!-- Alert Help Modal -->
<div class="alert-help-modal-overlay" id="alertHelpModal">
    <div class="alert-help-modal">
        <div class="alert-help-modal-header">
            <h2>
                <svg viewBox="0 0 20 20" fill="currentColor" width="24" height="24">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z"
                        clip-rule="evenodd" />
                </svg>
                Understanding Alert Types
            </h2>
            <button class="alert-help-modal-close" onclick="closeAlertHelpModal()">&times;</button>
        </div>
        <div class="alert-help-modal-body">
            <div class="alert-help-tabs">
                <button class="alert-help-tab" data-help-tab="spread">Spread</button>
                <button class="alert-help-tab" data-help-tab="spike">Spike</button>
                <button class="alert-help-tab" data-help-tab="sustained">Sustained</button>
                <button class="alert-help-tab" data-help-tab="threshold">Threshold</button>
            </div>
            <div class="alert-help-content">
                <!-- Spread Alert -->
                <div class="alert-help-section" data-help-section="spread">
                    <h3>
                        Spread Alert
                        <span class="alert-type-badge spread">Flip Margin</span>
                    </h3>
                    <p class="subtitle">Get notified when the buy/sell margin (spread) exceeds a percentage. Essential
                        for finding profitable flipping opportunities.</p>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    clip-rule="evenodd" />
                            </svg>
                            How It Works
                        </h4>
                        <p>The <strong>spread</strong> is the percentage difference between the high price (what buyers
                            pay) and the low price (what sellers receive). A higher spread means more potential profit
                            per flip.</p>
                        <p style="margin-top: 12px;"><strong>Formula:</strong> Spread % = ((High Price - Low Price) /
                            Low Price) Ã— 100</p>
                        
                        <div class="input-fields-guide" style="margin-top: 16px;">
                            <h5 style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: var(--text);">ðŸ“ Input Fields Explained:</h5>
                            <ul>
                                <li><strong>Apply To:</strong> Choose what items to monitor:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Specific Item(s)</em> - Select one or more specific items you want to track. Great for monitoring your favorite flip items.</li>
                                        <li><em>All Items</em> - Scan the entire Grand Exchange for any item meeting your spread criteria. Requires price filters to avoid noise.</li>
                                    </ul>
                                </li>
                                <li><strong>Items</strong> (when Specific Item(s) selected): Type to search for items. Click an item to add it to your list. Click the dropdown arrow to see/remove selected items. You can add multiple items to monitor simultaneously.</li>
                                <li><strong>Percentage (%):</strong> The minimum spread percentage that will trigger the alert. For example, entering "5" means you'll be notified when an item has a 5%+ margin between buy and sell prices.</li>
                                <li><strong>Minimum Price</strong> (when All Items selected): Only monitor items worth at least this much GP. Filters out low-value junk items. Enter raw number (e.g., 1000000 for 1M).</li>
                                <li><strong>Maximum Price</strong> (when All Items selected): Only monitor items worth at most this much GP. Useful for staying within your cash stack limits.</li>
                            </ul>
                        </div>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd"
                                    d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z"
                                    clip-rule="evenodd" />
                            </svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Finding items worth flipping across the entire GE</li>
                            <li>Monitoring your favorite flip items for optimal margins</li>
                            <li>Setting up "All Items" alerts to discover new opportunities</li>
                        </ul>
                    </div>

                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path
                                    d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z" />
                            </svg>
                            Example Scenario
                        </h4>
                        <p>Set an "All Items" spread alert for 5% with a minimum price of 1,000,000 gp. You'll be
                            notified whenever any item worth 1M+ has a 5%+ margin - perfect for finding high-value
                            flips!</p>
                    </div>

                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                                    clip-rule="evenodd" />
                            </svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Spread Percentage</div>
                                <div class="value">3-5% for high-value items</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Minimum Price</div>
                                <div class="value">500,000 - 1,000,000 gp</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Maximum Price</div>
                                <div class="value">Based on your cash stack</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spike Alert -->
                <div class="alert-help-section" data-help-section="spike">
                    <h3>
                        Spike Alert
                        <span class="alert-type-badge spike">Rapid Change</span>
                    </h3>
                    <p class="subtitle">Get notified when an item's price changes rapidly within a time window. Catch
                        sudden market movements as they happen.</p>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    clip-rule="evenodd" />
                            </svg>
                            How It Works
                        </h4>
                        <p>Spike alerts use a <strong>rolling time window</strong> to compare the current price against
                            the price from exactly <em>[time frame]</em> ago. If the price change exceeds your threshold,
                            you'll be notified.</p>
                        
                        <div class="input-fields-guide" style="margin-top: 16px;">
                            <h5 style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: var(--text);">ðŸ“ Input Fields Explained:</h5>
                            <ul>
                                <li><strong>Apply To:</strong> Choose what items to monitor:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Specific Item(s)</em> - Select one or more specific items to track for price spikes. The multi-item selector handles both single and multiple items.</li>
                                        <li><em>All Items</em> - Scan the entire Grand Exchange for any item spiking. Requires price filters to avoid noise from low-value items.</li>
                                    </ul>
                                </li>
                                <li><strong>Items</strong> (when Specific Item(s) selected): Type to search for items. Click an item to add it. Click the dropdown arrow to see/remove selected items. Monitor multiple items simultaneously.</li>
                                <li><strong>Percentage (%):</strong> The minimum price change percentage that triggers the alert. For example, "10" means a 10% price change within your time frame will trigger. Enter values between 0.001 and 100.</li>
                                <li><strong>Time Frame (minutes):</strong> The rolling window for comparison. The alert compares the current price to the price from exactly this many minutes ago. For example, "60" compares current price to the price 1 hour ago.</li>
                                <li><strong>Direction:</strong> Which price movements to track:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Both</em> - Alert on both price increases AND decreases. Best for catching all market movements.</li>
                                        <li><em>Up</em> - Only alert when price increases by the percentage. Good for catching pumps.</li>
                                        <li><em>Down</em> - Only alert when price decreases by the percentage. Good for catching crashes/buying opportunities.</li>
                                    </ul>
                                </li>
                                <li><strong>Minimum Price</strong> (when All Items selected): Only monitor items worth at least this much GP. Filters out cheap items that spike frequently due to low volume.</li>
                                <li><strong>Maximum Price</strong> (when All Items selected): Only monitor items worth at most this much GP. Useful for filtering to your budget range.</li>
                            </ul>
                        </div>
                        
                        <div class="alert-help-note" style="margin-top: 12px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 3px solid #ffc107;">
                            <strong>â³ Warmup Period:</strong> The alert won't trigger until enough time has passed to establish a baseline.
                            For example, a 10-minute spike alert needs 10 minutes of price data before it can make valid comparisons.
                        </div>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd"
                                    d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z"
                                    clip-rule="evenodd" />
                            </svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Catching items that spike after game updates or news</li>
                            <li>Detecting crash opportunities to buy low</li>
                            <li>Monitoring volatile items for trading opportunities</li>
                            <li>Setting "All Items" to find any item spiking in the market</li>
                            <li>Watching a curated list of items with "Specific Item(s)" mode</li>
                        </ul>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z"
                                    clip-rule="evenodd" />
                            </svg>
                            Multi-Item Behavior
                        </h4>
                        <p>When monitoring <strong>multiple specific items</strong>:</p>
                        <ul>
                            <li><strong>Triggers:</strong> When <em>any</em> item exceeds the threshold</li>
                            <li><strong>Re-triggers:</strong> When the triggered items or their percentages change</li>
                            <li><strong>No spam:</strong> Won't re-notify if the same items have the same values</li>
                            <li><strong>Deactivates:</strong> Only when <em>all</em> items are simultaneously within the threshold</li>
                        </ul>
                    </div>

                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path
                                    d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z" />
                            </svg>
                            Example Scenario
                        </h4>
                        <p>Set an "All Items" spike alert for 10% within 60 minutes, direction "Up", with minimum price
                            100,000 gp. When any item worth 100k+ jumps 10% in an hour, you'll be the first to know!</p>
                    </div>

                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                                    clip-rule="evenodd" />
                            </svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Percentage Change</div>
                                <div class="value">5-10%</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Time Frame</div>
                                <div class="value">30-60 minutes</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Direction</div>
                                <div class="value">Both (to catch all movements)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Minimum Price</div>
                                <div class="value">100,000+ gp</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sustained Move Alert -->
                <div class="alert-help-section" data-help-section="sustained">
                    <h3>
                        Sustained Move Alert
                        <span class="alert-type-badge sustained">Trend Detection</span>
                    </h3>
                    <p class="subtitle">Get notified when an item shows consistent price movement in one direction.
                        Detect emerging trends before they become obvious.</p>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    clip-rule="evenodd" />
                            </svg>
                            How It Works
                        </h4>
                        <p>Unlike spike alerts that catch sudden moves, sustained move alerts detect <strong>consistent
                                trends</strong>. They look for multiple consecutive price movements in the same
                            direction, filtering out noise to find real trends.</p>
                        
                        <div class="input-fields-guide" style="margin-top: 16px;">
                            <h5 style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: var(--text);">ðŸ“ Input Fields Explained:</h5>
                            <ul>
                                <li><strong>Apply To:</strong> Choose what items to monitor:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Specific Item(s)</em> - Select one or more specific items to track for sustained price trends.</li>
                                        <li><em>All Items</em> - Scan the entire Grand Exchange for any item showing sustained movement. Use with price filters.</li>
                                    </ul>
                                </li>
                                <li><strong>Items</strong> (when Specific Item(s) selected): Type to search for items. Click to add to your watchlist. Click the dropdown arrow to see/remove selected items.</li>
                                <li><strong>Min Consecutive Moves:</strong> How many consecutive price updates must move in the same direction to trigger. For example, "5" means 5 data points in a row must all be going up (or all going down). Minimum value is 2.</li>
                                <li><strong>Min Move %:</strong> The minimum percentage change for each individual price movement to count. For example, "0.5" means each move must be at least 0.5% - smaller changes are ignored as noise. Helps filter out tiny fluctuations.</li>
                                <li><strong>Direction:</strong> Which trends to track:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Both</em> - Alert on both upward AND downward trends.</li>
                                        <li><em>Up</em> - Only alert when price is trending upward consistently.</li>
                                        <li><em>Down</em> - Only alert when price is trending downward consistently.</li>
                                    </ul>
                                </li>
                                <li><strong>Min Volume:</strong> Only consider items with at least this many trades. Filters out low-activity items where price movements may be unreliable.</li>
                                <li><strong>Volatility Buffer (N):</strong> The rolling buffer size used to calculate average volatility. A larger buffer (e.g., 20) means smoother volatility estimates over more data points.</li>
                                <li><strong>Volatility Multiplier (K):</strong> The total sustained move must exceed K Ã— average volatility to trigger. Higher values (e.g., 1.5-2.0) filter out normal market noise by requiring the trend to be significantly larger than typical price swings.</li>
                                <li><strong>Market Pressure:</strong> Optional filter based on buy/sell pressure:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>No Pressure Filter</em> - Don't filter by market pressure.</li>
                                        <li><em>Weak+</em> - Requires any detected buying/selling pressure.</li>
                                        <li><em>Moderate+</em> - Requires pressure detected within 5 minutes.</li>
                                        <li><em>Strong</em> - Requires pressure detected within 1 minute.</li>
                                    </ul>
                                </li>
                                <li><strong>Min Spread % for Pressure:</strong> Minimum high-low spread percentage required to confirm market pressure. Higher values ensure the spread is meaningful.</li>
                            </ul>
                        </div>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd"
                                    d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z"
                                    clip-rule="evenodd" />
                            </svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>Detecting items being manipulated or merched</li>
                            <li>Finding items trending up before a big spike</li>
                            <li>Catching items in decline before they crash further</li>
                            <li>Identifying genuine market trends vs random noise</li>
                        </ul>
                    </div>

                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path
                                    d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z" />
                            </svg>
                            Example Scenario
                        </h4>
                        <p>Set a sustained move alert for "All Items" with 5 consecutive moves, 0.5% minimum move,
                            direction "Up". When any item moves up 5 times in a row, each by at least 0.5%, you'll catch
                            the trend early!</p>
                    </div>

                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                                    clip-rule="evenodd" />
                            </svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Consecutive Moves</div>
                                <div class="value">4-6 moves</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Min Move %</div>
                                <div class="value">0.3-0.5%</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Direction</div>
                                <div class="value">Both (catch all trends)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Min Volume</div>
                                <div class="value">100+ (filters low-trade items)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Threshold Alert -->
                <div class="alert-help-section" data-help-section="threshold">
                    <h3>
                        Threshold Alert
                        <span class="alert-type-badge threshold">Price Change</span>
                    </h3>
                    <p class="subtitle">Get notified when an item's price changes by a specific percentage or GP value from its baseline.
                        Flexible monitoring for price movements in either direction.</p>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    clip-rule="evenodd" />
                            </svg>
                            How It Works
                        </h4>
                        <p>Threshold alerts compare the current price against a <strong>baseline price</strong> (captured when the alert is created), or when price crosses over a specific value you specify. When tracking more than one item, only percentage thresholds are available.
                            When the price changes by your specified percentage or GP amount, you'll be notified. Unlike spike alerts that use
                            rolling time windows, threshold alerts use a fixed reference point.</p>
                        
                        <div class="input-fields-guide" style="margin-top: 16px;">
                            <h5 style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: var(--text);">ðŸ“ Input Fields Explained:</h5>
                            <ul>
                                <li><strong>Apply To:</strong> Choose what items to monitor:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Specific Item(s)</em> - Select one or more specific items. Best for tracking items you own or want to buy.</li>
                                        <li><em>All Items</em> - Scan the entire Grand Exchange. The threshold type is automatically locked to "Percentage" for this mode. Use with price filters.</li>
                                    </ul>
                                </li>
                                <li><strong>Items</strong> (when Specific Item(s) selected): Type to search for items. Click to add. Click the dropdown arrow to see/remove selected items. Each item gets its own baseline price when the alert is created.</li>
                                <li><strong>Direction:</strong> Which price movements to track:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Up</em> - Only alert when price increases above baseline by the threshold amount.</li>
                                        <li><em>Down</em> - Only alert when price decreases below baseline by the threshold amount.</li>
                                    </ul>
                                </li>
                                <li><strong>Threshold Type:</strong> How to measure the price change:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>Percentage</em> - Alert triggers when price changes by X% with respect to its value at alert creation time. For example, "10" means a 10% change from baseline. Best for comparing items of different values.</li>
                                        <li><em>Value (GP)</em> - Alert triggers when price crosses above or below a specified value.</li>
                                    </ul>
                                </li>
                                <li><strong>Threshold:</strong> The amount of change required to trigger the alert. Enter a number between 0.01 and 100 for percentages, or any GP value for Value mode. For percentage, enter "10" for 10%, not "0.10".</li>
                                <li><strong>Reference Price:</strong> Which price to monitor:
                                    <ul style="margin-top: 4px; margin-left: 16px;">
                                        <li><em>High (Instant Buy)</em> - The price you pay to buy instantly. Good for tracking buying opportunities.</li>
                                        <li><em>Low (Instant Sell)</em> - The price you receive when selling instantly. Good for tracking when to sell.</li>
                                        <li><em>Average</em> - The midpoint between high and low. Good for general price tracking.</li>
                                    </ul>
                                </li>
                                <li><strong>Minimum Price</strong> (when All Items selected): Only monitor items worth at least this much GP. Filters out low-value items.</li>
                                <li><strong>Maximum Price</strong> (when All Items selected): Only monitor items worth at most this much GP. Useful for staying within budget.</li>
                            </ul>
                        </div>
                        
                        <div class="alert-help-note" style="margin-top: 12px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 3px solid #ffc107;">
                            <strong>ðŸ“Š Baseline Price:</strong> When you create a threshold alert, the system captures the current price as the "baseline".
                            All future comparisons are made against this baseline, not a rolling window. You can see the baseline price on the alert detail page.
                        </div>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd"
                                    d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z"
                                    clip-rule="evenodd" />
                            </svg>
                            When To Use
                        </h4>
                        <ul>
                            <li>You bought an item and want to know when it rises/falls by a specific percentage</li>
                            <li>Monitoring portfolio items for significant price changes</li>
                            <li>Setting price-based exit or entry triggers</li>
                            <li>Tracking items with specific GP profit targets (single item, Value mode)</li>
                            <li>Scanning all items for significant market movements</li>
                        </ul>
                    </div>

                    <div class="alert-help-card">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z"
                                    clip-rule="evenodd" />
                            </svg>
                            Threshold vs Spike Alerts
                        </h4>
                        <p>Understanding when to use each:</p>
                        <ul>
                            <li><strong>Threshold:</strong> Uses a <em>fixed baseline</em> (price when created). Good for "notify me when this item is 10% higher than when I bought it".</li>
                            <li><strong>Spike:</strong> Uses a <em>rolling time window</em>. Good for "notify me when this item moves 10% in the last hour". Resets continuously.</li>
                        </ul>
                    </div>

                    <div class="example-scenario">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path
                                    d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z" />
                            </svg>
                            Example Scenario
                        </h4>
                        <p>You just bought an Armadyl Godsword for 15M and want to sell when it goes up 15%. Create a threshold alert with
                            Direction "Up", Threshold Type "Percentage", Threshold "15", and Reference "High". When the high price rises 15%
                            above your baseline (to ~17.25M), you'll be notified to sell!</p>
                    </div>

                    <div class="recommended-values">
                        <h4>
                            <svg viewBox="0 0 20 20" fill="currentColor" width="18" height="18">
                                <path fill-rule="evenodd"
                                    d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                                    clip-rule="evenodd" />
                            </svg>
                            Recommended Starting Values
                        </h4>
                        <div class="value-grid">
                            <div class="recommended-value">
                                <div class="label">Threshold Type</div>
                                <div class="value">Percentage (more flexible)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Threshold</div>
                                <div class="value">5-15% for most items</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Direction</div>
                                <div class="value">Up (for selling) / Down (for buying)</div>
                            </div>
                            <div class="recommended-value">
                                <div class="label">Reference Price</div>
                                <div class="value">High for selling, Low for buying</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    function openAlertHelpModal() {
        const modal = document.getElementById('alertHelpModal');
        modal.classList.add('open');
        document.body.style.overflow = 'hidden';

        // Switch to the currently selected alert type
        const alertType = document.getElementById('alert-type').value;
        switchHelpTab(alertType);
    }

    function closeAlertHelpModal() {
        const modal = document.getElementById('alertHelpModal');
        modal.classList.remove('open');
        document.body.style.overflow = '';
    }

    function switchHelpTab(tabName) {
        // Update tabs
        document.querySelectorAll('.alert-help-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.helpTab === tabName);
        });

        // Update sections
        document.querySelectorAll('.alert-help-section').forEach(section => {
            section.classList.toggle('active', section.dataset.helpSection === tabName);
        });
    }

    // Tab click handlers
    document.querySelectorAll('.alert-help-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            switchHelpTab(tab.dataset.helpTab);
        });
    });

    // Close on overlay click
    document.getElementById('alertHelpModal').addEventListener('click', (e) => {
        if (e.target.classList.contains('alert-help-modal-overlay')) {
            closeAlertHelpModal();
        }
    });

    // Close on Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeAlertHelpModal();
        }
    });

    // =============================================================================
    // NEW GROUP MODAL FUNCTIONS
    // What: Functions for the "Create New Group" modal triggered by the "+" button
    // Why: Users need a way to create groups inline while creating an alert
    // How: Opens modal, handles input, creates group, updates AlertsState and dropdown
    // =============================================================================
    
    /**
     * Opens the modal for creating a new group.
     * What: Shows the new group modal dialog
     * Why: Users need a way to create groups without leaving the create alert form
     * How: Add 'show' class to modal overlay, focus the input field
     */
    function openNewGroupModal() {
        const modal = document.getElementById('new-group-modal');
        const input = document.getElementById('new-group-name-input');
        
        // Show the modal
        modal.classList.add('show');
        
        // Clear any previous input and focus
        input.value = '';
        input.focus();
        
        // Add event listener for Enter key
        // What: Allows user to press Enter to create the group
        // Why: Faster workflow than clicking the button
        // How: Listen for keydown, check for Enter, call createNewGroup
        input.onkeydown = function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                createNewGroup();
            } else if (e.key === 'Escape') {
                closeNewGroupModal();
            }
        };
    }
    
    /**
     * Closes the new group modal.
     * What: Hides the new group modal dialog
     * Why: User cancelled or finished creating a group
     * How: Remove 'show' class from modal overlay
     */
    function closeNewGroupModal() {
        const modal = document.getElementById('new-group-modal');
        modal.classList.remove('show');
    }
    
    /**
     * Creates a new group and adds it to the dropdown.
     * What: Validates input, adds new group to AlertsState, updates dropdown, selects it
     * Why: User wants to create a new group for their alert
     * How: Get input value, validate, add to AlertsState.alertGroups, update dropdown, select
     */
    function createNewGroup() {
        const input = document.getElementById('new-group-name-input');
        const groupName = input.value.trim();
        
        // Validate input
        // What: Ensure the group name is not empty
        // Why: Empty group names are not allowed
        // How: Check trimmed value length
        if (!groupName) {
            input.focus();
            return;
        }
        
        // Check for duplicates (case-insensitive)
        // What: Prevent creating duplicate groups
        // Why: Group names should be unique per user
        // How: Check if any existing group matches (ignoring case)
        const existingGroups = AlertsState.getAlertGroups();
        const isDuplicate = existingGroups.some(g => g.toLowerCase() === groupName.toLowerCase());
        if (isDuplicate) {
            // Show error - group already exists
            input.style.borderColor = '#dc3545';
            setTimeout(() => {
                input.style.borderColor = '';
            }, 2000);
            return;
        }
        
        // Add new group to AlertsState
        // What: Adds the new group name to the application state
        // Why: Makes it available in the dropdown and for future reference
        // How: Push to alertGroups array and call updateGroupDropdown
        existingGroups.push(groupName);
        AlertsState.setAlertGroups(existingGroups);
        
        // Select the newly created group in the dropdown
        // What: Automatically selects the new group in the dropdown
        // Why: User likely wants to use the group they just created
        // How: Set the select value to the new group name
        const dropdown = document.getElementById('alert-group');
        if (dropdown) {
            dropdown.value = groupName;
        }
        
        // Close the modal
        closeNewGroupModal();
    }
    
    // Close new group modal on overlay click
    // What: Click handler for modal overlay backdrop
    // Why: Standard UX pattern - clicking outside modal closes it
    // How: Check if click target is the overlay itself (not the content)
    document.getElementById('new-group-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeNewGroupModal();
        }
    });
</script>

{% endblock %}
