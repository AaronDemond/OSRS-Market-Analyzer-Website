{% extends 'base.html' %}
{% load humanize %}
{% load static %}

{% block title %}My Flips{% endblock %}

{% block extra_css %}
<!-- Buy Limit button styles (external CSS file for maintainability) -->
<!-- What: Loads the CSS for the Buy Limit button feature in the New Flip modal -->
<!-- Why: Keeping styles in a separate file makes them easier to maintain and reuse -->
<!-- How: Django's static template tag resolves the path to the CSS file -->
<link rel="stylesheet" href="{% static 'css/flips.css' %}">

<style>
    :root {
        /* Neutrals */
        --bg: #F8F9FA;
        --surface: #FFFFFF;
        --surface-2: #F5F6F8;
        --border: #E5E7EB;
        --text: #374151;
        --muted: #6B7280;
        /* Brand - muted */
        --primary: #6366F1;
        --primary-hover: #5558E3;
        /* Semantics - muted */
        --success: #22C55E;
        --success-muted: #4ADE80;
        --danger: #EF4444;
        --danger-muted: #F87171;
        --warning: #F59E0B;
        --info: #3B82F6;
        /* Hover */
        --hover-orange: #F97316;
        --hover-orange-light: #FDBA74;
    }

    /* Skeleton loading animation */
    @keyframes skeleton-pulse {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.4;
        }
    }

    .skeleton {
        background: linear-gradient(90deg, #E5E7EB 25%, #F3F4F6 50%, #E5E7EB 75%);
        background-size: 200% 100%;
        animation: skeleton-pulse 1.5s ease-in-out infinite;
        border-radius: 4px;
    }

    .skeleton-text {
        height: 1em;
        display: inline-block;
        min-width: 60px;
    }

    .skeleton-stat-value {
        height: 28px;
        width: 100px;
    }

    .skeleton-table-row td {
        padding: 12px 14px !important;
    }

    .skeleton-cell {
        height: 16px;
        width: 80%;
        display: block;
    }

    /* Loading state for stats */
    .stats-row.loading .stat-value {
        visibility: hidden;
        position: relative;
    }

    .stats-row.loading .stat-value::after {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 80px;
        height: 24px;
        background: linear-gradient(90deg, #E5E7EB 25%, #F3F4F6 50%, #E5E7EB 75%);
        background-size: 200% 100%;
        animation: skeleton-pulse 1.5s ease-in-out infinite;
        border-radius: 4px;
        visibility: visible;
    }

    /* Fade in animation for loaded content */
    .fade-in {
        animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 30px;
    }

    .page-header-icon {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
    }

    .page-header-icon svg {
        width: 24px;
        height: 24px;
        color: white;
    }

    .page-header-text h1 {
        font-size: 1.75rem;
        font-weight: 700;
        color: var(--text);
        margin: 0 0 2px 0;
        letter-spacing: -0.02em;
    }

    .page-header-text p {
        color: var(--muted);
        margin: 0;
        font-size: 0.95rem;
    }

    /* 
        Table Styles - Modern Card Design
        ==================================
        What: Styling for the flips table with modern, sleek appearance
        Why: Table should match the card-based design seen throughout the site
        How: Uses subtle shadows, gradients, smooth transitions, and improved spacing
    */
    #flipsTable {
        width: 100%;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 16px;
        overflow: hidden;
        border-collapse: separate;
        border-spacing: 0;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.04);
    }

    /* 
        Table Header - Gradient Design
        What: Modern gradient header matching site's accent colors
        Why: Creates visual hierarchy and makes headers stand out
        How: Uses green gradient similar to page header icons
    */
    #flipsTable thead th {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: #FFFFFF;
        font-weight: 600;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.025em;
        padding: 16px 18px;
        border-bottom: none;
        transition: all 0.2s ease;
        position: relative;
    }

    /* 
        Table Header - First and Last Child Styling
        What: Ensures first and last header cells maintain border radius
        Why: Preserves the card-like rounded corners on the table
    */
    #flipsTable thead th:first-child {
        border-top-left-radius: 16px;
    }

    #flipsTable thead th:last-child {
        border-top-right-radius: 16px;
    }

    /* 
        Table Cells - Improved Spacing and Typography
        What: Better padding and subtle borders for table cells
        Why: Improves readability and creates cleaner visual separation
        How: Increased padding, lighter border colors
    */
    #flipsTable tbody td {
        padding: 16px 18px;
        border-top: 1px solid #F3F4F6;
        color: var(--text);
        font-size: 0.9375rem;
        transition: all 0.2s ease;
    }

    /* 
        Table Row - No Zebra Striping
        What: Clean white background for all rows
        Why: Modern tables often use subtle borders instead of alternating colors
        How: Uniform white background with hover effects for interaction
    */
    #flipsTable tbody tr {
        background: var(--surface);
        transition: all 0.2s ease;
    }

    /* 
        Table Row Hover - Elevated Effect
        What: Subtle shadow and background change on hover
        Why: Provides interactive feedback and highlights the current row
        How: Light purple/blue tint with shadow for depth
    */
    #flipsTable tbody tr:hover {
        background: linear-gradient(135deg, #F0F4FF 0%, #E8F0FE 100%) !important;
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.08);
        transform: scale(1.002);
    }

    #flipsTable tbody tr:hover>td {
        background: inherit !important;
        border-top-color: rgba(99, 102, 241, 0.1);
    }

    /* 
        Sortable Header Hover - Enhanced Interaction
        What: Darker gradient on hover for sortable columns
        Why: Indicates clickable/interactive headers
        How: Slightly darker green gradient with smooth transition
    */
    .sortable:hover {
        background: linear-gradient(135deg, #0d8075 0%, #2dd368 100%) !important;
        color: #fff;
        cursor: pointer;
        box-shadow: inset 0 -2px 8px rgba(0, 0, 0, 0.1);
    }

    /* 
        Links in Table - Primary Color
        What: Styled links matching the site's primary color scheme
        Why: Consistent with the rest of the site's link styling
    */
    #flipsTable a {
        color: var(--primary);
        text-decoration: none;
        font-weight: 500;
        transition: color 0.15s ease;
    }

    #flipsTable a:hover {
        color: var(--primary-hover);
        text-decoration: underline;
    }

    /* 
        First Row Special Styling
        What: Adds slight top border to first row
        Why: Creates visual separation from header
    */
    #flipsTable tbody tr:first-child td {
        border-top-color: rgba(17, 153, 142, 0.2);
    }

    .autocomplete-wrapper {
        position: relative;
    }

    .autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: var(--surface);
        border: 1px solid var(--border);
        border-top: none;
        border-radius: 0 0 4px 4px;
        z-index: 1000;
        display: none;
    }

    .autocomplete-results.show {
        display: block;
    }

    .autocomplete-item {
        padding: 8px 12px;
        cursor: pointer;
        color: var(--text);
    }

    .autocomplete-item:hover,
    .autocomplete-item.active {
        background-color: var(--primary);
        color: #fff;
    }

    /* 
        Sortable Column Styling
        What: Interactive columns that can be clicked to sort the table
        Why: Users need to sort data by different columns
        How: Cursor and transition effects indicate interactivity
    */
    .sortable {
        cursor: pointer;
        user-select: none;
        transition: all 0.2s ease;
    }

    /* 
        Sort Icon - Modern Arrows
        What: Visual indicator showing sort capability and current sort state
        Why: Users need to know which columns are sortable and current sort direction
        How: Unicode arrows with opacity and smooth transitions
    */
    .sort-icon {
        display: inline-block;
        margin-left: 6px;
        transition: all 0.2s ease;
    }

    .sort-icon::after {
        content: '⇅';
        opacity: 0.6;
        font-size: 0.9em;
    }

    .sortable:hover .sort-icon::after {
        opacity: 0.9;
    }

    .sortable.asc .sort-icon::after {
        content: '↑';
        opacity: 1;
        font-weight: bold;
    }

    .sortable.desc .sort-icon::after {
        content: '↓';
        opacity: 1;
        font-weight: bold;
    }

    /* Stats row */
    .stats-row {
        display: flex;
        flex-direction: row;
        gap: 1.5rem;
        margin-bottom: 1.5rem;
    }

    .stat-card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
        display: flex;
        flex-direction: column;
    }

    .stat-card[data-tone="success"] {
        border-top: 4px solid var(--success);
    }

    .stat-card[data-tone="danger"] {
        border-top: 4px solid var(--danger);
    }

    .stat-card[data-tone="info"] {
        border-top: 4px solid var(--primary);
    }

    .stat-label {
        color: var(--muted);
        font-size: 12px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }

    .stat-value {
        font-size: 22px;
        font-weight: 700;
        color: var(--text);
    }

    .stat-value.pnl-pos {
        color: var(--success);
    }

    .stat-value.pnl-neg {
        color: var(--danger);
    }

    .stat-value.pnl-zero {
        color: var(--muted);
    }

    /* Buttons */
    .btn-new-flip,
    .btn-delete-flip {
        padding: 8px 14px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-weight: 500;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .btn-new-flip:hover,
    .btn-delete-flip:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }

    .btn-new-flip:active,
    .btn-delete-flip:active {
        transform: translateY(1px);
    }

    .btn-new-flip svg,
    .btn-delete-flip svg {
        width: 16px;
        height: 16px;
    }

    .btn-delete-flip.delete-mode-active {
        background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        border-color: transparent;
        color: #fff;
    }

    .btn-delete-flip.delete-mode-active:hover {
        background: linear-gradient(135deg, #D97706 0%, #B45309 100%);
    }

    #flipsTable.delete-mode tbody tr {
        cursor: pointer;
    }

    #flipsTable.delete-mode tbody tr:hover {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%) !important;
    }

    #flipsTable.delete-mode tbody tr:hover td {
        color: white;
    }

    #flipsTable.delete-mode tbody tr:hover a {
        color: white;
    }

    #flipsTable.delete-mode tbody tr.selected-for-delete {
        background: linear-gradient(135deg, #B91C1C 0%, #991B1B 100%) !important;
    }

    #flipsTable.delete-mode tbody tr.selected-for-delete td {
        color: white;
    }

    #flipsTable.delete-mode tbody tr.selected-for-delete a {
        color: white;
    }

    /* Selected row styling - works even after delete-mode is removed */
    #flipsTable tbody tr.selected-for-delete,
    #flipsTable tbody tr.selected-for-delete:hover {
        background: linear-gradient(135deg, #B91C1C 0%, #991B1B 100%) !important;
    }

    #flipsTable tbody tr.selected-for-delete td,
    #flipsTable tbody tr.selected-for-delete:hover td {
        color: white !important;
        background: transparent !important;
    }

    #flipsTable tbody tr.selected-for-delete a,
    #flipsTable tbody tr.selected-for-delete:hover a {
        color: white !important;
    }

    /* Controls container - stacks buttons row and search/filter row */
    .controls-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 12px;
    }

    .buttons-row {
        display: flex;
        gap: 12px;
        align-items: center;
    }

    /*
    .search-filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    */

    /* Filter search bar - stretches to fill available space */
    .filter-search-wrapper {
        position: relative;
        flex: 1;
        min-width: 0;
    }

    .filter-search-input {
        width: 100%;
        padding: 8px 36px 8px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 14px;
        color: var(--text);
        background: var(--surface);
        transition: border-color 0.15s, box-shadow 0.15s;
    }

    .filter-search-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .filter-search-input::placeholder {
        color: var(--muted);
    }

    .filter-search-clear {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--muted);
        cursor: pointer;
        padding: 0;
        font-size: 18px;
        line-height: 1;
        display: none;
    }

    .filter-search-clear:hover {
        color: var(--text);
    }

    .filter-search-wrapper.has-value .filter-search-clear {
        display: block;
    }

    /* Filter dropdown */
    .filter-dropdown-wrapper {
        position: relative;
    }

    .btn-filter {
        padding: 8px 14px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .btn-filter:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }

    .btn-filter.has-active {
        background: rgba(99, 102, 241, 0.1);
        border-color: var(--primary);
        color: var(--primary);
    }

    .btn-filter svg {
        width: 16px;
        height: 16px;
    }

    /* =========================================================================
       HISTORICAL VIEW BUTTON STYLES
       What: Styles for the Historical View button in the search/filter row
       Why: Needs to match the filter button style but be distinguishable
       How: Uses similar styling but with a distinct color scheme
       ========================================================================= */
    .btn-historical {
        padding: 8px 14px;
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
    }

    .btn-historical:hover {
        background: rgba(59, 130, 246, 0.1);
        border-color: var(--info);
        color: var(--info);
    }

    .btn-historical svg {
        width: 16px;
        height: 16px;
    }

    /* Active state when viewing historical data */
    .btn-historical.active {
        background: rgba(59, 130, 246, 0.15);
        border-color: var(--info);
        color: var(--info);
    }

    /* =========================================================================
       HISTORICAL MODAL STYLES
       What: Distinct styling for the Historical View modal
       Why: User requested modal have a distinct appearance from other modals
       How: Uses a blue/info color scheme and unique visual elements
       ========================================================================= */
    .historical-modal .modal-content {
        border: none;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(59, 130, 246, 0.25);
        overflow: hidden;
    }

    .historical-modal .modal-header {
        background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
        color: white;
        padding: 20px 24px;
        border-bottom: none;
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .historical-modal .modal-header-icon {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .historical-modal .modal-header-icon svg {
        width: 24px;
        height: 24px;
        color: white;
    }

    .historical-modal .modal-title {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
        flex-grow: 1;
    }

    .historical-modal .btn-close {
        filter: brightness(0) invert(1);
        opacity: 0.8;
    }

    .historical-modal .btn-close:hover {
        opacity: 1;
    }

    .historical-modal .modal-body {
        padding: 24px;
    }

    .historical-description {
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 20px;
    }

    .historical-date-picker {
        margin-bottom: 24px;
    }

    .historical-date-picker .form-label {
        font-weight: 600;
        color: var(--text);
        margin-bottom: 8px;
    }

    .historical-date-input {
        padding: 12px 14px;
        border: 2px solid var(--border);
        border-radius: 10px;
        font-size: 15px;
        transition: all 0.2s;
    }

    .historical-date-input:focus {
        border-color: var(--info);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        outline: none;
    }

    .historical-presets {
        background: var(--surface-2);
        border-radius: 12px;
        padding: 16px;
    }

    .presets-label {
        display: block;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 12px;
    }

    .preset-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .btn-preset {
        padding: 8px 16px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text);
        cursor: pointer;
        transition: all 0.15s;
    }

    .btn-preset:hover {
        background: var(--info);
        border-color: var(--info);
        color: white;
    }

    .btn-preset.selected {
        background: var(--info);
        border-color: var(--info);
        color: white;
    }

    .historical-modal .modal-footer {
        padding: 16px 24px 24px;
        border-top: none;
        gap: 12px;
    }

    .btn-cancel-historical {
        padding: 12px 24px;
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 10px;
        font-weight: 500;
        color: var(--text);
        cursor: pointer;
        transition: all 0.15s;
    }

    .btn-cancel-historical:hover {
        background: var(--surface);
        border-color: var(--text);
    }

    .btn-view-historical {
        padding: 12px 24px;
        background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
        border: none;
        border-radius: 10px;
        font-weight: 600;
        color: white;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-view-historical:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 20px rgba(59, 130, 246, 0.35);
    }

    .btn-view-historical svg {
        width: 18px;
        height: 18px;
    }

    /* =========================================================================
       HISTORICAL BANNER STYLES
       What: Prominent banner indicating historical data is being viewed
       Why: Users must clearly see they're viewing past data, not real-time
       How: Fixed position banner with distinct amber/warning color scheme
       ========================================================================= */
    .historical-banner {
        background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        color: white;
        padding: 12px 20px;
        margin-bottom: 16px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        animation: banner-pulse 2s ease-in-out infinite;
    }

    @keyframes banner-pulse {
        0%, 100% {
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        50% {
            box-shadow: 0 4px 25px rgba(245, 158, 11, 0.5);
        }
    }

    .historical-banner-content {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
    }

    .historical-banner-icon {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .historical-banner-icon svg {
        width: 24px;
        height: 24px;
    }

    .historical-banner-text {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .historical-banner-label {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.9;
    }

    .historical-banner-date {
        font-size: 18px;
        font-weight: 600;
    }

    .btn-return-realtime {
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }

    .btn-return-realtime:hover {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.5);
        transform: translateY(-1px);
    }

    .btn-return-realtime svg {
        width: 18px;
        height: 18px;
    }

    /* Dimmed state for Realized Net card when viewing historical data */
    .stat-card.dimmed {
        opacity: 0.5;
        filter: grayscale(30%);
        pointer-events: none;
    }

    .stat-card.dimmed::after {
        content: 'Not applicable in historical view';
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: var(--muted);
        white-space: nowrap;
    }

    /* =========================================================================
       HISTORICAL SKIPPED ITEMS NOTIFICATION
       What: Notification shown when items are excluded due to missing historical data
       Why: Users need to know which items weren't included in the historical calculation
       How: Displays as an info banner below the historical banner
       ========================================================================= */
    .historical-skipped-notification {
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .historical-skipped-notification .notification-content {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .historical-skipped-notification svg {
        width: 20px;
        height: 20px;
        color: var(--info);
        flex-shrink: 0;
    }

    .historical-skipped-notification span {
        flex-grow: 1;
        font-size: 13px;
        color: var(--text);
        line-height: 1.4;
    }

    .historical-skipped-notification .notification-dismiss {
        background: none;
        border: none;
        color: var(--muted);
        font-size: 18px;
        cursor: pointer;
        padding: 0 4px;
        line-height: 1;
    }

    .historical-skipped-notification .notification-dismiss:hover {
        color: var(--text);
    }

    .filter-badge {
        background: var(--primary);
        color: white;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 4px;
    }

    .filter-dropdown-menu {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 6px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        min-width: 180px;
        z-index: 1000;
        display: none;
        padding: 6px;
    }

    .filter-dropdown-menu.show {
        display: block;
    }

    .filter-dropdown-header {
        padding: 8px 10px 6px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 6px;
    }

    .filter-dropdown-item {
        padding: 10px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.15s;
        border-radius: 6px;
        margin: 2px 0;
        background: var(--surface-2);
        border: 1px solid transparent;
    }

    .filter-dropdown-item:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.3);
    }

    .filter-dropdown-item.active {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
        color: var(--primary);
    }

    .filter-dropdown-item.active:hover {
        background: rgba(99, 102, 241, 0.25);
    }

    .filter-dropdown-item .filter-check {
        color: var(--primary);
        display: none;
        font-weight: 600;
    }

    .filter-dropdown-item.active .filter-check {
        display: none;
    }

    .filter-dropdown-item .filter-clear {
        display: none;
        color: var(--danger);
        font-size: 18px;
        font-weight: 600;
        line-height: 1;
        padding: 0 2px;
        border-radius: 4px;
        transition: all 0.15s;
    }

    .filter-dropdown-item.active .filter-clear {
        display: inline;
    }

    .filter-dropdown-item .filter-clear:hover {
        background: rgba(239, 68, 68, 0.15);
    }

    /* Sort indicator */
    .sort-indicator-wrapper {
        position: relative;
    }

    .sort-indicator {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 13px;
        color: var(--text);
        transition: all 0.3s ease;
        cursor: pointer;
    }

    .sort-indicator.active {
        display: inline-flex;
    }

    .sort-indicator.clickable:hover {
        background: var(--surface-2);
        border-color: var(--primary);
    }

    .sort-indicator.flash {
        animation: sortFlash 0.25s ease 5;
    }

    @keyframes sortFlash {
        0% {
            background: var(--surface);
            border-color: var(--border);
        }

        50% {
            background: rgba(99, 102, 241, 0.15);
            border-color: var(--primary);
        }

        100% {
            background: var(--surface);
            border-color: var(--border);
        }
    }

    .sort-indicator-label {
        color: var(--text-muted);
    }

    .sort-indicator-value {
        font-weight: 500;
        color: var(--primary);
    }

    .sort-indicator-arrow {
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
        transition: all 0.15s;
        font-size: 14px;
        user-select: none;
        background: var(--surface-2);
        border: 1px solid var(--border);
        margin-left: 4px;
    }

    .sort-indicator-arrow:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.4);
    }

    .sort-indicator-menu {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 6px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        min-width: 160px;
        z-index: 1000;
        display: none;
        padding: 6px;
    }

    .sort-indicator-menu.show {
        display: block;
    }

    .sort-indicator-menu .sort-by-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.15s;
        border-radius: 6px;
        margin: 2px 0;
        font-size: 13px;
        background: var(--surface-2);
        border: 1px solid transparent;
    }

    .sort-indicator-menu .sort-by-item:hover {
        background: linear-gradient(135deg, rgba(234, 179, 140, 0.3), rgba(216, 155, 108, 0.25));
        border-color: rgba(200, 140, 90, 0.3);
    }

    .sort-indicator-menu .sort-by-item.active {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
        color: var(--primary);
    }

    /* Sort selector in dropdown */
    .filter-dropdown-divider {
        height: 1px;
        background: var(--border);
        margin: 6px 0;
    }

    .filter-dropdown-section {
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .sort-by-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.15s;
        border-radius: 6px;
        margin: 2px 0;
        font-size: 13px;
    }

    .sort-by-item:hover {
        background: var(--surface-2);
    }

    .sort-by-item.active {
        background: rgba(99, 102, 241, 0.1);
        color: var(--primary);
    }

    .sort-by-item .sort-radio {
        width: 14px;
        height: 14px;
        border: 2px solid var(--border);
        border-radius: 50%;
        transition: all 0.15s;
    }

    .sort-by-item.active .sort-radio {
        border-color: var(--primary);
        background: var(--primary);
        box-shadow: inset 0 0 0 3px var(--surface);
    }

    /* Desktop sort indicator - inline with search/filter row */
    /* Only shows when sort indicator inside is active */
    .desktop-sort {
        position: relative;
        display: none;
    }

    .desktop-sort:has(.sort-indicator.active) {
        display: block;
    }

    /* Filter and sort group - keeps filter dropdown and mobile sort indicator together */
    .filter-sort-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-shrink: 0;
    }

    /* Mobile sort indicator row - hidden on desktop, shown on mobile */
    .sort-indicator-mobile-row {
        display: none;
    }

    /* Mobile sort indicator should always display when row is visible */
    .sort-indicator-mobile-row .sort-indicator {
        display: inline-flex;
    }

    /* Active filter tags row (desktop) */
    .active-filter-tags-row {
        display: none;
    }

    .active-filter-tags-row.has-filters {
        display: block;
    }

    .active-filter-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
    }

    .filter-tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px 4px 10px;
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid var(--primary);
        border-radius: 16px;
        font-size: 12px;
        color: var(--primary);
        font-weight: 500;
    }

    .filter-tag-remove {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        background: transparent;
        border: none;
        border-radius: 50%;
        color: #DC2626;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        transition: background 0.15s;
    }

    .filter-tag-remove:hover {
        background: rgba(220, 38, 38, 0.15);
    }

    /* Mobile filter tags (next to sort indicator) */
    .active-filter-tags-mobile {
        display: none;
    }

    .sort-indicator-mobile-row.has-filters .active-filter-tags-mobile {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
    }

    /* Time held subtext */
    .time-held-subtext {
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
    }

    /* Position size subtext */
    .position-size-subtext {
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
    }

    /* P&L colors for table - muted green/red */
    .pnl-pos {
        color: #16A34A;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
    }

    .pnl-neg {
        color: #DC2626;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
    }

    .pnl-zero {
        color: var(--muted);
        font-variant-numeric: tabular-nums;
    }

    /* Success notification */
    .success-notification {
        background-color: #28a745;
        color: white;
        padding: 15px 40px 15px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        position: relative;
        font-weight: 500;
        transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
        max-height: 100px;
        overflow: hidden;
    }

    .success-notification.dismissing {
        opacity: 0;
        transform: translateX(20px);
        max-height: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }

    .success-notification .dismiss-btn {
        position: absolute;
        top: 50%;
        right: 15px;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        opacity: 0.8;
    }

    .success-notification .dismiss-btn:hover {
        opacity: 1;
    }

    /* Delete confirmation modal */
    .delete-confirm-modal .modal-content {
        border-radius: 12px;
        border: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    .delete-confirm-modal .modal-header {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        color: white;
        border-radius: 12px 12px 0 0;
        border: none;
        padding: 1rem 1.5rem;
    }

    .delete-confirm-modal .modal-header .btn-close {
        filter: brightness(0) invert(1);
        opacity: 0.8;
    }

    .delete-confirm-modal .modal-header .btn-close:hover {
        opacity: 1;
    }

    .delete-confirm-modal .modal-body {
        padding: 1.5rem;
        text-align: center;
    }

    .delete-confirm-modal .modal-body .delete-icon {
        width: 64px;
        height: 64px;
        background: #FEE2E2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1rem;
    }

    .delete-confirm-modal .modal-body .delete-icon svg {
        width: 32px;
        height: 32px;
        color: #DC2626;
    }

    .delete-confirm-modal .modal-body p {
        color: var(--text);
        margin-bottom: 0.5rem;
    }

    .delete-confirm-modal .modal-body .item-name {
        font-weight: 600;
        color: var(--primary);
    }

    .delete-confirm-modal .modal-footer {
        border: none;
        padding: 1rem 1.5rem;
        gap: 0.75rem;
        justify-content: center;
    }

    .delete-confirm-modal .btn-cancel {
        background: var(--surface-2);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 0.5rem 1.5rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .delete-confirm-modal .btn-cancel:hover {
        background: var(--surface);
        border-color: var(--text-muted);
    }

    .delete-confirm-modal .btn-confirm-delete {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        border: none;
        color: white;
        padding: 0.5rem 1.5rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .delete-confirm-modal .btn-confirm-delete:hover {
        background: linear-gradient(135deg, #B91C1C 0%, #991B1B 100%);
        transform: translateY(-1px);
    }

    /* New Flip Modal styling */
    .new-flip-modal .modal-content {
        border-radius: 12px;
        border: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    .new-flip-modal .modal-header {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        border-radius: 12px 12px 0 0;
        border: none;
        padding: 1rem 1.5rem;
    }

    .new-flip-modal .modal-header .modal-title {
        font-weight: 600;
    }

    .new-flip-modal .modal-header .btn-close {
        filter: brightness(0) invert(1);
        opacity: 0.8;
    }

    .new-flip-modal .modal-header .btn-close:hover {
        opacity: 1;
    }

    .new-flip-modal .modal-body {
        padding: 1.5rem;
        font-size: 16px;
    }

    .new-flip-modal .modal-body .flip-icon {
        width: 56px;
        height: 56px;
        background: rgba(17, 153, 142, 0.1);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1rem;
    }

    .new-flip-modal .modal-body .flip-icon svg {
        width: 28px;
        height: 28px;
        color: #11998e;
    }

    .new-flip-modal .form-row {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .new-flip-modal .form-row .form-group {
        flex: 1;
    }

    .new-flip-modal .form-row .form-group.full-width {
        flex: 1 1 100%;
    }

    .new-flip-modal .form-label {
        font-weight: 500;
        color: var(--text);
        font-size: 15px;
        margin-bottom: 0.5rem;
    }

    .new-flip-modal .form-control,
    .new-flip-modal .form-select {
        border-radius: 8px;
        border: 1px solid var(--border);
        padding: 0.625rem 0.875rem;
        font-size: 16px;
        transition: all 0.15s;
    }

    .new-flip-modal .form-control:focus,
    .new-flip-modal .form-select:focus {
        border-color: #11998e;
        box-shadow: 0 0 0 3px rgba(17, 153, 142, 0.15);
    }

    .new-flip-modal .form-control::placeholder {
        color: var(--text-muted);
        opacity: 0.7;
    }

    .new-flip-modal .modal-footer {
        border: none;
        padding: 1rem 1.5rem;
        gap: 0.75rem;
        justify-content: flex-end;
    }

    .new-flip-modal .btn-cancel {
        background: var(--surface-2);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 0.5rem 1.25rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .new-flip-modal .btn-cancel:hover {
        background: var(--surface);
        border-color: var(--text-muted);
    }

    .new-flip-modal .btn-add-flip {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border: none;
        color: white;
        padding: 0.5rem 1.25rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .new-flip-modal .btn-add-flip:hover {
        background: linear-gradient(135deg, #0e8377 0%, #2dd36f 100%);
        transform: translateY(-1px);
    }

    .new-flip-modal .autocomplete-wrapper {
        position: relative;
    }

    .new-flip-modal .autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        max-height: 200px;
        overflow-y: auto;
        z-index: 1050;
        display: none;
    }

    .new-flip-modal .autocomplete-results.show {
        display: block;
    }

    .new-flip-modal .autocomplete-item {
        padding: 0.625rem 0.875rem;
        cursor: pointer;
        transition: background 0.15s, color 0.15s;
        font-size: 16px;
    }

    .new-flip-modal .autocomplete-item:hover {
        background: rgba(30, 58, 138, 0.1);
    }

    .new-flip-modal .autocomplete-item.active {
        background: #1E3A8A;
        color: white;
    }

    .new-flip-modal .date-input-wrapper {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .new-flip-modal .date-input-wrapper .form-control {
        flex: 1;
    }

    .new-flip-modal .btn-now {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border: none;
        color: white;
        padding: 0.625rem 0.75rem;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s;
        white-space: nowrap;
    }

    .new-flip-modal .btn-now:hover {
        background: linear-gradient(135deg, #0e8377 0%, #2dd36f 100%);
        transform: translateY(-1px);
    }

    /* Filter modals styling */
    .filter-modal .modal-content {
        border-radius: 12px;
        border: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    .filter-modal .modal-header {
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        color: white;
        border-radius: 12px 12px 0 0;
        border: none;
        padding: 1rem 1.5rem;
    }

    .filter-modal .modal-header .modal-title {
        font-weight: 600;
    }

    .filter-modal .modal-header .btn-close {
        filter: brightness(0) invert(1);
        opacity: 0.8;
    }

    .filter-modal .modal-header .btn-close:hover {
        opacity: 1;
    }

    .filter-modal .modal-body {
        padding: 1.5rem;
    }

    .filter-modal .modal-body .filter-icon {
        width: 56px;
        height: 56px;
        background: rgba(99, 102, 241, 0.1);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1rem;
    }

    .filter-modal .modal-body .filter-icon svg {
        width: 28px;
        height: 28px;
        color: var(--primary);
    }

    .filter-modal .modal-body .filter-description {
        text-align: center;
        color: var(--text-muted);
        font-size: 15px;
        margin-bottom: 1.25rem;
    }

    .filter-modal .modal-body .form-label {
        font-weight: 500;
        color: var(--text);
        font-size: 15px;
        margin-bottom: 0.5rem;
    }

    .filter-modal .modal-body .form-control {
        border-radius: 8px;
        border: 1px solid var(--border);
        padding: 0.625rem 0.875rem;
        font-size: 16px;
        transition: all 0.15s;
    }

    .filter-modal .modal-body .form-control:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }

    .filter-modal .modal-body .form-control::placeholder {
        color: var(--text-muted);
        opacity: 0.7;
    }

    .filter-modal .modal-footer {
        border: none;
        padding: 1rem 1.5rem;
        gap: 0.75rem;
        justify-content: flex-end;
    }

    .filter-modal .btn-clear-filter {
        background: var(--surface-2);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 0.5rem 1.25rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .filter-modal .btn-clear-filter:hover {
        background: var(--surface);
        border-color: var(--text-muted);
    }

    .filter-modal .btn-apply-filter {
        background: linear-gradient(135deg, var(--primary) 0%, #4F46E5 100%);
        border: none;
        color: white;
        padding: 0.5rem 1.25rem;
        border-radius: 8px;
        font-weight: 500;
        transition: all 0.15s;
    }

    .filter-modal .btn-apply-filter:hover {
        background: linear-gradient(135deg, #4F46E5 0%, #4338CA 100%);
        transform: translateY(-1px);
    }

    /* Completion filter modal */
    .completion-filter-modal .completion-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.75rem;
        margin-top: 0.5rem;
    }

    .completion-filter-modal .completion-card {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 0.75rem 0.9rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        transition: all 0.15s;
        cursor: pointer;
        background: var(--surface);
    }

    .completion-filter-modal .completion-card:hover {
        border-color: var(--primary);
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.12);
        transform: translateY(-1px);
    }

    .completion-filter-modal .completion-card input {
        accent-color: var(--primary);
    }

    .completion-filter-modal .completion-card .completion-label {
        font-weight: 600;
        color: var(--text);
    }

    .completion-filter-modal .completion-card .completion-hint {
        color: var(--text-muted);
        font-size: 13px;
        margin: 0;
    }

    /* Mobile styles */
    @media (max-width: 1100px) {
        .stats-row {
            flex-direction: row;
            gap: 0.5rem;
            width: fit-content;
        }

        .stat-card {
            padding: 8px 12px;
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
            border-radius: 10px;
        }

        .stat-label {
            font-size: 10px;
            margin-bottom: 0;
        }

        .stat-value {
            font-size: 16px;
        }

        /* Hide columns on mobile: Price Paid, Quantity Holding, High Price, Low Price */
        #flipsTable th:nth-child(2),
        #flipsTable td:nth-child(2),
        #flipsTable th:nth-child(3),
        #flipsTable td:nth-child(3),
        #flipsTable th:nth-child(5),
        #flipsTable td:nth-child(5),
        #flipsTable th:nth-child(6),
        #flipsTable td:nth-child(6) {
            display: none;
        }

        #flipsTable {
            font-size: 0.75rem;
            width: 100%;
            max-width: 100%;
            table-layout: fixed;
        }

        .main-content {
            overflow-x: hidden;
        }

        #flipsTable th,
        #flipsTable td {
            padding: 0.4rem 0.25rem;
        }

        /* Mobile controls layout */
        .controls-container {
            gap: 0.75rem;
        }

        .buttons-row {
            justify-content: flex-start;
        }

        /*
        .search-filter-row {
            flex-direction: row;
            gap: 0.5rem;
        }
        */

        /* Search bar stretches on mobile */
        .filter-search-wrapper {
            flex: 1;
            min-width: 0;
        }

        .filter-search-input {
            width: 100%;
            font-size: 14px;
            padding: 8px 12px;
        }

        /* Hide desktop sort indicator at 1100px */
        .desktop-sort {
            display: none !important;
        }

        /* Hide desktop filter tags row on mobile */
        .active-filter-tags-row {
            display: none !important;
        }

        /* Show mobile sort indicator as its own row starting at 1100px - only when active or has filters */
        .sort-indicator-mobile-row.active,
        .sort-indicator-mobile-row.has-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .sort-indicator {
            padding: 6px 10px;
            font-size: 12px;
            gap: 4px;
            white-space: nowrap;
        }

        .sort-indicator-arrow {
            padding: 2px 5px;
            font-size: 12px;
        }

        /* Mobile filter tags */
        .filter-tag {
            padding: 3px 6px 3px 8px;
            font-size: 11px;
        }

        .filter-tag-remove {
            width: 14px;
            height: 14px;
            font-size: 12px;
        }
    }

    /* Mobile styles */
    @media (max-width: 900px) {
        .stats-row {
            flex-direction: column;
            gap: 0.5rem;
            align-self: flex-start;
        }

        .stat-card {
            padding: 8px 12px;
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
            border-radius: 10px;
            min-width: 220px;
        }

        .stat-label {
            font-size: 10px;
            margin-bottom: 0;
        }

        .stat-value {
            font-size: 16px;
        }

        /* Hide columns on mobile: Price Paid, Quantity Holding, High Price, Low Price */
        #flipsTable th:nth-child(2),
        #flipsTable td:nth-child(2),
        #flipsTable th:nth-child(3),
        #flipsTable td:nth-child(3),
        #flipsTable th:nth-child(5),
        #flipsTable td:nth-child(5),
        #flipsTable th:nth-child(6),
        #flipsTable td:nth-child(6) {
            display: none;
        }

        #flipsTable {
            font-size: 0.75rem;
            width: 100%;
            max-width: 100%;
            table-layout: fixed;
        }

        .main-content {
            overflow-x: hidden;
        }

        #flipsTable th,
        #flipsTable td {
            padding: 0.4rem 0.25rem;
        }

        /* Mobile controls layout */
        .controls-container {
            gap: 0.75rem;
        }

        .buttons-row {
            justify-content: flex-start;
        }

        .search-filter-row {
            flex-direction: row;
            gap: 0.5rem;
        }

        /* Search bar stretches on mobile */
        .filter-search-wrapper {
            flex: 1;
            min-width: 0;
        }

        .filter-search-input {
            width: 100%;
            font-size: 14px;
            padding: 8px 12px;
        }

        /* Hide desktop sort indicator on mobile */
        .desktop-sort {
            display: none !important;
        }

        /* Hide desktop filter tags row on mobile */
        .active-filter-tags-row {
            display: none !important;
        }

        /* Show mobile sort indicator as its own row on mobile - only when active or has filters */
        .sort-indicator-mobile-row.active,
        .sort-indicator-mobile-row.has-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .sort-indicator {
            padding: 6px 10px;
            font-size: 12px;
            gap: 4px;
            white-space: nowrap;
        }

        .sort-indicator-arrow {
            padding: 2px 5px;
            font-size: 12px;
        }

        /* Mobile filter tags */
        .filter-tag {
            padding: 3px 6px 3px 8px;
            font-size: 11px;
        }

        .filter-tag-remove {
            width: 14px;
            height: 14px;
            font-size: 12px;
        }

        /* =============================================================================
           HIDE ITEM ICONS ON MOBILE
           =============================================================================
           What: Hides the item icons (OSRS Wiki images) and their placeholders on mobile
           Why: On small screens, table space is limited. Hiding icons allows more room
                for the item name and critical data columns (prices, P&L) to remain readable.
           How: Sets display:none on both .flip-icon (actual images) and .flip-icon-placeholder
                (fallback emoji shown when no icon available). Also removes the gap in the
                container since there's no icon to space from the text anymore.
        */
        .flip-icon,
        .flip-icon-placeholder {
            display: none;
        }

        /* Remove the gap in the item cell container since there's no icon on mobile */
        .flip-item-cell {
            gap: 0;
        }

        /* =========================================================================
           HISTORICAL VIEW MOBILE STYLES
           What: Responsive adjustments for historical view components on mobile
           Why: Ensures the historical button, modal, and banner work well on small screens
           How: Adjusts sizing, layout, and visibility for mobile viewports
           ========================================================================= */
        
        /* Historical button - make it icon-only on very small screens */
        .btn-historical {
            padding: 8px 12px;
        }

        .btn-historical span {
            display: none;
        }

        /* Historical banner - stack vertically on mobile */
        .historical-banner {
            padding: 10px 14px;
        }

        .historical-banner-content {
            flex-direction: column;
            align-items: flex-start;
            gap: 12px;
        }

        .historical-banner-icon {
            width: 32px;
            height: 32px;
        }

        .historical-banner-icon svg {
            width: 18px;
            height: 18px;
        }

        .historical-banner-date {
            font-size: 16px;
        }

        .btn-return-realtime {
            width: 100%;
            justify-content: center;
            padding: 10px 16px;
        }

        /* Historical modal - adjust for mobile */
        .historical-modal .modal-dialog {
            margin: 10px;
        }

        .historical-modal .modal-header {
            padding: 16px 18px;
        }

        .historical-modal .modal-body {
            padding: 18px;
        }

        .preset-buttons {
            gap: 6px;
        }

        .btn-preset {
            padding: 6px 12px;
            font-size: 12px;
        }

        .historical-modal .modal-footer {
            flex-direction: column;
            gap: 8px;
        }

        .btn-cancel-historical,
        .btn-view-historical {
            width: 100%;
            justify-content: center;
        }

        /* Skipped items notification - smaller on mobile */
        .historical-skipped-notification {
            padding: 10px 12px;
        }

        .historical-skipped-notification span {
            font-size: 12px;
        }
    }

    /* ============================================================
       FLIP ITEM ICON STYLES
       ============================================================
       These styles render item icons next to flip names in the table.
       Icons are fetched from the OSRS Wiki and displayed at 24x24px
       to fit within table rows without taking up too much space.
       ============================================================ */
    
    /* Container for the icon and item name - uses flexbox for alignment */
    .flip-item-cell {
        display: flex;
        align-items: center;
        gap: 8px;  /* Space between icon and item name */
    }
    
    /* The actual item icon image from the OSRS Wiki */
    .flip-icon {
        width: 24px;       /* Fixed width for consistent table layout */
        height: 24px;      /* Fixed height matching width for square icons */
        object-fit: contain;  /* Preserve aspect ratio, fit within bounds */
        flex-shrink: 0;    /* Prevent icon from shrinking when space is tight */
    }
    
    /* Placeholder shown when no icon is available for an item */
    .flip-icon-placeholder {
        width: 24px;       /* Same dimensions as .flip-icon for consistency */
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;   /* Size for emoji fallback */
        flex-shrink: 0;    /* Prevent shrinking */
        color: var(--muted);  /* Muted color for placeholder */
    }
    
    /* Container for item name and subtexts - allows wrapping subtexts below name */
    .flip-item-info {
        display: flex;
        flex-direction: column;
        min-width: 0;  /* Allow text truncation if needed */
    }

</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <div class="page-header-icon">
        <svg fill="currentColor" viewBox="0 0 20 20">
            <path
                d="M10 2a1 1 0 011 1v1.323l.956.285a4.5 4.5 0 012.626 2.02 1 1 0 01-1.724 1.016 2.5 2.5 0 00-1.46-1.123L11 6.4V10l.956.285a4.5 4.5 0 01-.001 8.48l-.955.285V20a1 1 0 11-2 0v-.95l-.956-.285a4.5 4.5 0 01-2.626-2.02 1 1 0 011.724-1.016 2.5 2.5 0 001.46 1.123l.398.118V13l-.956-.285a4.5 4.5 0 01.001-8.48L9 4.05V3a1 1 0 011-1zm1 8.79V6.4l.398.118a2.5 2.5 0 010 4.723L11 10.79zm-2 .42l-.398-.118a2.5 2.5 0 010-4.723L9 6.25v3.96zm0 2.54v3.96l-.398-.118a2.5 2.5 0 010-4.723L9 11.75zm2 .46l.398.118a2.5 2.5 0 010 4.723L11 17.17v-3.96z" />
        </svg>
    </div>
    <div class="page-header-text">
        <h1>My Flips</h1>
        <p>Track your Grand Exchange flipping profits. Click on an item to get the list of individual flips for that item.</p>
    </div>
</div>

<div class="stats-row loading" id="statsRow">
    <div class="stat-card" data-tone="info" id="statUnrealized">
        <span class="stat-label">Unrealized Net</span>
        <span class="stat-value pnl-zero" id="statUnrealizedValue">-- gp</span>
    </div>
    <div class="stat-card" data-tone="info" id="statRealized">
        <span class="stat-label">Realized Net</span>
        <span class="stat-value pnl-zero" id="statRealizedValue">-- gp</span>
    </div>
    <div class="stat-card" data-tone="info" id="statPosition">
        <span class="stat-label">Position Size</span>
        <span class="stat-value" id="statPositionValue">-- gp</span>
    </div>
</div>


<div class="controls-container">
    <div class="d-flex gap-3 align-items-center buttons-row">
        <button type="button" class="btn-new-flip" data-bs-toggle="modal" data-bs-target="#newFlipModal">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
            New Flip
        </button>
        <button type="button" class="btn-delete-flip" id="deleteFlipBtn">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
            Delete Flip
        </button>
    </div>
    <div class="d-flex gap-2 align-items-center search-filter-row">
        <!-- Desktop sort indicator (inline with search/filter) -->
        <div class="sort-indicator-wrapper desktop-sort">
            <div class="sort-indicator" id="sortIndicator">
                <span class="sort-indicator-label">Sorted by:</span>
                <span class="sort-indicator-value" id="sortIndicatorValue">Time Held</span>
                <span class="sort-indicator-arrow" id="sortIndicatorArrow" title="Toggle sort order">↓</span>
            </div>
            <div class="sort-indicator-menu" id="sortIndicatorMenu">
                <div class="filter-dropdown-header">Sort by</div>
                <div id="sortIndicatorOptions"></div>
            </div>
        </div>
        <div class="filter-search-wrapper" id="filterSearchWrapper">
            <input type="text" class="filter-search-input" id="filterSearchInput" placeholder="Search...">
            <button type="button" class="filter-search-clear" id="filterSearchClear">&times;</button>
        </div>
        <!-- Historical View Button -->
        <!-- What: Button to open the Historical View modal for viewing past portfolio performance -->
        <!-- Why: Allows users to see what their unrealized P&L would have been at a past date -->
        <!-- How: Triggers modal with date picker and presets, fetches historical prices from API -->
        <button type="button" class="btn-historical" id="historicalViewBtn" data-bs-toggle="modal" data-bs-target="#historicalModal">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            Historical
        </button>
        <div class="filter-sort-group">
            <div class="filter-dropdown-wrapper">
                <button type="button" class="btn-filter" id="filterDropdownBtn">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
                    </svg>
                    Filters
                    <span class="filter-badge" id="filterBadge" style="display: none;">0</span>
                </button>
                <div class="filter-dropdown-menu" id="filterDropdownMenu">
                    <div class="filter-dropdown-header">Filter by</div>
                    <div class="filter-dropdown-item" data-filter="position-size">
                        <span>Position Size</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="quantity">
                        <span>Quantity</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="realized-range">
                        <span>Realized</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="time-held">
                        <span>Time Held</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="unrealized-range">
                        <span>Unrealized</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-item" data-filter="completion-state">
                        <span>Completion</span>
                        <span class="filter-check">✓</span>
                        <span class="filter-clear" title="Clear filter">×</span>
                    </div>
                    <div class="filter-dropdown-divider" id="sortByDivider" style="display: none;"></div>
                    <div class="filter-dropdown-section" id="sortBySection" style="display: none;">Sort by</div>
                    <div id="sortByOptions"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Mobile sort indicator row (shown below search/filter on mobile) -->
    <div class="sort-indicator-mobile-row" id="sortIndicatorMobileRow">
        <div class="sort-indicator" id="sortIndicatorMobile">
            <span class="sort-indicator-label">Sorted by:</span>
            <span class="sort-indicator-value" id="sortIndicatorValueMobile">Time Held</span>
            <span class="sort-indicator-arrow" id="sortIndicatorArrowMobile" title="Toggle sort order">↓</span>
        </div>
        <div class="active-filter-tags-mobile" id="activeFilterTagsMobile"></div>
    </div>
    <!-- Desktop filter tags row -->
    <div class="active-filter-tags-row" id="activeFilterTagsRow">
        <div class="active-filter-tags" id="activeFilterTags"></div>
    </div>
</div>

<!-- New Flip Modal -->
<div class="modal fade new-flip-modal" id="newFlipModal" tabindex="-1" aria-labelledby="newFlipModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newFlipModalLabel">New Flip</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form method="post" action="{% url 'add_flip' %}">
                {% csrf_token %}
                <div class="modal-body">
                    <div class="flip-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </div>

                    <div class="form-row">
                        <div class="form-group full-width autocomplete-wrapper">
                            <label for="itemName" class="form-label">Item Name</label>
                            <input type="text" class="form-control" id="itemName" name="item_name" autocomplete="off"
                                placeholder="Search for an item..." required>
                            <div class="autocomplete-results" id="autocompleteResults"></div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="price" class="form-label">Price</label>
                            <input type="number" class="form-control" id="price" name="price" placeholder="0" required>
                        </div>
                        <div class="form-group">
                            <!-- Quantity Header: Contains label and Buy Limit button -->
                            <!-- What: Wrapper div that positions the label and button side by side -->
                            <!-- Why: Buy Limit button needs to be above the input but aligned with the label -->
                            <!-- How: Flexbox container with space-between alignment -->
                            <div class="quantity-header">
                                <label for="quantity" class="form-label">Quantity</label>
                                <!-- Buy Limit Button -->
                                <!-- What: Small button that auto-fills quantity with the item's GE buy limit -->
                                <!-- Why: QOL feature - saves user from having to look up buy limits manually -->
                                <!-- How: Fetches item data from API and populates the quantity input -->
                                <button type="button" 
                                        class="btn-buy-limit" 
                                        id="btnBuyLimit"
                                        disabled
                                        data-tooltip="Select an item first">
                                    <!-- Spinner SVG (hidden by default, shown during loading) -->
                                    <!-- What: Animated loading indicator -->
                                    <!-- Why: Shows user that API request is in progress -->
                                    <!-- How: CSS animation rotates the SVG when .loading class is added -->
                                    <svg class="spinner" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                        <circle cx="12" cy="12" r="10" stroke-dasharray="32" stroke-dashoffset="12"></circle>
                                    </svg>
                                    <span class="btn-text">Buy Limit</span>
                                </button>
                            </div>
                            <input type="number" class="form-control" id="quantity" name="quantity" placeholder="0"
                                required>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="date" class="form-label">Date</label>
                            <div class="date-input-wrapper">
                                <input type="datetime-local" class="form-control" id="date" name="date" required>
                                <button type="button" class="btn-now" id="setNowBtn"
                                    title="Set to current time">Now</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="type" class="form-label">Type</label>
                            <select class="form-select" id="type" name="type" required>
                                <option value="buy">Buy</option>
                                <option value="sell">Sell</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-cancel" data-bs-dismiss="modal">Cancel</button>
                    <button type="submit" class="btn-add-flip">Add Flip</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Time Held Filter Modal -->
<div class="modal fade filter-modal" id="timeHeldFilterModal" tabindex="-1" aria-labelledby="timeHeldFilterModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="timeHeldFilterModalLabel">Filter by Time Held</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </div>
                <p class="filter-description">Show items held for a specific range of days.</p>
                <div class="mb-3">
                    <label for="timeHeldMin" class="form-label">Minimum Days</label>
                    <input type="number" class="form-control" id="timeHeldMin" min="0" step="0.1"
                        placeholder="No minimum">
                </div>
                <div class="mb-3">
                    <label for="timeHeldMax" class="form-label">Maximum Days</label>
                    <input type="number" class="form-control" id="timeHeldMax" min="0" step="0.1"
                        placeholder="No maximum">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearTimeHeldFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyTimeHeldFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Unrealized Range Filter Modal -->
<div class="modal fade filter-modal" id="unrealizedRangeFilterModal" tabindex="-1"
    aria-labelledby="unrealizedRangeFilterModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="unrealizedRangeFilterModalLabel">Filter by Unrealized</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                    </svg>
                </div>
                <p class="filter-description">Show items with unrealized profit in a specific range.</p>
                <div class="mb-3">
                    <label for="unrealizedMin" class="form-label">Minimum</label>
                    <input type="number" class="form-control" id="unrealizedMin" placeholder="No minimum">
                </div>
                <div class="mb-3">
                    <label for="unrealizedMax" class="form-label">Maximum</label>
                    <input type="number" class="form-control" id="unrealizedMax" placeholder="No maximum">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearUnrealizedFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyUnrealizedFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Realized Range Filter Modal -->
<div class="modal fade filter-modal" id="realizedRangeFilterModal" tabindex="-1"
    aria-labelledby="realizedRangeFilterModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="realizedRangeFilterModalLabel">Filter by Realized</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </div>
                <p class="filter-description">Show items with realized profit in a specific range.</p>
                <div class="mb-3">
                    <label for="realizedMin" class="form-label">Minimum</label>
                    <input type="number" class="form-control" id="realizedMin" placeholder="No minimum">
                </div>
                <div class="mb-3">
                    <label for="realizedMax" class="form-label">Maximum</label>
                    <input type="number" class="form-control" id="realizedMax" placeholder="No maximum">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearRealizedFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyRealizedFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Position Size Filter Modal -->
<div class="modal fade filter-modal" id="positionSizeFilterModal" tabindex="-1"
    aria-labelledby="positionSizeFilterModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="positionSizeFilterModalLabel">Filter by Position Size</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z" />
                    </svg>
                </div>
                <p class="filter-description">Show items with position size (price × quantity) in a specific range.</p>
                <div class="mb-3">
                    <label for="positionSizeMin" class="form-label">Minimum</label>
                    <input type="number" class="form-control" id="positionSizeMin" placeholder="No minimum">
                </div>
                <div class="mb-3">
                    <label for="positionSizeMax" class="form-label">Maximum</label>
                    <input type="number" class="form-control" id="positionSizeMax" placeholder="No maximum">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearPositionSizeFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyPositionSizeFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Quantity Filter Modal -->
<div class="modal fade filter-modal" id="quantityFilterModal" tabindex="-1" aria-labelledby="quantityFilterModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quantityFilterModalLabel">Filter by Quantity</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
                    </svg>
                </div>
                <p class="filter-description">Show items with quantity holding in a specific range.</p>
                <div class="mb-3">
                    <label for="quantityMin" class="form-label">Minimum</label>
                    <input type="number" class="form-control" id="quantityMin" placeholder="No minimum">
                </div>
                <div class="mb-3">
                    <label for="quantityMax" class="form-label">Maximum</label>
                    <input type="number" class="form-control" id="quantityMax" placeholder="No maximum">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearQuantityFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyQuantityFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Completion Filter Modal -->
<div class="modal fade filter-modal completion-filter-modal" id="completionFilterModal" tabindex="-1"
    aria-labelledby="completionFilterModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="completionFilterModalLabel">Filter by Completion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="filter-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M5 13l4 4L19 7" />
                    </svg>
                </div>
                <p class="filter-description">Choose whether to show flips that are completed or still in progress.</p>
                <div class="completion-options">
                    <label class="completion-card">
                        <input type="radio" name="completionState" id="completionCompleted" value="completed">
                        <div>
                            <div class="completion-label">Completed</div>
                            <p class="completion-hint">Quantity held is exactly 0</p>
                        </div>
                    </label>
                    <label class="completion-card">
                        <input type="radio" name="completionState" id="completionUncompleted" value="uncompleted">
                        <div>
                            <div class="completion-label">Uncompleted</div>
                            <p class="completion-hint">Quantity held is more than 1</p>
                        </div>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-clear-filter" id="clearCompletionFilter">Clear</button>
                <button type="button" class="btn-apply-filter" id="applyCompletionFilter">Apply Filter</button>
            </div>
        </div>
    </div>
</div>

<!-- Success Notifications -->
<div id="notifications">
    {% if messages %}
    {% for message in messages %}
    <div class="success-notification">
        {{ message }}
        <button type="button" class="dismiss-btn" onclick="dismissNotification(this)">&times;</button>
    </div>
    {% endfor %}
    {% endif %}
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade delete-confirm-modal" id="deleteConfirmModal" tabindex="-1"
    aria-labelledby="deleteConfirmModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteConfirmModalLabel">Confirm Delete</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="delete-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                </div>
                <p>Are you sure you want to delete all flips for</p>
                <p class="item-name" id="deleteItemName"></p>
                <p class="text-muted" style="font-size: 13px; margin-top: 0.5rem;">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-cancel" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn-confirm-delete" id="confirmDeleteBtn">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Historical View Modal -->
<!-- What: Modal for selecting a historical date to view past portfolio performance -->
<!-- Why: Allows users to see what their unrealized P&L would have been at a specific date -->
<!-- How: User selects date via picker or preset, submits to fetch historical prices from API -->
<div class="modal fade historical-modal" id="historicalModal" tabindex="-1" aria-labelledby="historicalModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-header-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </div>
                <h5 class="modal-title" id="historicalModalLabel">Historical View</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="historical-description">
                    View your portfolio's unrealized P&L as it would have been on a past date.
                    Select a date below or use one of the quick presets.
                </p>
                
                <!-- Date Picker -->
                <div class="historical-date-picker">
                    <label for="historicalDateInput" class="form-label">Select Date</label>
                    <input type="date" class="form-control historical-date-input" id="historicalDateInput">
                </div>
                
                <!-- Quick Presets -->
                <!-- What: Buttons for common historical time periods -->
                <!-- Why: Saves users from manually calculating dates for common lookback periods -->
                <!-- How: Each button calculates the date X days ago and sets the date picker -->
                <div class="historical-presets">
                    <span class="presets-label">Quick Presets:</span>
                    <div class="preset-buttons">
                        <button type="button" class="btn-preset" data-days="1">Day</button>
                        <button type="button" class="btn-preset" data-days="7">Week</button>
                        <button type="button" class="btn-preset" data-days="30">Month</button>
                        <button type="button" class="btn-preset" data-days="90">Quarter</button>
                        <button type="button" class="btn-preset" data-days="180">6 Months</button>
                        <button type="button" class="btn-preset" data-days="365">Year</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-cancel-historical" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn-view-historical" id="submitHistoricalView">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                    View Historical Data
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Historical View Banner -->
<!-- What: Prominent banner indicating the user is viewing historical (not real-time) data -->
<!-- Why: Users must clearly understand they're not seeing current prices to avoid confusion -->
<!-- How: Shows the historical date and provides a quick button to return to real-time view -->
<div class="historical-banner" id="historicalBanner" style="display: none;">
    <div class="historical-banner-content">
        <div class="historical-banner-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </div>
        <div class="historical-banner-text">
            <span class="historical-banner-label">VIEWING HISTORICAL DATA</span>
            <span class="historical-banner-date" id="historicalBannerDate">--</span>
        </div>
        <button type="button" class="btn-return-realtime" id="returnToRealtimeBtn">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            Return to Real-Time
        </button>
    </div>
</div>

<table class="table" id="flipsTable">
    <thead>
        <tr>
            <th class="sortable" data-col="0" data-type="string">Item <span class="sort-icon"></span></th>
            <th class="sortable" data-col="1" data-type="number">Price Paid<span class="sort-icon"></span></th>
            <th class="sortable" data-col="2" data-type="number"><span class="d-none d-md-inline">Quantity
                    Holding</span><span class="d-md-none">Qty</span> <span class="sort-icon"></span></th>
            <th class="sortable" data-col="3" data-type="number"><span class="d-none d-md-inline">Position
                    Size</span><span class="d-md-none">Pos.</span> <span class="sort-icon"></span></th>
            <th class="sortable" data-col="4" data-type="number">High Price <span class="sort-icon"></span></th>
            <th class="sortable" data-col="5" data-type="number">Low Price <span class="sort-icon"></span></th>
            <th class="sortable" data-col="6" data-type="number"><span class="d-none d-md-inline">Unrealized
                    Net</span><span class="d-md-none">Unreal.</span> <span class="sort-icon"></span></th>
            <th class="sortable" data-col="7" data-type="number"><span class="d-none d-md-inline">Realized
                    Net</span><span class="d-md-none">Real.</span> <span class="sort-icon"></span></th>
        </tr>
    </thead>
    <tbody id="flipsTableBody">
        <!-- Skeleton loading rows - shown while data loads -->
        <tr class="skeleton-row">
            <td colspan="8" class="text-center" style="padding: 20px; color: var(--muted);">
                <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <div class="spinner-border spinner-border-sm" role="status" style="color: var(--primary);"></div>
                    <span>Loading flip data...</span>
                </div>
            </td>
        </tr>
    </tbody>
</table>

{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        // =========================================================================
        // PROGRESSIVE DATA LOADING
        // =========================================================================

        const timeFilter = '{{ time_filter }}';
        let flipsData = null;

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function formatNumberWithSign(num) {
            return (num >= 0 ? '+' : '') + Math.round(num).toLocaleString();
        }

        function getPnlClass(value) {
            if (value > 0) return 'pnl-pos';
            if (value < 0) return 'pnl-neg';
            return 'pnl-zero';
        }

        function updateStats(stats) {
            const statsRow = document.getElementById('statsRow');

            // Unrealized
            const unrealizedCard = document.getElementById('statUnrealized');
            const unrealizedValue = document.getElementById('statUnrealizedValue');
            unrealizedCard.dataset.tone = stats.total_unrealized >= 0 ? 'success' : 'danger';
            unrealizedValue.className = 'stat-value ' + getPnlClass(stats.total_unrealized);
            unrealizedValue.textContent = formatNumberWithSign(stats.total_unrealized) + ' gp';

            // Realized
            const realizedCard = document.getElementById('statRealized');
            const realizedValue = document.getElementById('statRealizedValue');
            realizedCard.dataset.tone = stats.total_realized >= 0 ? 'success' : 'danger';
            realizedValue.className = 'stat-value ' + getPnlClass(stats.total_realized);
            realizedValue.textContent = formatNumberWithSign(stats.total_realized) + ' gp';

            // Position Size
            const positionValue = document.getElementById('statPositionValue');
            positionValue.textContent = formatNumber(stats.position_size) + ' gp';

            // Remove loading state
            statsRow.classList.remove('loading');
            statsRow.classList.add('fade-in');
        }

        /**
         * Renders the flip items into the table body.
         * 
         * What: Populates the flips table with item data including icons, prices, and P&L.
         * Why: Displays all user's flip positions in a sortable, interactive table.
         * How: Iterates through items array and builds HTML rows with icon, name, and data columns.
         * 
         * @param {Array} items - Array of flip item objects from the API containing:
         *   - item_id: Unique identifier for the item
         *   - name: Display name of the item
         *   - icon: Wiki image filename for the item (e.g., "Abyssal_whip.png")
         *   - avg_price, high_price, low_price: Price data
         *   - quantity_holding, position_size: Position metrics
         *   - unrealized_net, realized_net: Profit/loss values
         *   - first_buy_timestamp: Timestamp for time-held calculations
         */
        function renderTableRows(items) {
            const tbody = document.getElementById('flipsTableBody');

            if (items.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center">No flips recorded yet.</td></tr>';
                return;
            }

            let html = '';
            items.forEach(item => {
                // Build icon HTML - use item image from OSRS Wiki if available, otherwise show placeholder
                // The icon field contains the wiki filename (e.g., "Abyssal_whip.png")
                // We construct the full URL by encoding the filename and prepending the wiki images base URL
                let iconHtml;
                if (item.icon) {
                    // Construct the wiki image URL:
                    // - Replace spaces with underscores (wiki URL convention)
                    // - URL encode the filename to handle special characters
                    const iconUrl = 'https://oldschool.runescape.wiki/images/' + encodeURIComponent(item.icon.replace(/ /g, '_'));
                    iconHtml = '<img class="flip-icon" src="' + iconUrl + '" alt="" loading="lazy">';
                } else {
                    // Fallback placeholder when no icon is available - show a coin emoji
                    // This ensures consistent visual layout even without icons
                    iconHtml = '<span class="flip-icon-placeholder">🪙</span>';
                }
                
                html += `
            <tr data-item-id="${item.item_id}" data-item-name="${item.name}" data-first-buy="${item.first_buy_timestamp || ''}" data-position-size="${item.position_size}">
                <td>
                    <div class="flip-item-cell">
                        ${iconHtml}
                        <div class="flip-item-info">
                            <a href="/flips/item/${item.item_id}/">${item.name}</a>
                            <div class="time-held-subtext" style="display: none;"></div>
                            <div class="position-size-subtext" style="display: none;"></div>
                        </div>
                    </div>
                </td>
                <td data-value="${item.avg_price}">${formatNumber(item.avg_price)}</td>
                <td data-value="${item.quantity_holding}">${formatNumber(item.quantity_holding)}</td>
                <td data-value="${item.position_size}">${formatNumber(item.position_size)}</td>
                <td data-value="${item.high_price || 0}">${item.high_price ? formatNumber(item.high_price) : '-'}</td>
                <td data-value="${item.low_price || 0}">${item.low_price ? formatNumber(item.low_price) : '-'}</td>
                <td data-value="${item.unrealized_net}" class="${getPnlClass(item.unrealized_net)}">${formatNumberWithSign(item.unrealized_net)}</td>
                <td data-value="${item.realized_net}" class="${getPnlClass(item.realized_net)}">${formatNumberWithSign(item.realized_net)}</td>
            </tr>`;
            });

            tbody.innerHTML = html;
            tbody.classList.add('fade-in');

            // Apply mobile formatting after rendering
            applyMobileFormatting();

            // Re-initialize sorting after data loads
            initTableSort();

            // Apply initial sort by time held
            triggerInitialSort();
        }

        function loadFlipsStats() {
            // Fast stats load - uses cached values, no external API calls
            fetch('/api/flips/stats/')
                .then(response => response.json())
                .then(stats => {
                    updateStats({
                        total_unrealized: stats.total_unrealized,
                        total_realized: stats.total_realized,
                        position_size: stats.position_size
                    });
                })
                .catch(error => {
                    console.error('Error loading flips stats:', error);
                });
        }

        /**
         * isHistoricalMode: Global flag to track if we're viewing historical data
         * Why: Prevents auto-refresh from overwriting historical data view
         * How: Set to true when viewing historical, false when returning to real-time
         */
        let isHistoricalMode = false;

        function loadFlipsData() {
            // Skip loading if in historical mode (don't overwrite historical data)
            if (isHistoricalMode) {
                return;
            }

            const url = '/api/flips/data/' + (timeFilter !== 'current' ? '?filter=' + timeFilter : '');

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    flipsData = data;
                    // Update stats again with fresh values (recalculated with live prices)
                    updateStats(data.stats);
                    renderTableRows(data.items);
                })
                .catch(error => {
                    console.error('Error loading flips data:', error);
                    document.getElementById('flipsTableBody').innerHTML =
                        '<tr><td colspan="8" class="text-center text-danger">Error loading data. Please refresh the page.</td></tr>';
                });
        }

        // Load stats instantly (cached values), then load full data
        loadFlipsStats();
        loadFlipsData();

        // Auto-refresh data every 5 minutes (instead of page reload)
        setInterval(loadFlipsData, 5 * 60 * 1000);

        // =========================================================================
        // MOBILE NUMBER FORMATTING
        // =========================================================================

        function formatNumberMobile(num) {
            const absNum = Math.abs(num);
            const sign = num < 0 ? '-' : (num > 0 ? '+' : '');

            if (absNum >= 1000000) {
                // Millions - use 1 decimal
                return sign + (absNum / 1000000).toFixed(1) + 'M';
            } else if (absNum >= 1000) {
                // Thousands - no decimal
                return sign + Math.floor(absNum / 1000) + 'K';
            } else {
                return sign + absNum;
            }
        }

        function formatNumberMobileNoSign(num) {
            const absNum = Math.abs(num);

            if (absNum >= 1000000) {
                return (absNum / 1000000).toFixed(1) + 'M';
            } else if (absNum >= 1000) {
                return Math.floor(absNum / 1000) + 'K';
            } else {
                return absNum.toLocaleString();
            }
        }

        function applyMobileFormatting() {
            const isMobile = window.innerWidth <= 1100;
            const rows = document.querySelectorAll('#flipsTable tbody tr[data-item-id]');

            rows.forEach(row => {
                // Position Size (column 4)
                const posCell = row.querySelector('td:nth-child(4)');
                if (posCell) {
                    const value = parseFloat(posCell.dataset.value) || 0;
                    posCell.textContent = isMobile ? formatNumberMobileNoSign(value) : value.toLocaleString();
                }

                // Unrealized Net (column 7)
                const unrealCell = row.querySelector('td:nth-child(7)');
                if (unrealCell) {
                    const value = parseFloat(unrealCell.dataset.value) || 0;
                    if (isMobile) {
                        unrealCell.textContent = formatNumberMobile(value);
                    } else {
                        unrealCell.textContent = (value >= 0 ? '+' : '') + Math.round(value).toLocaleString();
                    }
                }

                // Realized Net (column 8)
                const realCell = row.querySelector('td:nth-child(8)');
                if (realCell) {
                    const value = parseFloat(realCell.dataset.value) || 0;
                    if (isMobile) {
                        realCell.textContent = formatNumberMobile(value);
                    } else {
                        realCell.textContent = (value >= 0 ? '+' : '') + Math.round(value).toLocaleString();
                    }
                }
            });
        }

        // Apply on load and resize
        applyMobileFormatting();
        window.addEventListener('resize', applyMobileFormatting);

        // =========================================================================
        // FILTER SYSTEM
        // =========================================================================

        const activeFilters = {};
        let currentSortFilter = null;
        let sortAscending = false; // Default descending
        let columnSortActive = false; // Track if column header sort is active

        const filterDropdownBtn = document.getElementById('filterDropdownBtn'); // What: main filter button; Why: opens filter dropdown; How: DOM lookup by id.
        const filterDropdownMenu = document.getElementById('filterDropdownMenu'); // What: filter dropdown menu; Why: houses filter options; How: DOM lookup.
        const filterBadge = document.getElementById('filterBadge'); // What: badge showing active filter count; Why: UX indicator; How: DOM lookup.
        const tableBody = document.querySelector('#flipsTable tbody'); // What: flips table body; Why: render and filter rows; How: querySelector.
        const sortIndicator = document.getElementById('sortIndicator'); // What: desktop sort indicator; Why: shows current sort; How: DOM lookup.
        const sortIndicatorValue = document.getElementById('sortIndicatorValue'); // What: sort label; Why: display sort criteria; How: DOM lookup.
        const sortIndicatorArrow = document.getElementById('sortIndicatorArrow'); // What: sort direction arrow; Why: toggle asc/desc; How: DOM lookup.
        const sortIndicatorMenu = document.getElementById('sortIndicatorMenu'); // What: sort dropdown; Why: choose filter sort; How: DOM lookup.
        const sortIndicatorOptions = document.getElementById('sortIndicatorOptions'); // What: sort options container; Why: renders sort choices; How: DOM lookup.
        const sortByDivider = document.getElementById('sortByDivider'); // What: divider inside filter dropdown; Why: separates filter and sort; How: DOM lookup.
        const sortBySection = document.getElementById('sortBySection'); // What: sort section label; Why: UX clarity; How: DOM lookup.
        const sortByOptions = document.getElementById('sortByOptions'); // What: container for sort options in dropdown; Why: renders list; How: DOM lookup.

        // Mobile sort indicator elements
        const sortIndicatorMobileRow = document.getElementById('sortIndicatorMobileRow'); // What: mobile sort row; Why: show sort on small screens; How: DOM lookup.
        const sortIndicatorMobile = document.getElementById('sortIndicatorMobile'); // What: mobile sort pill; Why: show sort label; How: DOM lookup.
        const sortIndicatorValueMobile = document.getElementById('sortIndicatorValueMobile'); // What: mobile sort value; Why: mirrors desktop; How: DOM lookup.
        const sortIndicatorArrowMobile = document.getElementById('sortIndicatorArrowMobile'); // What: mobile sort arrow; Why: toggle direction; How: DOM lookup.

        // Filter tags elements
        const activeFilterTagsRow = document.getElementById('activeFilterTagsRow'); // What: desktop tags row; Why: show active filters; How: DOM lookup.
        const activeFilterTags = document.getElementById('activeFilterTags'); // What: desktop tags container; Why: list active filters; How: DOM lookup.
        const activeFilterTagsMobile = document.getElementById('activeFilterTagsMobile'); // What: mobile tags container; Why: show active filters on mobile; How: DOM lookup.

        // Filter label mappings
        const filterLabels = {
            'time-held': 'Time Held',
            'unrealized-range': 'Unrealized',
            'realized-range': 'Realized',
            'position-size': 'Position Size',
            'quantity': 'Quantity',
            'completion-state': 'Completion'
        };

        // Modal elements - declare early so click handlers can access them
        const timeHeldModal = document.getElementById('timeHeldFilterModal'); // What: modal for time-held filter input; Why: allows bounds input; How: DOM lookup.
        const timeHeldMin = document.getElementById('timeHeldMin'); // What: minimum days input; Why: lower bound for time held; How: DOM lookup.
        const timeHeldMax = document.getElementById('timeHeldMax'); // What: maximum days input; Why: upper bound for time held; How: DOM lookup.
        const unrealizedModal = document.getElementById('unrealizedRangeFilterModal'); // What: modal for unrealized filter; Why: capture unrealized bounds; How: DOM lookup.
        const unrealizedMin = document.getElementById('unrealizedMin'); // What: minimum unrealized input; Why: lower bound; How: DOM lookup.
        const unrealizedMax = document.getElementById('unrealizedMax'); // What: maximum unrealized input; Why: upper bound; How: DOM lookup.
        const realizedModal = document.getElementById('realizedRangeFilterModal'); // What: modal for realized filter; Why: capture realized bounds; How: DOM lookup.
        const realizedMin = document.getElementById('realizedMin'); // What: minimum realized input; Why: lower bound; How: DOM lookup.
        const realizedMax = document.getElementById('realizedMax'); // What: maximum realized input; Why: upper bound; How: DOM lookup.
        const positionSizeModal = document.getElementById('positionSizeFilterModal'); // What: modal for position size filter; Why: bounds on position size; How: DOM lookup.
        const positionSizeMin = document.getElementById('positionSizeMin'); // What: minimum position size input; Why: lower bound; How: DOM lookup.
        const positionSizeMax = document.getElementById('positionSizeMax'); // What: maximum position size input; Why: upper bound; How: DOM lookup.
        const quantityModal = document.getElementById('quantityFilterModal'); // What: modal for quantity filter; Why: bounds on quantity held; How: DOM lookup.
        const quantityMin = document.getElementById('quantityMin'); // What: minimum quantity input; Why: lower bound; How: DOM lookup.
        const quantityMax = document.getElementById('quantityMax'); // What: maximum quantity input; Why: upper bound; How: DOM lookup.
        const completionModal = document.getElementById('completionFilterModal'); // What: modal for completion filter; Why: pick completed vs uncompleted; How: DOM lookup.
        const completionCompleted = document.getElementById('completionCompleted'); // What: radio for completed flips; Why: set filter to completed; How: DOM lookup.
        const completionUncompleted = document.getElementById('completionUncompleted'); // What: radio for uncompleted flips; Why: set filter to uncompleted; How: DOM lookup.

        const filterDisplayNames = {
            'position-size': 'Position Size',
            'quantity': 'Quantity',
            'realized-range': 'Realized',
            'time-held': 'Time Held',
            'unrealized-range': 'Unrealized',
            'completion-state': 'Completion'
        };

        if (!filterDropdownBtn || !filterDropdownMenu) {
            console.error('Filter elements not found!');
        }

        // Sort table alphabetically by item name
        function sortTableAlphabetically() {
            const rows = Array.from(tableBody.querySelectorAll('tr[data-item-name]'));
            rows.sort((a, b) => {
                const nameA = a.dataset.itemName.toLowerCase();
                const nameB = b.dataset.itemName.toLowerCase();
                return nameA.localeCompare(nameB);
            });
            rows.forEach(row => tableBody.appendChild(row));
        }

        // Function to trigger initial sort (called after data loads via AJAX)
        function triggerInitialSort() {
            sortTableAlphabetically();
        }

        // Function to re-initialize table sorting (called after data loads via AJAX)
        // Note: Column header event listeners are set up once on DOMContentLoaded
        // This function exists for any post-load cleanup if needed
        function initTableSort() {
            // Headers already have event listeners from initial setup
            // Just ensure any filter state is consistent
        }

        // Make functions globally accessible for AJAX callbacks
        window.triggerInitialSort = triggerInitialSort;
        window.initTableSort = initTableSort;

        // Function to clear column header sort styling
        function clearColumnSortStyling() {
            const headers = document.querySelectorAll('#flipsTable th.sortable');
            headers.forEach(h => h.classList.remove('asc', 'desc'));
        }

        // Function to deactivate filter sort (called when column header is clicked)
        function deactivateFilterSort() {
            columnSortActive = true;
            currentSortFilter = null;
            sortIndicator.classList.remove('active');
            sortIndicatorMenu.classList.remove('show');
            syncMobileSortIndicator();
            updateSortByOptions();
        }

        // Sync mobile sort indicator with desktop
        function syncMobileSortIndicator() {
            // Sync active state - mobile row only shows when sort is active
            if (sortIndicator.classList.contains('active')) {
                sortIndicatorMobileRow.classList.add('active');
            } else {
                sortIndicatorMobileRow.classList.remove('active');
            }
            // Sync content
            sortIndicatorValueMobile.textContent = sortIndicatorValue.textContent;
            sortIndicatorArrowMobile.textContent = sortIndicatorArrow.textContent;
            // Copy flash animation
            if (sortIndicator.classList.contains('flash')) {
                sortIndicatorMobile.classList.add('flash');
            } else {
                sortIndicatorMobile.classList.remove('flash');
            }
        }

        // Function to activate filter sort (called when filter sort is selected)
        function activateFilterSort(filterName) {
            columnSortActive = false;
            currentSortFilter = filterName;
            clearColumnSortStyling();
            updateSortByOptions();
            sortTableByFilter();
        }

        // Format time held in human-readable format
        function formatTimeHeld(seconds) {
            if (seconds < 0) return 'N/A';

            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(seconds / 3600);
            const days = Math.floor(seconds / 86400);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);

            if (seconds < 3600) {
                return minutes === 1 ? '1 minute' : `${minutes} minutes`;
            } else if (seconds < 86400) {
                const remainingMins = minutes % 60;
                if (remainingMins > 0) {
                    return hours === 1 ? `1 hour and ${remainingMins} min` : `${hours} hours and ${remainingMins} min`;
                }
                return hours === 1 ? '1 hour' : `${hours} hours`;
            } else if (days < 14) {
                const remainingHours = hours % 24;
                if (remainingHours > 0 && days < 7) {
                    return days === 1 ? `1 day and ${remainingHours} hr` : `${days} days and ${remainingHours} hr`;
                }
                return days === 1 ? '1 day' : `${days} days`;
            } else if (days < 60) {
                const remainingDays = days % 7;
                if (remainingDays > 0) {
                    return weeks === 1 ? `1 week and ${remainingDays} day${remainingDays > 1 ? 's' : ''}` : `${weeks} weeks and ${remainingDays} day${remainingDays > 1 ? 's' : ''}`;
                }
                return weeks === 1 ? '1 week' : `${weeks} weeks`;
            } else {
                const remainingDays = days % 30;
                if (remainingDays > 0) {
                    return months === 1 ? `1 month and ${remainingDays} day${remainingDays > 1 ? 's' : ''}` : `${months} months and ${remainingDays} day${remainingDays > 1 ? 's' : ''}`;
                }
                return months === 1 ? '1 month' : `${months} months`;
            }
        }

        // Calculate time held in days for a row
        function getTimeHeldDays(row) {
            const firstBuy = row.dataset.firstBuy;
            if (!firstBuy) return null;
            const now = Date.now() / 1000;
            const seconds = now - parseFloat(firstBuy);
            return seconds / 86400;
        }

        // Get sort value for a row based on filter type
        function getSortValue(row, filterName) {
            if (filterName === 'time-held') {
                return getTimeHeldDays(row) || 0;
            } else if (filterName === 'unrealized-range') {
                const cell = row.querySelector('td:nth-child(7)');
                return parseFloat(cell?.dataset.value) || 0;
            } else if (filterName === 'realized-range') {
                const cell = row.querySelector('td:nth-child(8)');
                return parseFloat(cell?.dataset.value) || 0;
            } else if (filterName === 'position-size') {
                const cell = row.querySelector('td:nth-child(4)');
                return parseFloat(cell?.dataset.value) || 0;
            } else if (filterName === 'quantity') {
                const cell = row.querySelector('td:nth-child(3)');
                return parseFloat(cell?.dataset.value) || 0;
            } else if (filterName === 'completion-state') {
                const cell = row.querySelector('td:nth-child(3)');
                return parseFloat(cell?.dataset.value) || 0;
            }
            return 0;
        }

        // Sort the table by current sort filter
        function sortTableByFilter() {
            if (!currentSortFilter) return;

            const rows = Array.from(tableBody.querySelectorAll('tr[data-item-name]'));

            rows.sort((a, b) => {
                const valA = getSortValue(a, currentSortFilter);
                const valB = getSortValue(b, currentSortFilter);
                return sortAscending ? valA - valB : valB - valA;
            });

            rows.forEach(row => tableBody.appendChild(row));
        }

        // Update sort-by options in dropdown
        function updateSortByOptions() {
            const filterKeys = Object.keys(activeFilters);

            if (filterKeys.length === 0) {
                sortByDivider.style.display = 'none';
                sortBySection.style.display = 'none';
                sortByOptions.innerHTML = '';
                sortIndicator.classList.remove('active');
                sortIndicator.classList.remove('clickable');
                sortIndicatorOptions.innerHTML = '';
                currentSortFilter = null;
                // Sort alphabetically when all filters cleared
                if (!columnSortActive) {
                    sortTableAlphabetically();
                }
                syncMobileSortIndicator();
                return;
            }

            // Show sort section in filter dropdown
            sortByDivider.style.display = 'block';
            sortBySection.style.display = 'block';

            // Only show sort indicator if column sort is not active
            if (!columnSortActive) {
                sortIndicator.classList.add('active');

                // Make clickable only if more than one filter
                if (filterKeys.length > 1) {
                    sortIndicator.classList.add('clickable');
                } else {
                    sortIndicator.classList.remove('clickable');
                }

                // If no current sort or current sort filter was removed, use first filter
                const previousSort = currentSortFilter;
                if (!currentSortFilter || !activeFilters[currentSortFilter]) {
                    currentSortFilter = filterKeys[0];
                }

                // Flash the indicator when sort changes or first activates
                if (previousSort !== currentSortFilter || !previousSort) {
                    sortIndicator.classList.remove('flash');
                    void sortIndicator.offsetWidth;
                    sortIndicator.classList.add('flash');
                }

                // Update sort indicator text
                sortIndicatorValue.textContent = filterDisplayNames[currentSortFilter];
                sortIndicatorArrow.textContent = sortAscending ? '↑' : '↓';

                // Build sort indicator dropdown options
                sortIndicatorOptions.innerHTML = filterKeys.map(filterName => `
                <div class="sort-by-item ${filterName === currentSortFilter ? 'active' : ''}" data-sort="${filterName}">
                    <span>${filterDisplayNames[filterName]}</span>
                </div>
            `).join('');

                // Add click handlers for sort indicator dropdown
                sortIndicatorOptions.querySelectorAll('.sort-by-item').forEach(item => {
                    item.addEventListener('click', function (e) {
                        e.stopPropagation();
                        const newSort = this.dataset.sort;
                        if (newSort !== currentSortFilter) {
                            currentSortFilter = newSort;
                            sortIndicator.classList.remove('flash');
                            void sortIndicator.offsetWidth;
                            sortIndicator.classList.add('flash');
                            clearColumnSortStyling();
                            updateSortByOptions();
                            sortTableByFilter();
                        }
                        sortIndicatorMenu.classList.remove('show');
                    });
                });
            } else {
                sortIndicator.classList.remove('active');
                sortIndicator.classList.remove('clickable');
            }

            // Build sort-by options in filter dropdown (show none selected if column sort active)
            sortByOptions.innerHTML = filterKeys.map(filterName => `
            <div class="sort-by-item ${!columnSortActive && filterName === currentSortFilter ? 'active' : ''}" data-sort="${filterName}">
                <span>${filterDisplayNames[filterName]}</span>
                <span class="sort-radio"></span>
            </div>
        `).join('');

            // Add click handlers for filter dropdown sort options
            sortByOptions.querySelectorAll('.sort-by-item').forEach(item => {
                item.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const newSort = this.dataset.sort;
                    columnSortActive = false;
                    currentSortFilter = newSort;
                    sortIndicator.classList.remove('flash');
                    void sortIndicator.offsetWidth;
                    sortIndicator.classList.add('flash');
                    clearColumnSortStyling();
                    updateSortByOptions();
                    sortTableByFilter();
                    filterDropdownMenu.classList.remove('show');
                });
            });

            // Sync mobile sort indicator
            syncMobileSortIndicator();
        }

        // Update filter badge and button state
        function updateFilterUI() {
            const count = Object.keys(activeFilters).length;
            if (count > 0) {
                filterBadge.textContent = count;
                filterBadge.style.display = 'inline';
                filterDropdownBtn.classList.add('has-active');
            } else {
                filterBadge.style.display = 'none';
                filterDropdownBtn.classList.remove('has-active');
            }

        // Update dropdown item states
        document.querySelectorAll('.filter-dropdown-item').forEach(item => {
            const filterName = item.dataset.filter;
            if (activeFilters[filterName]) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });

        // Update filter tags
        updateFilterTags();

        updateSortByOptions();
    }

        // Format filter value for display
        function formatFilterValue(filterName, filterData) {
            // Handle completion filter separately (boolean-like choice)
            if (filterName === 'completion-state') {
                return filterData === 'completed' ? 'Completed' : 'Uncompleted';
            }

            const {min, max} = filterData;

            // Format number based on filter type
            const formatNum = (n) => {
                if (n === null) return null;
                return n.toLocaleString();
            };

            // Add unit suffix based on filter type
            const getUnit = () => {
                if (filterName === 'time-held') return ' days';
                return '';
            };
            const unit = getUnit();

            if (min !== null && max !== null) {
                return `${formatNum(min)} - ${formatNum(max)}${unit}`;
            } else if (min !== null) {
                return `≥ ${formatNum(min)}${unit}`;
            } else if (max !== null) {
                return `≤ ${formatNum(max)}${unit}`;
            }
            return '';
        }

        // Render filter tags
        function updateFilterTags() {
            const filterKeys = Object.keys(activeFilters);

            // Desktop filter tags
            if (activeFilterTags) {
                activeFilterTags.innerHTML = '';
                filterKeys.forEach(filterName => {
                    const label = filterLabels[filterName] || filterName;
                    const value = formatFilterValue(filterName, activeFilters[filterName]);
                    const tag = document.createElement('span');
                    tag.className = 'filter-tag';
                    tag.dataset.filter = filterName;
                    const displayValue = value || (filterName === 'completion-state' ? (activeFilters[filterName] === 'completed' ? 'Completed' : 'Uncompleted') : '');
                    tag.innerHTML = `${label}: ${displayValue}<button class="filter-tag-remove" title="Remove filter">&times;</button>`;
                    tag.querySelector('.filter-tag-remove').addEventListener('click', () => {
                        removeFilter(filterName);
                    });
                    activeFilterTags.appendChild(tag);

                });
            }

            // Mobile filter tags
            if (activeFilterTagsMobile) {
                activeFilterTagsMobile.innerHTML = '';
                filterKeys.forEach(filterName => {
                    const label = filterLabels[filterName] || filterName;
                    const value = formatFilterValue(filterName, activeFilters[filterName]);
                    const tag = document.createElement('span');
                    tag.className = 'filter-tag';
                    tag.dataset.filter = filterName;
                    const displayValue = value || (filterName === 'completion-state' ? (activeFilters[filterName] === 'completed' ? 'Completed' : 'Uncompleted') : '');
                    tag.innerHTML = `${label}: ${displayValue}<button class="filter-tag-remove" title="Remove filter">&times;</button>`;
                    tag.querySelector('.filter-tag-remove').addEventListener('click', () => {
                        removeFilter(filterName);
                    });
                    activeFilterTagsMobile.appendChild(tag);
                });
            }

            // Toggle row visibility
            if (activeFilterTagsRow) {
                if (filterKeys.length > 0) {
                    activeFilterTagsRow.classList.add('has-filters');
                } else {
                    activeFilterTagsRow.classList.remove('has-filters');
                }
            }

            if (sortIndicatorMobileRow) {
                if (filterKeys.length > 0) {
                    sortIndicatorMobileRow.classList.add('has-filters');
                } else {
                    sortIndicatorMobileRow.classList.remove('has-filters');
                }
            }
        }

        // Remove a filter by name
        function removeFilter(filterName) {
            delete activeFilters[filterName];
            updateFilterUI();
            applyFilters();
        }

        // Apply all active filters
        function applyFilters() {
            // Ensure sort filter is set before sorting (only if column sort not active)
            const filterKeys = Object.keys(activeFilters);
            if (!columnSortActive) {
                if (filterKeys.length > 0 && (!currentSortFilter || !activeFilters[currentSortFilter])) {
                    currentSortFilter = filterKeys[0];
                } else if (filterKeys.length === 0) {
                    currentSortFilter = null;
                }
            }

            const rows = tableBody.querySelectorAll('tr[data-item-name]');
            const timeHeldActive = activeFilters['time-held'];
            const unrealizedActive = activeFilters['unrealized-range'];
            const realizedActive = activeFilters['realized-range'];
            const positionSizeActive = activeFilters['position-size'];
            const quantityActive = activeFilters['quantity'];
            const completionActive = activeFilters['completion-state'];

            rows.forEach(row => {
                let show = true;
                const subtext = row.querySelector('.time-held-subtext');

                // Time held filter
                if (timeHeldActive) {
                    const daysHeld = getTimeHeldDays(row);
                    if (daysHeld === null) {
                        show = false;
                    } else {
                        const min = timeHeldActive.min !== null ? timeHeldActive.min : -Infinity;
                        const max = timeHeldActive.max !== null ? timeHeldActive.max : Infinity;
                        if (daysHeld < min || daysHeld > max) {
                            show = false;
                        }
                    }

                    if (subtext && daysHeld !== null) {
                        const seconds = daysHeld * 86400;
                        subtext.textContent = 'Held: ' + formatTimeHeld(seconds);
                        subtext.style.display = 'block';
                    }
                } else {
                    if (subtext) {
                        subtext.style.display = 'none';
                    }
                }

                // Unrealized range filter
                if (show && unrealizedActive) {
                    const cell = row.querySelector('td:nth-child(7)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    const min = unrealizedActive.min !== null ? unrealizedActive.min : -Infinity;
                    const max = unrealizedActive.max !== null ? unrealizedActive.max : Infinity;
                    if (value < min || value > max) {
                        show = false;
                    }
                }

                // Realized range filter
                if (show && realizedActive) {
                    const cell = row.querySelector('td:nth-child(8)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    const min = realizedActive.min !== null ? realizedActive.min : -Infinity;
                    const max = realizedActive.max !== null ? realizedActive.max : Infinity;
                    if (value < min || value > max) {
                        show = false;
                    }
                }

                // Position size filter
                if (show && positionSizeActive) {
                    const cell = row.querySelector('td:nth-child(4)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    const min = positionSizeActive.min !== null ? positionSizeActive.min : -Infinity;
                    const max = positionSizeActive.max !== null ? positionSizeActive.max : Infinity;
                    if (value < min || value > max) {
                        show = false;
                    }
                }

                // Show/hide position size subtext
                const positionSubtext = row.querySelector('.position-size-subtext');
                if (positionSizeActive && positionSubtext) {
                    const cell = row.querySelector('td:nth-child(4)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    positionSubtext.textContent = 'Position: ' + value.toLocaleString() + ' gp';
                    positionSubtext.style.display = 'block';
                } else if (positionSubtext) {
                    positionSubtext.style.display = 'none';
                }

                // Quantity filter
                if (show && quantityActive) {
                    const cell = row.querySelector('td:nth-child(3)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    const min = quantityActive.min !== null ? quantityActive.min : -Infinity;
                    const max = quantityActive.max !== null ? quantityActive.max : Infinity;
                    if (value < min || value > max) {
                        show = false;
                    }
                }

                // Completion filter (completed = quantity held == 0, uncompleted = quantity held > 1)
                if (show && completionActive) {
                    const cell = row.querySelector('td:nth-child(3)');
                    const value = parseFloat(cell?.dataset.value) || 0;
                    if (completionActive === 'completed' && value !== 0) {
                        show = false;
                    } else if (completionActive === 'uncompleted' && value <= 1) {
                        show = false;
                    }
                }

                row.style.display = show ? '' : 'none';
            });

            // Sort after filtering (only if column sort not active)
            if (!columnSortActive) {
                sortTableByFilter();
            }
        }

        // Toggle sort direction
        sortIndicatorArrow.addEventListener('click', function (e) {
            e.stopPropagation();
            sortAscending = !sortAscending;
            this.textContent = sortAscending ? '↑' : '↓';
            sortIndicatorArrowMobile.textContent = sortAscending ? '↑' : '↓';
            sortTableByFilter();
        });

        // Mobile sort indicator arrow - same behavior
        sortIndicatorArrowMobile.addEventListener('click', function (e) {
            e.stopPropagation();
            sortAscending = !sortAscending;
            sortIndicatorArrow.textContent = sortAscending ? '↑' : '↓';
            this.textContent = sortAscending ? '↑' : '↓';
            sortTableByFilter();
        });

        // Toggle sort indicator dropdown (only if multiple filters)
        sortIndicator.addEventListener('click', function (e) {
            // Don't trigger if clicking the arrow
            if (e.target === sortIndicatorArrow) return;

            const filterKeys = Object.keys(activeFilters);
            if (filterKeys.length > 1) {
                e.stopPropagation();
                sortIndicatorMenu.classList.toggle('show');
                filterDropdownMenu.classList.remove('show');
            }
        });

        // Prevent sort indicator menu from closing when clicking inside it
        sortIndicatorMenu.addEventListener('click', function (e) {
            e.stopPropagation();
        });

        // Toggle filter dropdown
        filterDropdownBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            filterDropdownMenu.classList.toggle('show');
            sortIndicatorMenu.classList.remove('show');
        });

        // Prevent dropdown from closing when clicking inside it
        filterDropdownMenu.addEventListener('click', function (e) {
            e.stopPropagation();
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', function () {
            filterDropdownMenu.classList.remove('show');
            sortIndicatorMenu.classList.remove('show');
        });

        // Handle filter item clicks
        document.querySelectorAll('.filter-dropdown-item').forEach(item => {
            item.addEventListener('click', function (e) {
                e.stopPropagation();
                const filterName = this.dataset.filter;

                // Check if clicking the clear button
                if (e.target.classList.contains('filter-clear')) {
                    delete activeFilters[filterName];
                    if (filterName === 'time-held') {
                        timeHeldMin.value = '';
                        timeHeldMax.value = '';
                    } else if (filterName === 'unrealized-range') {
                        unrealizedMin.value = '';
                        unrealizedMax.value = '';
                    } else if (filterName === 'realized-range') {
                        realizedMin.value = '';
                        realizedMax.value = '';
                    } else if (filterName === 'position-size') {
                        positionSizeMin.value = '';
                        positionSizeMax.value = '';
                    } else if (filterName === 'quantity') {
                        quantityMin.value = '';
                        quantityMax.value = '';
                    } else if (filterName === 'completion-state') {
                        completionCompleted.checked = false;
                        completionUncompleted.checked = false;
                    }
                    updateFilterUI();
                    applyFilters();
                    filterDropdownMenu.classList.remove('show');
                    return;
                }

                // Open appropriate modal
                if (filterName === 'time-held') {
                    const modal = new bootstrap.Modal(document.getElementById('timeHeldFilterModal'));
                    modal.show();
                } else if (filterName === 'unrealized-range') {
                    const modal = new bootstrap.Modal(document.getElementById('unrealizedRangeFilterModal'));
                    modal.show();
                } else if (filterName === 'realized-range') {
                    const modal = new bootstrap.Modal(document.getElementById('realizedRangeFilterModal'));
                    modal.show();
                } else if (filterName === 'position-size') {
                    const modal = new bootstrap.Modal(document.getElementById('positionSizeFilterModal'));
                    modal.show();
                } else if (filterName === 'quantity') {
                    const modal = new bootstrap.Modal(document.getElementById('quantityFilterModal'));
                    modal.show();
                } else if (filterName === 'completion-state') {
                    const modal = new bootstrap.Modal(document.getElementById('completionFilterModal'));
                    modal.show();
                }
                filterDropdownMenu.classList.remove('show');
            });
        });

        // Time held filter modal
        const applyTimeHeldBtn = document.getElementById('applyTimeHeldFilter');
        const clearTimeHeldBtn = document.getElementById('clearTimeHeldFilter');

        applyTimeHeldBtn.addEventListener('click', function () {
            const min = timeHeldMin.value !== '' ? parseFloat(timeHeldMin.value) : null;
            const max = timeHeldMax.value !== '' ? parseFloat(timeHeldMax.value) : null;

            activeFilters['time-held'] = {min, max};
            columnSortActive = false;
            currentSortFilter = 'time-held';
            clearColumnSortStyling();
            updateFilterUI();
            applyFilters();

            // Trigger flash animation
            sortIndicator.classList.remove('flash');
            void sortIndicator.offsetWidth;
            sortIndicator.classList.add('flash');
            syncMobileSortIndicator();

            bootstrap.Modal.getInstance(timeHeldModal).hide();
        });

        clearTimeHeldBtn.addEventListener('click', function () {
            delete activeFilters['time-held'];
            timeHeldMin.value = '';
            timeHeldMax.value = '';
            updateFilterUI();
            applyFilters();

            bootstrap.Modal.getInstance(timeHeldModal).hide();
        });

        timeHeldModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['time-held']) {
                timeHeldMin.value = activeFilters['time-held'].min !== null ? activeFilters['time-held'].min : '';
                timeHeldMax.value = activeFilters['time-held'].max !== null ? activeFilters['time-held'].max : '';
            }
        });

        // Unrealized range filter modal
        const applyUnrealizedBtn = document.getElementById('applyUnrealizedFilter');
        const clearUnrealizedBtn = document.getElementById('clearUnrealizedFilter');

        applyUnrealizedBtn.addEventListener('click', function () {
            const min = unrealizedMin.value !== '' ? parseFloat(unrealizedMin.value) : null;
            const max = unrealizedMax.value !== '' ? parseFloat(unrealizedMax.value) : null;

            activeFilters['unrealized-range'] = {min, max};
            columnSortActive = false;
            currentSortFilter = 'unrealized-range';
            clearColumnSortStyling();
            updateFilterUI();
            applyFilters();

            // Trigger flash animation
            sortIndicator.classList.remove('flash');
            void sortIndicator.offsetWidth;
            sortIndicator.classList.add('flash');
            syncMobileSortIndicator();

            bootstrap.Modal.getInstance(unrealizedModal).hide();
        });

        clearUnrealizedBtn.addEventListener('click', function () {
            delete activeFilters['unrealized-range'];
            unrealizedMin.value = '';
            unrealizedMax.value = '';
            updateFilterUI();
            applyFilters();

            bootstrap.Modal.getInstance(unrealizedModal).hide();
        });

        unrealizedModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['unrealized-range']) {
                unrealizedMin.value = activeFilters['unrealized-range'].min !== null ? activeFilters['unrealized-range'].min : '';
                unrealizedMax.value = activeFilters['unrealized-range'].max !== null ? activeFilters['unrealized-range'].max : '';
            }
        });

        // Realized range filter modal
        const applyRealizedBtn = document.getElementById('applyRealizedFilter');
        const clearRealizedBtn = document.getElementById('clearRealizedFilter');

        applyRealizedBtn.addEventListener('click', function () {
            const min = realizedMin.value !== '' ? parseFloat(realizedMin.value) : null;
            const max = realizedMax.value !== '' ? parseFloat(realizedMax.value) : null;

            activeFilters['realized-range'] = {min, max};
            columnSortActive = false;
            currentSortFilter = 'realized-range';
            clearColumnSortStyling();
            updateFilterUI();
            applyFilters();

            // Trigger flash animation
            sortIndicator.classList.remove('flash');
            void sortIndicator.offsetWidth;
            sortIndicator.classList.add('flash');
            syncMobileSortIndicator();

            bootstrap.Modal.getInstance(realizedModal).hide();
        });

        clearRealizedBtn.addEventListener('click', function () {
            delete activeFilters['realized-range'];
            realizedMin.value = '';
            realizedMax.value = '';
            updateFilterUI();
            applyFilters();

            bootstrap.Modal.getInstance(realizedModal).hide();
        });

        realizedModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['realized-range']) {
                realizedMin.value = activeFilters['realized-range'].min !== null ? activeFilters['realized-range'].min : '';
                realizedMax.value = activeFilters['realized-range'].max !== null ? activeFilters['realized-range'].max : '';
            }
        });

        // Position size filter modal
        const applyPositionSizeBtn = document.getElementById('applyPositionSizeFilter');
        const clearPositionSizeBtn = document.getElementById('clearPositionSizeFilter');

        applyPositionSizeBtn.addEventListener('click', function () {
            const min = positionSizeMin.value !== '' ? parseFloat(positionSizeMin.value) : null;
            const max = positionSizeMax.value !== '' ? parseFloat(positionSizeMax.value) : null;

            activeFilters['position-size'] = {min, max};
            columnSortActive = false;
            currentSortFilter = 'position-size';
            clearColumnSortStyling();
            updateFilterUI();
            applyFilters();

            // Trigger flash animation
            sortIndicator.classList.remove('flash');
            void sortIndicator.offsetWidth;
            sortIndicator.classList.add('flash');
            syncMobileSortIndicator();

            bootstrap.Modal.getInstance(positionSizeModal).hide();
        });

        clearPositionSizeBtn.addEventListener('click', function () {
            delete activeFilters['position-size'];
            positionSizeMin.value = '';
            positionSizeMax.value = '';
            updateFilterUI();
            applyFilters();

            bootstrap.Modal.getInstance(positionSizeModal).hide();
        });

        positionSizeModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['position-size']) {
                positionSizeMin.value = activeFilters['position-size'].min !== null ? activeFilters['position-size'].min : '';
                positionSizeMax.value = activeFilters['position-size'].max !== null ? activeFilters['position-size'].max : '';
            }
        });

        // Quantity filter modal
        const applyQuantityBtn = document.getElementById('applyQuantityFilter'); // What: apply button for quantity filter; Why: saves quantity bounds; How: DOM lookup.
        const clearQuantityBtn = document.getElementById('clearQuantityFilter'); // What: clear button for quantity filter; Why: resets quantity bounds; How: DOM lookup.

        applyQuantityBtn.addEventListener('click', function () {
            const min = quantityMin.value !== '' ? parseFloat(quantityMin.value) : null;
            const max = quantityMax.value !== '' ? parseFloat(quantityMax.value) : null;

            activeFilters['quantity'] = {min, max};
            columnSortActive = false;
            currentSortFilter = 'quantity';
            clearColumnSortStyling();
            updateFilterUI();
            applyFilters();

            // Trigger flash animation
            sortIndicator.classList.remove('flash');
            void sortIndicator.offsetWidth;
            sortIndicator.classList.add('flash');
            syncMobileSortIndicator();

            bootstrap.Modal.getInstance(quantityModal).hide();
        });

        clearQuantityBtn.addEventListener('click', function () {
            delete activeFilters['quantity'];
            quantityMin.value = '';
            quantityMax.value = '';
            updateFilterUI();
            applyFilters();

            bootstrap.Modal.getInstance(quantityModal).hide();
        });

        quantityModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['quantity']) {
                quantityMin.value = activeFilters['quantity'].min !== null ? activeFilters['quantity'].min : '';
                quantityMax.value = activeFilters['quantity'].max !== null ? activeFilters['quantity'].max : '';
            }
        });

        // Completion filter modal
        const applyCompletionBtn = document.getElementById('applyCompletionFilter'); // What: apply button for completion filter; Why: sets completion state filter; How: DOM lookup.
        const clearCompletionBtn = document.getElementById('clearCompletionFilter'); // What: clear button for completion filter; Why: removes completion filter; How: DOM lookup.

        applyCompletionBtn.addEventListener('click', function () {
            const state = completionCompleted.checked ? 'completed' : (completionUncompleted.checked ? 'uncompleted' : null);
            if (state) {
                activeFilters['completion-state'] = state;
                columnSortActive = false;
                currentSortFilter = 'completion-state';
                clearColumnSortStyling();
                updateFilterUI();
                applyFilters();

                sortIndicator.classList.remove('flash');
                void sortIndicator.offsetWidth;
                sortIndicator.classList.add('flash');
                syncMobileSortIndicator();
            }
            bootstrap.Modal.getInstance(completionModal).hide();
        });

        clearCompletionBtn.addEventListener('click', function () {
            delete activeFilters['completion-state'];
            completionCompleted.checked = false;
            completionUncompleted.checked = false;
            updateFilterUI();
            applyFilters();
            bootstrap.Modal.getInstance(completionModal).hide();
        });

        completionModal.addEventListener('show.bs.modal', function () {
            if (activeFilters['completion-state'] === 'completed') {
                completionCompleted.checked = true;
                completionUncompleted.checked = false;
            } else if (activeFilters['completion-state'] === 'uncompleted') {
                completionUncompleted.checked = true;
                completionCompleted.checked = false;
            } else {
                completionCompleted.checked = false;
                completionUncompleted.checked = false;
            }
        });

        // =========================================================================
        // TEXT SEARCH FILTER
        // =========================================================================

        const filterInput = document.getElementById('filterSearchInput'); // What: text input for searching flips; Why: allows quick filtering by item name; How: DOM lookup by id.
        const filterClear = document.getElementById('filterSearchClear'); // What: clear button for search; Why: lets users reset search quickly; How: DOM lookup by id.
        const filterWrapper = document.getElementById('filterSearchWrapper'); // What: wrapper controlling clear visibility; Why: toggles styling when input has value; How: DOM lookup by id.

        // Check if a row passes all active dropdown filters
        function passesDropdownFilters(row) {
            // Time held filter
            if (activeFilters['time-held']) {
                const daysHeld = getTimeHeldDays(row);
                if (daysHeld === null) return false;
                const min = activeFilters['time-held'].min !== null ? activeFilters['time-held'].min : -Infinity;
                const max = activeFilters['time-held'].max !== null ? activeFilters['time-held'].max : Infinity;
                if (daysHeld < min || daysHeld > max) return false;
            }

            // Unrealized range filter
            if (activeFilters['unrealized-range']) {
                const cell = row.querySelector('td:nth-child(7)');
                const value = parseFloat(cell?.dataset.value) || 0;
                const min = activeFilters['unrealized-range'].min !== null ? activeFilters['unrealized-range'].min : -Infinity;
                const max = activeFilters['unrealized-range'].max !== null ? activeFilters['unrealized-range'].max : Infinity;
                if (value < min || value > max) return false;
            }

            // Realized range filter
            if (activeFilters['realized-range']) {
                const cell = row.querySelector('td:nth-child(8)');
                const value = parseFloat(cell?.dataset.value) || 0;
                const min = activeFilters['realized-range'].min !== null ? activeFilters['realized-range'].min : -Infinity;
                const max = activeFilters['realized-range'].max !== null ? activeFilters['realized-range'].max : Infinity;
                if (value < min || value > max) return false;
            }

            // Position size filter
            if (activeFilters['position-size']) {
                const cell = row.querySelector('td:nth-child(4)');
                const value = parseFloat(cell?.dataset.value) || 0;
                const min = activeFilters['position-size'].min !== null ? activeFilters['position-size'].min : -Infinity;
                const max = activeFilters['position-size'].max !== null ? activeFilters['position-size'].max : Infinity;
                if (value < min || value > max) return false;
            }

            // Quantity filter
            if (activeFilters['quantity']) {
                const cell = row.querySelector('td:nth-child(3)');
                const value = parseFloat(cell?.dataset.value) || 0;
                const min = activeFilters['quantity'].min !== null ? activeFilters['quantity'].min : -Infinity;
                const max = activeFilters['quantity'].max !== null ? activeFilters['quantity'].max : Infinity;
                if (value < min || value > max) return false;
            }

                // Completion filter
            if (activeFilters['completion-state']) {
                const cell = row.querySelector('td:nth-child(3)');
                const value = parseFloat(cell?.dataset.value) || 0;
                const state = activeFilters['completion-state'];
                if (state === 'completed' && value !== 0) return false;
                if (state === 'uncompleted' && value <= 1) return false;
            }

            return true;
        }

        filterInput.addEventListener('input', function () {
            const query = this.value.toLowerCase().trim();

            // Toggle clear button visibility
            if (query.length > 0) {
                filterWrapper.classList.add('has-value');
            } else {
                filterWrapper.classList.remove('has-value');
            }

            // Filter table rows (combined with other filters)
            const rows = tableBody.querySelectorAll('tr[data-item-name]');
            rows.forEach(row => {
                const itemName = row.dataset.itemName.toLowerCase();
                const matchesSearch = itemName.includes(query);
                const passesFilters = passesDropdownFilters(row);

                row.style.display = (matchesSearch && passesFilters) ? '' : 'none';
            });
        });

        // Blur search input on Enter key (dismiss mobile keyboard)
        filterInput.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur();
            }
        });

        filterClear.addEventListener('click', function () {
            filterInput.value = '';
            filterWrapper.classList.remove('has-value');
            applyFilters(); // Reapply just the dropdown filters
            filterInput.blur();
        });

        // =========================================================================
        // AUTOCOMPLETE FOR NEW FLIP MODAL
        // =========================================================================

        const input = document.getElementById('itemName');
        const results = document.getElementById('autocompleteResults');
        let activeIndex = -1;
        let items = [];
        
        // =============================================================================
        // SELECTED ITEM TRACKING FOR BUY LIMIT FEATURE
        // =============================================================================
        // What: Tracks the currently selected item's ID for the Buy Limit button
        // Why: The Buy Limit button needs the item ID to fetch the GE buy limit from the API
        // How: Set when user selects an item from autocomplete, cleared when input changes
        // selectedItemId: The OSRS item ID of the currently selected item (null if none)
        let selectedItemId = null;
        
        // btnBuyLimit: Reference to the Buy Limit button element
        // Why: Needed to update button state (enabled/disabled) and handle clicks
        const btnBuyLimit = document.getElementById('btnBuyLimit');
        
        // quantityInput: Reference to the quantity input field
        // Why: Needed to populate with the buy limit value when button is clicked
        const quantityInput = document.getElementById('quantity');
        
        /**
         * Updates the Buy Limit button state based on whether an item is selected.
         * 
         * What: Enables/disables the Buy Limit button and updates its tooltip
         * Why: Button should only be clickable when an item is selected
         * How: Checks selectedItemId and updates disabled property and data-tooltip attribute
         */
        function updateBuyLimitButtonState() {
            if (selectedItemId) {
                // Item is selected - enable the button
                btnBuyLimit.disabled = false;
                btnBuyLimit.setAttribute('data-tooltip', 'Click to auto-fill quantity with the GE buy limit for this item');
            } else {
                // No item selected - disable the button
                btnBuyLimit.disabled = true;
                btnBuyLimit.setAttribute('data-tooltip', 'Select an item first');
            }
        }

        input.addEventListener('input', function () {
            const query = this.value;
            
            // =============================================================================
            // CLEAR SELECTED ITEM WHEN USER TYPES
            // =============================================================================
            // What: Clears the selectedItemId when user modifies the input text
            // Why: If user changes the text, the previous selection is no longer valid
            // How: Set selectedItemId to null and update button state
            selectedItemId = null;
            updateBuyLimitButtonState();
            
            if (query.length < 2) {
                results.classList.remove('show');
                return;
            }

            fetch(`/api/items/?q=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(data => {
                    items = data;
                    activeIndex = -1;
                    if (data.length === 0) {
                        results.classList.remove('show');
                        return;
                    }
                    // =============================================================================
                    // STORE ITEM ID IN AUTOCOMPLETE RESULTS
                    // =============================================================================
                    // What: Adds data-id attribute to each autocomplete item
                    // Why: Need the item ID when user selects an item for the Buy Limit feature
                    // How: Include item.id in the data-id attribute of each autocomplete item div
                    results.innerHTML = data.map((item, i) =>
                        `<div class="autocomplete-item" data-index="${i}" data-name="${item.name}" data-id="${item.id}">${item.name}</div>`
                    ).join('');
                    results.classList.add('show');
                });
        });

        input.addEventListener('keydown', function (e) {
            const itemElements = results.querySelectorAll('.autocomplete-item');
            if (!results.classList.contains('show') || itemElements.length === 0) return;

            if (e.key === 'ArrowDown' || e.key === 'Tab') {
                e.preventDefault();
                activeIndex = Math.min(activeIndex + 1, itemElements.length - 1);
                updateActive(itemElements);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                activeIndex = Math.max(activeIndex - 1, 0);
                updateActive(itemElements);
            } else if (e.key === 'Enter' && activeIndex >= 0) {
                e.preventDefault();
                // Pass both name and id to selectItem
                const selectedElement = itemElements[activeIndex];
                selectItem(selectedElement.dataset.name, selectedElement.dataset.id);
            }
        });

        results.addEventListener('click', function (e) {
            if (e.target.classList.contains('autocomplete-item')) {
                // Pass both name and id to selectItem
                selectItem(e.target.dataset.name, e.target.dataset.id);
            }
        });

        function updateActive(itemElements) {
            itemElements.forEach((el, i) => {
                el.classList.toggle('active', i === activeIndex);
            });
            if (activeIndex >= 0) {
                itemElements[activeIndex].scrollIntoView({block: 'nearest'});
            }
        }

        /**
         * Selects an item from the autocomplete dropdown.
         * 
         * What: Sets the input value and stores the selected item's ID
         * Why: Need to track selected item for Buy Limit feature
         * How: Updates input value, stores item ID, hides dropdown, updates button state
         * 
         * @param {string} name - The name of the selected item
         * @param {string} id - The OSRS item ID of the selected item
         */
        function selectItem(name, id) {
            input.value = name;
            // Store the selected item's ID for the Buy Limit button
            selectedItemId = id;
            results.classList.remove('show');
            activeIndex = -1;
            // Enable the Buy Limit button now that an item is selected
            updateBuyLimitButtonState();
        }

        document.addEventListener('click', function (e) {
            if (!input.contains(e.target) && !results.contains(e.target)) {
                results.classList.remove('show');
            }
        });
        
        // =============================================================================
        // BUY LIMIT BUTTON CLICK HANDLER
        // =============================================================================
        // What: Fetches the GE buy limit for the selected item and fills the quantity input
        // Why: QOL feature - saves user from manually looking up buy limits
        // How: Makes API request to /api/item/data/, extracts limit, populates quantity field
        btnBuyLimit.addEventListener('click', async function() {
            // Safety check - shouldn't happen since button is disabled when no item selected
            if (!selectedItemId) {
                return;
            }
            
            // =============================================================================
            // SHOW LOADING STATE
            // =============================================================================
            // What: Adds loading class to show spinner and prevent double-clicks
            // Why: API request may take a moment, user needs visual feedback
            // How: Add 'loading' class and disable button during request
            btnBuyLimit.classList.add('loading');
            btnBuyLimit.disabled = true;
            
            try {
                // =============================================================================
                // FETCH ITEM DATA FROM API
                // =============================================================================
                // What: Makes request to the item data API to get the buy limit
                // Why: The buy limit is stored in the OSRS Wiki mapping data
                // How: GET request to /api/item/data/ with the item ID as a query parameter
                const response = await fetch(`/api/item/data/?id=${encodeURIComponent(selectedItemId)}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch item data');
                }
                
                const data = await response.json();
                
                // =============================================================================
                // CHECK IF ITEM HAS A BUY LIMIT
                // =============================================================================
                // What: Validates that the item has a buy limit defined
                // Why: Some items don't have buy limits (e.g., untradeable items, bonds)
                // How: Check if data.limit exists and is not null/undefined
                if (data.limit === null || data.limit === undefined) {
                    alert('This item does not have a GE buy limit.');
                    return;
                }
                
                // =============================================================================
                // POPULATE QUANTITY INPUT
                // =============================================================================
                // What: Sets the quantity input value to the item's buy limit
                // Why: This is the main purpose of the Buy Limit button
                // How: Set the input's value property to the limit from the API response
                quantityInput.value = data.limit;
                
            } catch (error) {
                // =============================================================================
                // HANDLE ERRORS
                // =============================================================================
                // What: Shows error message if API request fails
                // Why: User needs to know something went wrong
                // How: Display alert with error information
                console.error('Error fetching buy limit:', error);
                alert('Failed to fetch buy limit. Please try again.');
                
            } finally {
                // =============================================================================
                // RESTORE BUTTON STATE
                // =============================================================================
                // What: Removes loading state and re-enables button
                // Why: Need to allow user to try again or use button for different item
                // How: Remove 'loading' class and re-enable button
                btnBuyLimit.classList.remove('loading');
                btnBuyLimit.disabled = false;
            }
        });

        // Date "Now" button and default date
        const dateInput = document.getElementById('date');
        const setNowBtn = document.getElementById('setNowBtn');

        function setDateToNow() {
            const now = new Date();
            // Format for datetime-local input: YYYY-MM-DDTHH:MM
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            dateInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        setNowBtn.addEventListener('click', setDateToNow);

        // Set default date and auto-focus when modal opens
        const newFlipModal = document.getElementById('newFlipModal');
        newFlipModal.addEventListener('shown.bs.modal', function () {
            setDateToNow();
            input.focus();
        });

        // Clear form when modal closes
        newFlipModal.addEventListener('hidden.bs.modal', function () {
            input.value = '';
            document.getElementById('price').value = '';
            document.getElementById('quantity').value = '';
            document.getElementById('type').value = 'buy';
            dateInput.value = '';
            results.classList.remove('show');
            activeIndex = -1;
            
            // =============================================================================
            // RESET BUY LIMIT BUTTON STATE ON MODAL CLOSE
            // =============================================================================
            // What: Clears the selected item ID and resets the Buy Limit button
            // Why: When modal closes, form is cleared so button should return to disabled state
            // How: Set selectedItemId to null and call updateBuyLimitButtonState
            selectedItemId = null;
            updateBuyLimitButtonState();
        });

        // Prevent Enter from submitting form unless Add Flip button is focused
        newFlipModal.querySelector('form').addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                const activeElement = document.activeElement;
                const submitBtn = newFlipModal.querySelector('.btn-add-flip');
                // Allow Enter only if submit button is focused or in autocomplete selection
                if (activeElement !== submitBtn && activeElement.id !== 'itemName') {
                    e.preventDefault();
                }
                // If in autocomplete and selecting item, don't submit
                if (activeElement.id === 'itemName' && results.classList.contains('show')) {
                    e.preventDefault();
                }
                // If on date input, show the picker instead of submitting
                if (activeElement.id === 'date') {
                    e.preventDefault();
                    activeElement.showPicker();
                }
            }
        });

        // Table sorting
        const table = document.getElementById('flipsTable');
        const headers = table.querySelectorAll('th.sortable');
        let currentCol = -1;
        let currentAsc = true;

        headers.forEach(header => {
            header.addEventListener('click', function () {
                const col = parseInt(this.dataset.col);
                const type = this.dataset.type;

                // Toggle direction if same column, otherwise start ascending
                if (col === currentCol) {
                    currentAsc = !currentAsc;
                } else {
                    currentCol = col;
                    currentAsc = true;
                }

                // Deactivate filter sort when column header is clicked
                deactivateFilterSort();

                // Reset all headers
                headers.forEach(h => h.classList.remove('asc', 'desc'));

                // Set current sort direction
                this.classList.add(currentAsc ? 'asc' : 'desc');

                sortTable(col, type, currentAsc);
            });
        });

        function sortTable(col, type, asc) {
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                let aVal, bVal;
                const aCell = a.cells[col];
                const bCell = b.cells[col];

                if (type === 'number') {
                    aVal = parseFloat(aCell.dataset.value) || 0;
                    bVal = parseFloat(bCell.dataset.value) || 0;
                } else {
                    aVal = aCell.textContent.trim().toLowerCase();
                    bVal = bCell.textContent.trim().toLowerCase();
                }

                if (aVal < bVal) return asc ? -1 : 1;
                if (aVal > bVal) return asc ? 1 : -1;
                return 0;
            });

            rows.forEach(row => tbody.appendChild(row));
        }

        // Delete flip functionality
        const deleteBtn = document.getElementById('deleteFlipBtn');
        let deleteMode = false;
        let isProcessing = false;
        let selectedRow = null;

        deleteBtn.addEventListener('click', function () {
            if (!deleteMode) {
                deleteMode = true;
                deleteBtn.textContent = 'Click a row to delete';
                deleteBtn.classList.add('delete-mode-active');
                table.classList.add('delete-mode');
            } else {
                cancelDeleteMode();
            }
        });

        function cancelDeleteMode() {
            deleteMode = false;
            isProcessing = false;
            deleteBtn.textContent = 'Delete Flip';
            deleteBtn.classList.remove('delete-mode-active');
            table.classList.remove('delete-mode');
            // Clear any selected row
            if (selectedRow) {
                selectedRow.classList.remove('selected-for-delete');
                selectedRow = null;
            }
        }

        table.querySelector('tbody').addEventListener('click', function (e) {
            if (!deleteMode || isProcessing) return;

            const row = e.target.closest('tr');
            if (!row || !row.dataset.itemId) return;

            e.preventDefault();
            e.stopImmediatePropagation();

            isProcessing = true;
            deleteMode = false;

            // Highlight the selected row
            row.classList.add('selected-for-delete');
            selectedRow = row;

            const itemName = row.dataset.itemName;
            const itemId = row.dataset.itemId;

            // Show delete confirmation modal
            document.getElementById('deleteItemName').textContent = itemName;
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));

            // Set up confirm button handler
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', function () {
                // Create and submit a form to delete
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = `/flips/delete/${itemId}/`;

                const csrf = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const csrfInput = document.createElement('input');
                csrfInput.type = 'hidden';
                csrfInput.name = 'csrfmiddlewaretoken';
                csrfInput.value = csrf;
                form.appendChild(csrfInput);

                document.body.appendChild(form);
                form.submit();
            });

            // Handle modal close (cancel)
            document.getElementById('deleteConfirmModal').addEventListener('hidden.bs.modal', function () {
                cancelDeleteMode();
            }, {once: true});

            deleteModal.show();
        });

        // Dismiss notification function
        window.dismissNotification = function (btn) {
            const notification = btn.closest('.success-notification');
            if (notification) {
                notification.classList.add('dismissing');
                setTimeout(() => notification.remove(), 300);
            }
        };

        // Auto-dismiss notifications after 5 seconds
        document.querySelectorAll('.success-notification').forEach(notification => {
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.classList.add('dismissing');
                    setTimeout(() => notification.remove(), 300);
                }
            }, 5000);
        });

        // Initialize mobile sort indicator state on page load
        syncMobileSortIndicator();

        // =========================================================================
        // HISTORICAL VIEW FUNCTIONALITY
        // =========================================================================
        // What: Allows users to view their portfolio's unrealized P&L at a past date
        // Why: Enables analysis of missed opportunities and portfolio evolution over time
        // How: Fetches historical prices from OSRS Wiki API and recalculates unrealized net
        //      without modifying any database records
        // =========================================================================

        // Note: isHistoricalMode is declared at the top of the script (near loadFlipsData)
        // to allow the auto-refresh to check if we're in historical mode

        /**
         * historicalRefreshInterval: Stores the interval ID for auto-refresh
         * Why: We need to pause auto-refresh when viewing historical data and resume later
         */
        let historicalRefreshInterval = null;

        /**
         * originalFlipsData: Stores the original real-time data before switching to historical
         * Why: Allows quick restoration of real-time data without re-fetching
         */
        let originalFlipsData = null;

        // DOM element references for historical view components
        const historicalModal = document.getElementById('historicalModal');
        const historicalDateInput = document.getElementById('historicalDateInput');
        const historicalBanner = document.getElementById('historicalBanner');
        const historicalBannerDate = document.getElementById('historicalBannerDate');
        const submitHistoricalBtn = document.getElementById('submitHistoricalView');
        const returnToRealtimeBtn = document.getElementById('returnToRealtimeBtn');
        const historicalViewBtn = document.getElementById('historicalViewBtn');
        const presetButtons = document.querySelectorAll('.btn-preset');

        /**
         * Sets the date input max to yesterday (can't view future or today's historical data)
         * What: Configures the historical date picker's allowed date range
         * Why: Historical data API only returns past data, today's data is "current"
         *      Users should be able to select any past date for historical analysis
         * How: Sets max date to yesterday (no future/today), no min date restriction
         *      to allow selecting any historical date the user has data for
         */
        function initializeDatePicker() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            // Format as YYYY-MM-DD for the input max attribute
            // What: Converts yesterday's date to the format required by HTML date input
            // Why: Prevents users from selecting today or future dates (no historical data exists)
            const maxDate = yesterday.toISOString().split('T')[0];
            historicalDateInput.max = maxDate;
            
            // Note: No min date is set to allow users to select any past date
            // The user's actual data availability will determine if results are shown
        }

        /**
         * Calculates the date X days ago and formats it for the date input
         * @param {number} days - Number of days to go back
         * @returns {string} Date in YYYY-MM-DD format
         */
        function getDateDaysAgo(days) {
            const date = new Date();
            date.setDate(date.getDate() - days);
            return date.toISOString().split('T')[0];
        }

        /**
         * Formats a date string for display in the banner
         * @param {string} dateStr - Date in YYYY-MM-DD format
         * @returns {string} Formatted date string (e.g., "January 15, 2026")
         */
        function formatDateForDisplay(dateStr) {
            const date = new Date(dateStr + 'T00:00:00');
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        /**
         * Shows the historical banner and updates its content
         * @param {string} dateStr - The historical date being viewed
         */
        function showHistoricalBanner(dateStr) {
            historicalBannerDate.textContent = formatDateForDisplay(dateStr);
            historicalBanner.style.display = 'block';
            historicalViewBtn.classList.add('active');
        }

        /**
         * Hides the historical banner
         */
        function hideHistoricalBanner() {
            historicalBanner.style.display = 'none';
            historicalViewBtn.classList.remove('active');
        }

        /**
         * Dims the Realized Net stat card when viewing historical data
         * Why: Realized net is not affected by historical prices, so dimming indicates
         *      it's not relevant to the historical view
         */
        function dimRealizedNetCard() {
            const realizedCard = document.getElementById('statRealized');
            realizedCard.classList.add('dimmed');
        }

        /**
         * Undims the Realized Net stat card when returning to real-time view
         */
        function undimRealizedNetCard() {
            const realizedCard = document.getElementById('statRealized');
            realizedCard.classList.remove('dimmed');
        }

        /**
         * Notifies the user about items that were skipped due to missing historical data
         * @param {Array} skippedItems - Array of objects with item_name and reason
         */
        function notifySkippedItems(skippedItems) {
            if (!skippedItems || skippedItems.length === 0) return;

            // Build notification message
            const itemNames = skippedItems.map(item => item.item_name).join(', ');
            const message = skippedItems.length === 1
                ? `Note: "${itemNames}" was excluded - no historical price data available for this date.`
                : `Note: ${skippedItems.length} items were excluded due to missing historical data: ${itemNames}`;

            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'historical-skipped-notification';
            notification.innerHTML = `
                <div class="notification-content">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>${message}</span>
                    <button class="notification-dismiss">&times;</button>
                </div>
            `;

            // Insert notification after the banner
            historicalBanner.insertAdjacentElement('afterend', notification);

            // Add dismiss functionality
            notification.querySelector('.notification-dismiss').addEventListener('click', () => {
                notification.remove();
            });

            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 10000);
        }

        /**
         * Pauses the auto-refresh interval when viewing historical data
         * Why: We don't want to overwrite historical data with live data while user is viewing
         */
        function pauseAutoRefresh() {
            // The auto-refresh is set with setInterval in the main code
            // We'll track the historical mode and skip refreshes when in that mode
            isHistoricalMode = true;
        }

        /**
         * Resumes the auto-refresh interval when returning to real-time view
         */
        function resumeAutoRefresh() {
            isHistoricalMode = false;
        }

        /**
         * Fetches historical data from the API and updates the UI
         * @param {string} dateStr - Date in YYYY-MM-DD format
         */
        async function fetchHistoricalData(dateStr) {
            // Close the modal immediately so the loading spinner is visible
            const modalInstance = bootstrap.Modal.getInstance(historicalModal);
            if (modalInstance) {
                modalInstance.hide();
            }

            // Store original data before fetching historical (if not already stored)
            if (!originalFlipsData && flipsData) {
                originalFlipsData = JSON.parse(JSON.stringify(flipsData));
            }

            // Show loading state
            const tableBody = document.getElementById('flipsTableBody');
            tableBody.innerHTML = `
                <tr>
                    <td colspan="8" class="text-center" style="padding: 20px; color: var(--muted);">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <div class="spinner-border spinner-border-sm" role="status" style="color: var(--info);"></div>
                            <span>Loading historical data for ${formatDateForDisplay(dateStr)}...</span>
                        </div>
                    </td>
                </tr>
            `;

            try {
                const response = await fetch(`/api/flips/historical/?date=${dateStr}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // Update the table and stats with historical data
                flipsData = data;
                updateStats(data.stats);
                renderTableRows(data.items);

                // Show the historical banner
                showHistoricalBanner(dateStr);

                // Dim the realized net card
                dimRealizedNetCard();

                // Pause auto-refresh
                pauseAutoRefresh();

                // Notify about skipped items
                notifySkippedItems(data.skipped_items);

            } catch (error) {
                console.error('Error fetching historical data:', error);
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="8" class="text-center text-danger" style="padding: 20px;">
                            Error loading historical data: ${error.message}. Please try again.
                        </td>
                    </tr>
                `;
            }
        }

        /**
         * Returns to real-time data view
         * Restores the original live data or fetches fresh data
         */
        function returnToRealTime() {
            // Remove any skipped items notifications
            document.querySelectorAll('.historical-skipped-notification').forEach(el => el.remove());

            // Hide the banner
            hideHistoricalBanner();

            // Undim the realized net card
            undimRealizedNetCard();

            // Resume auto-refresh
            resumeAutoRefresh();

            // Restore original data or fetch fresh
            if (originalFlipsData) {
                flipsData = originalFlipsData;
                updateStats(flipsData.stats);
                renderTableRows(flipsData.items);
                originalFlipsData = null;
            }

            // Fetch fresh data to ensure we have the latest
            loadFlipsData();
        }

        // =========================================================================
        // EVENT LISTENERS FOR HISTORICAL VIEW
        // =========================================================================

        // Initialize date picker constraints
        initializeDatePicker();

        // Preset button click handlers
        presetButtons.forEach(btn => {
            btn.addEventListener('click', function() {
                const days = parseInt(this.dataset.days);
                const dateStr = getDateDaysAgo(days);
                historicalDateInput.value = dateStr;

                // Update visual selection state
                presetButtons.forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Date input change handler (clears preset selection when manually changed)
        historicalDateInput.addEventListener('change', function() {
            presetButtons.forEach(b => b.classList.remove('selected'));
        });

        // Submit historical view button handler
        submitHistoricalBtn.addEventListener('click', function() {
            const dateStr = historicalDateInput.value;
            if (!dateStr) {
                alert('Please select a date or use one of the quick presets.');
                return;
            }
            fetchHistoricalData(dateStr);
        });

        // Return to real-time button handler
        returnToRealtimeBtn.addEventListener('click', returnToRealTime);

        // Reset modal state when closed without submitting
        historicalModal.addEventListener('hidden.bs.modal', function() {
            // Only reset if not in historical mode (user cancelled)
            if (!isHistoricalMode) {
                historicalDateInput.value = '';
                presetButtons.forEach(b => b.classList.remove('selected'));
            }
        });

        // Modify the auto-refresh to respect historical mode
        // Override the existing setInterval behavior
        const originalLoadFlipsData = loadFlipsData;
        window.loadFlipsDataWithHistoricalCheck = function() {
            if (!isHistoricalMode) {
                originalLoadFlipsData();
            }
        };

        // Clear the existing interval and set up a new one that respects historical mode
        // Note: We can't actually clear the original interval since we don't have its ID,
        // but we can make the loadFlipsData function check the mode
    });
</script>
{% endblock %}
